R:/LIAT.AI/question2-calldata/contracts/helpers/CalldataWrapper.sol
  1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
  2 |     | pragma solidity ^0.8.28;
  3 |     | 
  4 |     | import "../utilities/Calldata.sol";
  5 |     | import {
  6 |     |   getFreeMemoryPointer,
  7 |     |   getHookInputByteCount,
  8 |     |   _hookInputByteCount_
  9 |     | } from "../utilities/Memory.sol";
 10 |     | import {writeStorage} from "../utilities/Storage.sol";
 11 |     | 
 12 |     | /// @title This contract exposes the internal functions of 'Calldata.sol' for 
 13 |     | /// testing purposes.
 14 | *   | contract CalldataWrapper {
 15 |     |   function _readInitializeInput() public returns (
 16 |     |     KernelCompact kernelCompact
 17 |     |   ) {
 18 |     |     kernelCompact = readInitializeInput();
 19 |     |     uint256 freeMemoryPointer = getFreeMemoryPointer();
 20 |     |     assembly {
 21 |     |       log1(0, freeMemoryPointer, 0)
 22 |     |     }
 23 |     |   }
 24 |     | 
 25 |     |   function _readModifyPositionInput() public {
 26 |     |     readModifyPositionInput();
 27 |     |     uint256 freeMemoryPointer = getFreeMemoryPointer();
 28 |     |     assembly {
 29 |     |       log1(0, freeMemoryPointer, 0)
 30 |     |     }
 31 |     |   }
 32 |     | 
 33 |     |   function _readDonateInput() public {
 34 |     |     readDonateInput();
 35 |     |     uint256 freeMemoryPointer = getFreeMemoryPointer();
 36 | *   |     assembly {
 37 |     |       log1(0, freeMemoryPointer, 0)
 38 |     |     }
 39 |     |   }
 40 |     | 
 41 |     |   function _readModifyKernelInput() public returns (
 42 |     |     KernelCompact kernelCompact
 43 |     |   ) {
 44 |     |     kernelCompact = readModifyKernelInput();
 45 |     |     uint256 freeMemoryPointer = getFreeMemoryPointer();
 46 |     |     assembly {
 47 |     |       log1(0, freeMemoryPointer, 0)
 48 |     |     }
 49 |     |   }
 50 |     | 
 51 |     |   function _readModifyPoolGrowthPortionInput() public {
 52 |     |     readModifyPoolGrowthPortionInput();
 53 |     |     uint256 freeMemoryPointer = getFreeMemoryPointer();
 54 |     |     assembly {
 55 |     |       log1(0, freeMemoryPointer, 0)
 56 |     |     }
 57 |     |   }
 58 |     | 
 59 |     |   function _readUpdateGrowthPortionsInput() public {
 60 |     |     readUpdateGrowthPortionsInput();
 61 |     |     uint256 freeMemoryPointer = getFreeMemoryPointer();
 62 |     |     assembly {
 63 |     |       log1(0, freeMemoryPointer, 0)
 64 |     |     }
 65 |     |   }
 66 |     | 
 67 |     |   function _readSwapInput() public {
 68 |     |     readSwapInput();
 69 |     |     uint256 hookInputByteCount = getHookInputByteCount();
 70 |     |     assembly {
 71 |     |       log1(
 72 |     |         0,
 73 |     |         add(add(_hookInputByteCount_, hookInputByteCount), 32),
 74 |     |         0
 75 |     |       )
 76 |     |     }
 77 |     |   }
 78 |     | 
 79 |     |   function _readCollectInput() public {
 80 |     |     readCollectInput();
 81 |     |     uint256 freeMemoryPointer = getFreeMemoryPointer();
 82 |     |     assembly {
 83 |     |       log1(0, freeMemoryPointer, 0)
 84 |     |     }
 85 |     |   }
 86 |     | }

R:/LIAT.AI/question2-calldata/contracts/interfaces/INofeeswap.sol
   1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
   2 |     | pragma solidity ^0.8.28;
   3 |     | 
   4 |     | import {ISentinel} from "./ISentinel.sol";
   5 |     | import {Tag} from "../utilities/Tag.sol";
   6 |     | import {X59} from "../utilities/X59.sol";
   7 |     | import {IStorageAccess} from "./IStorageAccess.sol";
   8 |     | import {ITransientAccess} from "./ITransientAccess.sol";
   9 |     | 
  10 |     | /// @notice Interface for the Nofeeswap contract.
  11 |     | interface INofeeswap is IStorageAccess, ITransientAccess {
  12 |     |   /// @notice See ERC6909 specifications.
  13 |     |   function supportsInterface(
  14 |     |     bytes4 interfaceId
  15 |     |   ) external pure returns (bool);
  16 |     | 
  17 |     |   /// @notice See ERC6909 specifications.
  18 |     |   function balanceOf(
  19 |     |     address owner,
  20 |     |     Tag tag
  21 |     |   ) external view returns (
  22 |     |     uint256 amount
  23 |     |   );
  24 |     | 
  25 |     |   /// @notice See ERC6909 specifications.
  26 |     |   function allowance(
  27 |     |     address owner,
  28 |     |     address spender,
  29 |     |     Tag tag
  30 |     |   ) external view returns (
  31 |     |     uint256 amount
  32 |     |   );
  33 |     | 
  34 |     |   /// @notice See ERC6909 specifications.
  35 |     |   function isOperator(
  36 |     |     address owner,
  37 |     |     address spender
  38 |     |   ) external view returns (
  39 |     |     bool status
  40 |     |   );
  41 |     | 
  42 |     |   /// @notice See ERC6909 specifications.
  43 |     |   function transfer(
  44 |     |     address receiver,
  45 |     |     Tag tag,
  46 |     |     uint256 amount
  47 |     |   ) external returns (
  48 |     |     bool success
  49 |     |   );
  50 |     | 
  51 |     |   /// @notice See ERC6909 specifications.
  52 |     |   function transferFrom(
  53 |     |     address sender,
  54 |     |     address receiver,
  55 |     |     Tag tag,
  56 |     |     uint256 amount
  57 |     |   ) external returns (
  58 |     |     bool success
  59 |     |   );
  60 |     | 
  61 |     |   /// @notice See ERC6909 specifications.
  62 |     |   function approve(
  63 |     |     address spender,
  64 |     |     Tag tag,
  65 |     |     uint256 amount
  66 |     |   ) external returns (
  67 |     |     bool success
  68 |     |   );
  69 |     | 
  70 |     |   /// @notice See ERC6909 specifications.
  71 |     |   function setOperator(
  72 |     |     address spender,
  73 |     |     bool approved
  74 |     |   ) external returns (
  75 |     |     bool success
  76 |     |   );
  77 |     | 
  78 |     |   /// @notice Mints/burns singleton balance. This results in a transient
  79 |     |   /// storage balance which must be settled.
  80 |     |   ///
  81 |     |   /// transient balance <-> singleton balance
  82 |     |   ///
  83 |     |   /// @param owner Balance owner.
  84 |     |   /// @param tag The tag whose balance to be modified.
  85 |     |   /// @param amount The amount to be added (positive) or removed (negative)
  86 |     |   /// to/from the owner's singleton balance.
  87 |     |   function modifyBalance(
  88 |     |     address owner,
  89 |     |     Tag tag,
  90 |     |     int256 amount
  91 |     |   ) external;
  92 |     | 
  93 |     |   /// @notice Mints/burns singleton double balance of tags 0 and 1. Can be used
  94 |     |   /// for gas efficient transactions by eliminating the need to update two 
  95 |     |   /// storage slots. This results in transient storage balances which must be 
  96 |     |   /// settled.
  97 |     |   ///
  98 |     |   /// transient balance of tags 0 and 1 <-> singleton double balance
  99 |     |   ///
 100 |     |   /// @param owner Balance owner.
 101 |     |   /// @param tag0 The arithmetically smaller tag.
 102 |     |   /// @param tag1 The arithmetically larger tag.
 103 |     |   /// @param amount0 The amount of tag0 to be added (positive) or removed 
 104 |     |   /// (negative) to/from the owner's singleton balance.
 105 |     |   /// @param amount1 The amount of tag1 to be added (positive) or removed 
 106 |     |   /// (negative) to/from the owner's singleton balance.
 107 |     |   function modifyBalance(
 108 |     |     address owner,
 109 |     |     Tag tag0,
 110 |     |     Tag tag1,
 111 |     |     int256 amount0,
 112 |     |     int256 amount1
 113 |     |   ) external;
 114 |     | 
 115 |     |   /// @notice This function gives access to the following protocol methods that
 116 |     |   /// are safeguarded against reentrancy:
 117 |     |   ///
 118 |     |   ///   'INofeeswap.clear(Tag,uint256)'
 119 |     |   ///   'INofeeswap.take(address,address,uint256)'
 120 |     |   ///   'INofeeswap.take(address,uint256,address,uint256)'
 121 |     |   ///   'INofeeswap.take(address,uint256,address,uint256,bytes)'
 122 |     |   ///   'INofeeswap.settle(address)'
 123 |     |   ///   'INofeeswap.transferTransientBalanceFrom(address,address,Tag,uint256)'
 124 |     |   ///   'INofeeswap.modifyBalance(address,Tag,int256)'
 125 |     |   ///   'INofeeswap.modifyBalance(address,Tag,Tag,int256,int256)'
 126 |     |   ///   'INofeeswap.swap(uint256,int256,X59,uint256,bytes)'
 127 |     |   ///   'INofeeswapDelegatee.modifyPosition(uint256,X59,X59,int256,bytes)'
 128 |     |   ///   'INofeeswapDelegatee.donate(uint256,uint256,bytes)'
 129 |     |   ///
 130 |     |   /// @param unlockTarget The target contract address which must implement 
 131 |     |   /// 'IUnlockCallback.sol'.
 132 |     |   /// @param data The data/instructions to be passed to the target contract.
 133 |     |   /// @return result The output from the target contract.
 134 |     |   function unlock(
 135 |     |     address unlockTarget,
 136 |     |     bytes calldata data
 137 |     |   ) external payable returns (
 138 |     |     bytes memory result
 139 |     |   );
 140 |     | 
 141 |     |   /// @notice WARNING - Once a balance is cleared, the corresponding funds
 142 |     |   /// become permanently inaccessible and remain locked within the contract.
 143 |     |   /// Executing a clear call will erase the entire balance owed to the caller
 144 |     |   /// without initiating any outbound transfer.
 145 |     |   /// @notice Clears transient balance owed to 'msg.sender'.
 146 |     |   /// @param tag The tag whose transient balance to be cleared.
 147 |     |   /// @param amount The amount to be cleared which must be equal to the current
 148 |     |   /// transient balance of the caller.
 149 |     |   function clear(
 150 |     |     Tag tag,
 151 |     |     uint256 amount
 152 |     |   ) external;
 153 |     | 
 154 |     |   /// @notice Pays native or ERC-20 assets from the protocol to 'to'. This
 155 |     |   /// results in a transient storage balance which must be settled.
 156 |     |   ///
 157 |     |   /// transient balance -> 'to' wallet
 158 |     |   ///
 159 |     |   /// @param token ERC-20 or native tokens to be taken from the protocol's
 160 |     |   /// wallet.
 161 |     |   /// @param to The target address.
 162 |     |   /// @param amount The amount of tokens to be taken from the protocol.
 163 |     |   function take(
 164 |     |     address token,
 165 |     |     address to,
 166 |     |     uint256 amount
 167 |     |   ) external;
 168 |     | 
 169 |     |   /// @notice Pays ERC-6909 assets from the protocol to 'to'. This results in a
 170 |     |   /// transient storage balance which must be settled.
 171 |     |   ///
 172 |     |   /// transient balance -> 'to' wallet
 173 |     |   ///
 174 |     |   /// @param token ERC-6909 address.
 175 |     |   /// @param tokenId Multi-token id to be taken from the protocol's wallet.
 176 |     |   /// @param to The target address.
 177 |     |   /// @param amount The amount of tokens to be taken from the protocol.
 178 |     |   function take(
 179 |     |     address token,
 180 |     |     uint256 tokenId,
 181 |     |     address to,
 182 |     |     uint256 amount
 183 |     |   ) external;
 184 |     | 
 185 |     |   /// @notice Pays ERC-1155 assets from the protocol to 'to'. This results in a
 186 |     |   /// transient storage balance which must be settled.
 187 |     |   ///
 188 |     |   /// transient balance -> 'to' wallet
 189 |     |   ///
 190 |     |   /// @param token ERC-1155 address.
 191 |     |   /// @param tokenId Multi-token id to be taken from the protocol's wallet.
 192 |     |   /// @param to The target address.
 193 |     |   /// @param amount The amount of tokens to be taken from the protocol.
 194 |     |   /// @param transferData Data to be used from 'IERC1155.safeTransferFrom'.
 195 |     |   function take(
 196 |     |     address token,
 197 |     |     uint256 tokenId,
 198 |     |     address to,
 199 |     |     uint256 amount,
 200 |     |     bytes calldata transferData
 201 |     |   ) external;
 202 |     | 
 203 |     |   /// @notice Synchronizes the protocol ERC-20 balance. Should be called prior
 204 |     |   /// to ERC-20 transfers to the protocol.
 205 |     |   /// @param token ERC-20 address to be synced.
 206 |     |   function sync(
 207 |     |     address token
 208 |     |   ) external;
 209 |     | 
 210 |     |   /// @notice Synchronizes the protocol ERC-1155 or ERC-6909 balance. Should be 
 211 |     |   /// called prior to ERC-1155 or ERC-6909 transfers to the protocol.
 212 |     |   /// @param token ERC-1155 or ERC-6909 address to be synced.
 213 |     |   /// @param tokenId Multi-token id to be synced.
 214 |     |   function sync(
 215 |     |     address token,
 216 |     |     uint256 tokenId
 217 |     |   ) external;
 218 |     | 
 219 |     |   /// @notice Should be called after ERC-20, ERC6909, or ERC1155 transfers to
 220 |     |   /// the protocol to update transient balances. Can be used to send native
 221 |     |   /// tokens to the protocol to settle native transient balance of 
 222 |     |   /// 'msg.sender'.
 223 |     |   /// @return paid The amount paid.
 224 |     |   function settle() external payable returns (
 225 |     |     uint256 paid
 226 |     |   );
 227 |     | 
 228 |     |   /// @notice Transfers transient balance from 'sender' to 'receiver'. Can be
 229 |     |   /// used to settle on behalf of other accounts.
 230 |     |   /// @param sender The sender's address.
 231 |     |   /// @param receiver The recipient's address.
 232 |     |   /// @param tag The tag whose balance to be transferred.
 233 |     |   /// @param amount The amount to be transferred.
 234 |     |   function transferTransientBalanceFrom(
 235 |     |     address sender,
 236 |     |     address receiver,
 237 |     |     Tag tag,
 238 |     |     uint256 amount
 239 |     |   ) external;
 240 |     | 
 241 |     |   /// @notice Gives access to 'NofeeswapDelegatee.sol' functionalities.
 242 |     |   /// @param input Encoded input via 'abi.encodeWithSelector' to be passed as 
 243 |     |   /// delegate call to 'NofeeswapDelegatee.sol'.
 244 |     |   /// @return output0 The first output slot.
 245 |     |   /// @return output1 The second output slot.
 246 |     |   function dispatch(
 247 |     |     bytes calldata input
 248 |     |   ) external returns (
 249 |     |     int256 output0,
 250 |     |     int256 output1
 251 |     |   );
 252 |     | 
 253 |     |   /// @notice Performs a swap.
 254 |     |   /// @param poolId The target pool identifier.
 255 |     |   /// @param amountSpecified The amount to be given to (positive) or taken 
 256 |     |   /// from (negative) the pool.
 257 |     |   /// @param logPriceLimit The limit logPrice constraint. This value is equal
 258 |     |   /// to '(2 ** 59) * log(p)' where 'p' is the intended price limit and 'log'
 259 |     |   /// denotes the natural logarithm operator.
 260 |     |   /// @param zeroForOne If ‘zeroForOne & ((1 << 128) - 1) == 0' then tag0 is
 261 |     |   /// taken from and tag1 is given to the pool. If 
 262 |     |   /// ‘zeroForOne & ((1 << 128) - 1) == 1' then tag1 is taken from and tag0 is
 263 |     |   /// given to the pool. If ‘zeroForOne & ((1 << 128) - 1)’ is greater than 1,
 264 |     |   /// then the direction of the swap is towards 'logPriceLimit'.
 265 |     |   /// ‘(zeroForOne >> 128)’ is a threshold on the number of shares that should
 266 |     |   /// be available in any interval for the swap function to transact in that 
 267 |     |   /// interval. For example, if (zeroForOne >> 128 == 0), which is the default,
 268 |     |   /// no minimum number of shares is imposed.
 269 |     |   /// @param hookData The data to be passed to the hook.
 270 |     |   /// @return amount0 The amount of tag0 swapped. Positive values are incoming
 271 |     |   /// to the pool and negative values are outgoing from the pool.
 272 |     |   /// @return amount1 The amount of tag1 swapped. Positive values are incoming
 273 |     |   /// to the pool and negative values are outgoing from the pool.
 274 |     |   function swap(
 275 |     |     uint256 poolId,
 276 |     |     int256 amountSpecified,
 277 |     |     X59 logPriceLimit,
 278 |     |     uint256 zeroForOne,
 279 |     |     bytes calldata hookData
 280 |     |   ) external returns (
 281 |     |     int256 amount0,
 282 |     |     int256 amount1
 283 |     |   );
 284 |     | 
 285 |     |   /// @notice Emitted when a tag is transferred.
 286 |     |   /// @notice See ERC6909 specifications.
 287 |     |   event Transfer(
 288 |     |     address caller,
 289 |     |     address indexed from,
 290 |     |     address indexed to,
 291 |     |     Tag indexed tag,
 292 |     |     uint256 amount
 293 |     |   );
 294 |     | 
 295 |     |   /// @notice Emitted when an operator is assigned/absolved by the owner.
 296 |     |   /// @notice See ERC6909 specifications.
 297 |     |   event OperatorSet(
 298 |     |     address indexed owner,
 299 |     |     address indexed operator,
 300 |     |     bool approved
 301 |     |   );
 302 |     | 
 303 |     |   /// @notice Emitted when a spender's permission is updated by the owner.
 304 |     |   /// @notice See ERC6909 specifications.
 305 |     |   event Approval(
 306 |     |     address indexed owner,
 307 |     |     address indexed spender,
 308 |     |     Tag indexed tag,
 309 |     |     uint256 amount
 310 |     |   );
 311 |     | 
 312 |     |   /// @notice Emitted when owner's double balance is modified.
 313 |     |   /// @param caller The caller of 'INofeeswap.modifyBalance'.
 314 |     |   /// @param owner The double balance owner.
 315 |     |   /// @param tag The corresponding tag.
 316 |     |   /// @param increment The amount being incremented/decremented.
 317 |     |   /// @param balance The resulting balance.
 318 |     |   event ModifyDoubleBalanceEvent(
 319 |     |     address indexed caller,
 320 |     |     address indexed owner,
 321 |     |     Tag indexed tag,
 322 |     |     int256 increment,
 323 |     |     uint256 balance
 324 |     |   );
 325 |     | 
 326 |     |   /// @notice Emitted when the pool owner's accrued growth portions are
 327 |     |   /// collected.
 328 |     |   /// @param poolId The target pool identifier.
 329 |     |   /// @param owner Current owner of the target pool.
 330 |     |   /// @param amount0 The total amount of tag0 collected.
 331 |     |   /// @param amount1 The total amount of tag1 collected.
 332 |     |   event PoolCollection(
 333 |     |     uint256 indexed poolId,
 334 |     |     address indexed owner,
 335 |     |     uint256 amount0,
 336 |     |     uint256 amount1
 337 |     |   );
 338 |     | 
 339 |     |   /// @notice Emitted when the protocol owner's accrued growth portions are
 340 |     |   /// collected.
 341 |     |   /// @param poolId The target pool identifier.
 342 |     |   /// @param amount0 The total amount of tag0 collected.
 343 |     |   /// @param amount1 The total amount of tag1 collected.
 344 |     |   event ProtocolCollection(
 345 |     |     uint256 indexed poolId,
 346 |     |     uint256 amount0,
 347 |     |     uint256 amount1
 348 |     |   );
 349 |     | 
 350 |     |   /// @notice Emitted when protocol slot is updated.
 351 |     |   /// @param newOwner The new protocol owner.
 352 |     |   /// @param newProtocol The new protocol slot.
 353 |     |   event ModifyProtocol(
 354 |     |     address indexed newOwner,
 355 |     |     uint256 newProtocol
 356 |     |   );
 357 |     | 
 358 |     |   /// @notice Emitted when the sentinel contract is updated.
 359 |     |   /// @param oldSentinel The old sentinel contract.
 360 |     |   /// @param newSentinel The new sentinel contract.
 361 |     |   event ModifySentinel(
 362 |     |     ISentinel oldSentinel,
 363 |     |     ISentinel newSentinel
 364 |     |   );
 365 |     | 
 366 |     |   /// @notice Emitted when a pool owner is updated.
 367 |     |   /// @param poolId The target pool identifier.
 368 |     |   /// @param oldOwner The old owner of the target pool.
 369 |     |   /// @param newOwner The new owner of the target pool.
 370 |     |   event ModifyPoolOwner(
 371 |     |     uint256 indexed poolId,
 372 |     |     address indexed oldOwner,
 373 |     |     address indexed newOwner
 374 |     |   );
 375 |     | 
 376 |     |   /// @notice Emitted when a nofeeswap pool is initialized.
 377 |     |   /// @param poolId The target pool identifier.
 378 |     |   /// @param tag0 The arithmetically smaller tag.
 379 |     |   /// @param tag1 The arithmetically larger tag.
 380 |     |   /// @param data A snapshot of memory which includes 'staticParams', 'kernel',
 381 |     |   /// 'kernelCompact', and 'curve'.
 382 |     |   event Initialize(
 383 |     |     uint256 indexed poolId,
 384 |     |     Tag indexed tag0,
 385 |     |     Tag indexed tag1,
 386 |     |     bytes data
 387 |     |   );
 388 |     | 
 389 |     |   /// @notice Emitted when a nofeeswap position is created, burned or modified.
 390 |     |   /// @param poolId The target pool identifier.
 391 |     |   /// @param caller Caller of the external 'modifyPosition' function.
 392 |     |   /// @param data A snapshot of memory which includes the following parameters
 393 |     |   /// (as defined in 'Memory.sol') that are tightly packed together:
 394 |     |   ///  - 'logPriceMinOffsetted' in 'X59' representation (8 bytes)
 395 |     |   ///  - 'logPriceMaxOffsetted' in 'X59' representation (8 bytes)
 396 |     |   ///  - 'shares' in 'int256' representation (32 bytes)
 397 |     |   ///  - 'logPriceMin' in 'X59' representation (32 bytes)
 398 |     |   ///  - 'logPriceMax' in 'X59' representation (32 bytes)
 399 |     |   ///  - 'positionAmount0' in 'X127' representation (32 bytes)
 400 |     |   ///  - 'positionAmount1' in 'X127' representation (32 bytes)
 401 |     |   event ModifyPosition(
 402 |     |     uint256 indexed poolId,
 403 |     |     address indexed caller,
 404 |     |     bytes32[6] data
 405 |     |   );
 406 |     | 
 407 |     |   /// @notice Emitted with donates.
 408 |     |   /// @param poolId The target pool identifier.
 409 |     |   /// @param caller Caller of the external 'donate' function.
 410 |     |   /// @param data A snapshot of memory which contains the new value for
 411 |     |   /// 'growth'.
 412 |     |   /// This is sufficient to determine all of the donate parameters.
 413 |     |   event Donate(
 414 |     |     uint256 indexed poolId,
 415 |     |     address indexed caller,
 416 |     |     bytes32 data
 417 |     |   );
 418 |     | 
 419 |     |   /// @notice Emitted when a swap is performed. The last two members of the
 420 |     |   /// curve are logged which are sufficient to uniquely characterize the state.
 421 |     |   /// In other words, if we know both 'qTarget' and 'qOvershoot' that appear at
 422 |     |   /// the end of the amended curve, then we can deterministically track the
 423 |     |   /// state of each pool without having to perform any numerical search.
 424 |     |   /// @param poolId The target pool identifier.
 425 |     |   /// @param caller Caller of the external 'swap' function.
 426 |     |   /// @param data A snapshot of memory which includes the last two members of
 427 |     |   /// the amended curve (i.e., 'qOvershoot' and 'qTarget'). This is sufficient
 428 |     |   /// to reproduce the swap.
 429 |     |   event Swap(
 430 |     |     uint256 indexed poolId,
 431 |     |     address indexed caller,
 432 |     |     bytes32 data
 433 |     |   );
 434 |     | 
 435 |     |   /// @notice Emitted when a pending kernel is introduced for a nofeeswap pool.
 436 |     |   /// @param poolId The target pool identifier.
 437 |     |   /// @param caller Current owner of the target pool.
 438 |     |   /// @param data A snapshot of memory which includes 'staticParams', 'kernel',
 439 |     |   /// and 'kernelCompact'.
 440 |     |   event ModifyKernel(
 441 |     |     uint256 indexed poolId,
 442 |     |     address indexed caller,
 443 |     |     bytes data
 444 |     |   );
 445 |     | 
 446 |     |   /// @notice Emitted when a nofeeswap pool growth portion is modified.
 447 |     |   /// @param poolId The target pool identifier.
 448 |     |   /// @param caller Current owner of the target pool.
 449 |     |   /// @param data A snapshot of memory which contains the new value for 
 450 |     |   /// 'poolGrowthPortion'.
 451 |     |   event ModifyPoolGrowthPortion(
 452 |     |     uint256 indexed poolId,
 453 |     |     address indexed caller,
 454 |     |     bytes32 data
 455 |     |   );
 456 |     | 
 457 |     |   /// @notice Emitted when the growth portions for a nofeeswap pool are synced
 458 |     |   /// with the protocol or sentinel contract.
 459 |     |   /// @param poolId The target pool identifier.
 460 |     |   /// @param caller Current owner of the target pool.
 461 |     |   /// @param data A snapshot of memory which contains the new values for 
 462 |     |   /// 'maxPoolGrowthPortion' and 'protocolGrowthPortion'.
 463 |     |   event UpdateGrowthPortions(
 464 |     |     uint256 indexed poolId,
 465 |     |     address indexed caller,
 466 |     |     bytes32 data
 467 |     |   );
 468 |     | }

R:/LIAT.AI/question2-calldata/contracts/interfaces/ISentinel.sol
  1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
  2 |     | pragma solidity ^0.8.28;
  3 |     | 
  4 |     | import {X47} from "../utilities/X47.sol";
  5 |     | 
  6 |     | /// @notice Interface for the Sentinel contract.
  7 |     | interface ISentinel {
  8 |     |   /// @notice Gives the values of 'maxPoolGrowthPortion' and
  9 |     |   /// 'protocolGrowthPortion' when called by the protocol.
 10 |     |   /// @param sentinelInput Data passed to sentinel contract.
 11 |     |   /// @return maxPoolGrowthPortion The value for 'maxPoolGrowthPortion'. If 
 12 |     |   /// returns any value greater than 'oneX47' then protocol slot's default
 13 |     |   /// values are used.
 14 |     |   /// @return protocolGrowthPortion The value for 'protocolGrowthPortion'. If
 15 |     |   /// returns any value greater than 'oneX47' then protocol slot's default
 16 |     |   /// values are used.
 17 |     |   function getGrowthPortions(
 18 |     |     bytes calldata sentinelInput
 19 |     |   ) external returns (
 20 |     |     X47 maxPoolGrowthPortion,
 21 |     |     X47 protocolGrowthPortion
 22 |     |   );
 23 |     | 
 24 |     |   /// @notice Called by nofeeswap to get authorization for a pool 
 25 |     |   /// initialization.
 26 |     |   /// @param sentinelInput Data passed to sentinel contract which is a snapshot
 27 |     |   /// of nofeeswap's memory post initialization.
 28 |     |   function authorizeInitialization(
 29 |     |     bytes calldata sentinelInput
 30 |     |   ) external returns (bytes4 selector);
 31 |     | 
 32 |     |   /// @notice Called by nofeeswap to get authorization for modification of a 
 33 |     |   /// pool growth portion.
 34 |     |   /// @param sentinelInput Data passed to sentinel contract which is a snapshot
 35 |     |   /// of nofeeswap's memory.
 36 |     |   function authorizeModificationOfPoolGrowthPortion(
 37 |     |     bytes calldata sentinelInput
 38 |     |   ) external returns (bytes4 selector);
 39 |     | }

R:/LIAT.AI/question2-calldata/contracts/interfaces/IStorageAccess.sol
  1 |     | // Credit to: https://github.com/Uniswap/v4-core/blob/
  2 |     | // 80311e34080fee64b6fc6c916e9a51a437d0e482/src/interfaces/IExtsload.sol
  3 |     | pragma solidity ^0.8.28;
  4 |     | 
  5 |     | /// @notice Interface to access any storage slot of Nofeeswap.
  6 |     | interface IStorageAccess {
  7 |     |   /// @notice Provides access to a single Nofeeswap storage slot.
  8 |     |   /// @param slot Key of slot to sload.
  9 |     |   /// @return value The value of the slot as bytes32
 10 |     |   function storageAccess(bytes32 slot) external view returns (bytes32 value);
 11 |     | 
 12 |     |   /// @notice Provides access to consecutive Nofeeswap storage slots.
 13 |     |   /// @param startSlot Starting slot to be read.
 14 |     |   /// @param nSlots Number of slots to be read.
 15 |     |   /// @return values List of loaded values.
 16 |     |   function storageAccess(
 17 |     |     bytes32 startSlot,
 18 |     |     uint256 nSlots
 19 |     |   ) external view returns (bytes32[] memory values);
 20 |     | 
 21 |     |   /// @notice Provides access to a given list of Nofeeswap storage slots.
 22 |     |   /// @param slots List of slots to sload from.
 23 |     |   /// @return values List of loaded values.
 24 |     |   function storageAccess(
 25 |     |     bytes32[] calldata slots
 26 |     |   ) external view returns (bytes32[] memory values);
 27 |     | }

R:/LIAT.AI/question2-calldata/contracts/interfaces/ITransientAccess.sol
  1 |     | // Credit to: https://github.com/Uniswap/v4-core/blob/
  2 |     | // 80311e34080fee64b6fc6c916e9a51a437d0e482/src/interfaces/IExttload.sol
  3 |     | pragma solidity ^0.8.28;
  4 |     | 
  5 |     | /// @notice Interface to access any transient storage slot of Nofeeswap.
  6 |     | interface ITransientAccess {
  7 |     |   /// @notice Provides access to a single Nofeeswap transient storage slot.
  8 |     |   /// @param slot Key of slot to tload.
  9 |     |   /// @return value The value of the slot as bytes32
 10 |     |   function transientAccess(bytes32 slot) external view returns (bytes32 value);
 11 |     | 
 12 |     |   /// @notice Provides access to consecutive Nofeeswap transient storage slots.
 13 |     |   /// @param startSlot Starting slot to be read.
 14 |     |   /// @param nSlots Number of slots to be read.
 15 |     |   /// @return values List of loaded values.
 16 |     |   function transientAccess(
 17 |     |     bytes32 startSlot,
 18 |     |     uint256 nSlots
 19 |     |   ) external view returns (bytes32[] memory values);
 20 |     | 
 21 |     |   /// @notice Provides access to a given list of Nofeeswap transient storage
 22 |     |   /// slots.
 23 |     |   /// @param slots List of slots to tload from.
 24 |     |   /// @return values List of loaded values.
 25 |     |   function transientAccess(
 26 |     |     bytes32[] calldata slots
 27 |     |   ) external view returns (bytes32[] memory values);
 28 |     | }

R:/LIAT.AI/question2-calldata/contracts/utilities/Calldata.sol
   1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
   2 |     | pragma solidity ^0.8.28;
   3 |     | 
   4 |     | import {
   5 |     |   _swapInput_,
   6 |     |   _endOfStaticParams_,
   7 |     |   _hookInputByteCount_,
   8 |     |   _zeroForOne_,
   9 |     |   setMsgSender,
  10 |     |   setPoolId,
  11 |     |   setSqrtOffset,
  12 |     |   setSqrtInverseOffset,
  13 |     |   setTag0,
  14 |     |   setTag1,
  15 |     |   setPoolGrowthPortion,
  16 |     |   setCurve,
  17 |     |   setHookData,
  18 |     |   setHookDataByteCount,
  19 |     |   setFreeMemoryPointer,
  20 |     |   setHookInputByteCount,
  21 |     |   setKernel,
  22 |     |   setLogPriceMin,
  23 |     |   setLogPriceMax,
  24 |     |   setLogPriceMinOffsetted,
  25 |     |   setLogPriceMaxOffsetted,
  26 |     |   setShares,
  27 |     |   setAmountSpecified,
  28 |     |   setLogPriceLimit,
  29 |     |   setCrossThreshold
  30 |     | } from "./Memory.sol";
  31 |     | import {getLogOffsetFromPoolId, derivePoolId} from "./PoolId.sol";
  32 |     | import {Index} from "./Index.sol";
  33 |     | import {X47, oneX47} from "./X47.sol";
  34 |     | import {
  35 |     |   X59,
  36 |     |   zeroX59,
  37 |     |   minLogOffset,
  38 |     |   maxLogOffset,
  39 |     |   sixteenX59,
  40 |     |   thirtyTwoX59
  41 |     | } from "./X59.sol";
  42 |     | import {X127} from "./X127.sol";
  43 |     | import {Tag} from "./Tag.sol";
  44 |     | import {Curve} from "./Curve.sol";
  45 |     | import {Kernel} from "./Kernel.sol";
  46 |     | import {KernelCompact} from "./KernelCompact.sol";
  47 |     | import {readStorage, getDynamicParamsSlot} from "./Storage.sol";
  48 |     | import {
  49 |     |   PoolExists,
  50 |     |   LogOffsetOutOfRange,
  51 |     |   TagsOutOfOrder,
  52 |     |   InvalidGrowthPortion,
  53 |     |   LogPriceOutOfRange,
  54 |     |   InvalidNumberOfShares,
  55 |     |   CurveLengthIsZero,
  56 |     |   PoolIdCannotBeZero,
  57 |     |   HookDataTooLong
  58 |     | } from "./Errors.sol";
  59 |     | 
  60 |     | /// @notice Reads the inputs of the external function 'initialize' and places
  61 |     | /// each in the appropriate memory location. Then, the free memory pointer is
  62 |     | /// set.
  63 |     | /// @return kernelCompact The memory pointer for the given 'kernelCompact'.
  64 |     | /// Observe that 'kernel', 'kernelCompact', 'curve', and 'hookData' are loaded
  65 |     | /// in memory in this order. Hence, the place of 'kernelCompact' is not
  66 |     | /// constant and depends on the size of 'kernel'.
  67 |     | function readInitializeInput() view returns (KernelCompact kernelCompact) {
  68 |     |   // Calldata layout for 'initialize' is as follows:
  69 |     |   //
  70 |     |   // '0x00': 'INofeeswapDelegatee.initialize.selector'
  71 |     |   // '0x04': 'unsaltedPoolId'
  72 |     |   // '0x24': 'tag0'
  73 |     |   // '0x44': 'tag1'
  74 |     |   // '0x64': 'poolGrowthPortion'
  75 |     |   // '0x84': 'calldata pointer to the beginning of kernelCompactArray - 0x04'
  76 |     |   // '0xA4': 'calldata pointer to the beginning of curveArray - 0x04'
  77 |     |   // '0xC4': 'calldata pointer to the beginning of hookData - 0x04'
  78 |     |   // '0x04 + calldataload(0x84)': 'kernelCompactArray'
  79 |     |   // '0x04 + calldataload(0xA4)': 'curveArray'
  80 |     |   // '0x04 + calldataload(0xC4)': 'hookData'
  81 |     | 
  82 |     |   // 'msg.sender' is placed in memory to be passed to hook via calldata.
  83 |     |   setMsgSender(msg.sender);
  84 |     | 
  85 |     |   {
  86 |     |     // 'unsaltedPoolId' is read from calldata and used to derive poolId which
  87 |     |     // will be placed in memory.
  88 |     |     uint256 poolId;
  89 |     |     {
  90 |     |       uint256 unsaltedPoolId;
  91 |     |       assembly {
  92 |     |         unsaltedPoolId := calldataload(4)
  93 |     |       }
  94 |     |       poolId = derivePoolId(unsaltedPoolId);
  95 |     |     }
  96 |     |     setPoolId(poolId);
  97 |     | 
  98 |     |     // Check 'poolId != 0'.
  99 |     |     require(poolId != 0, PoolIdCannotBeZero());
 100 |     | 
 101 |     |     // Verifies whether the pool already exists or not.
 102 |     |     require(
 103 |     |       // The first slot of dynamic parameters contains the 'logPriceCurrent'
 104 |     |       // which is always nonzero after initialization.
 105 |     |       readStorage(getDynamicParamsSlot(poolId)) == 0,
 106 |     |       PoolExists(poolId)
 107 |     |     );
 108 |     | 
 109 |     |     // Throws if 'qOffset' is out of range.
 110 |     |     X59 qOffset = getLogOffsetFromPoolId(poolId);
 111 |     |     require(qOffset > minLogOffset, LogOffsetOutOfRange(qOffset));
 112 |     |     require(qOffset < maxLogOffset, LogOffsetOutOfRange(qOffset));
 113 |     | 
 114 |     |     // 'sqrtOffset' and 'sqrtInverseOffset' are calculated and stored in
 115 |     |     // memory.
 116 |     |     setSqrtOffset(qOffset.logToSqrtOffset());
 117 |     |     // The subtraction is safe due to the prior check.
 118 |     |     setSqrtInverseOffset((zeroX59 - qOffset).logToSqrtOffset());
 119 |     |   }
 120 |     | 
 121 |     |   {
 122 |     |     // 'tag0' is read from calldata and placed in memory.
 123 |     |     Tag tag0;
 124 |     |     assembly {
 125 |     |       tag0 := calldataload(36)
 126 |     |     }
 127 |     |     setTag0(tag0);
 128 |     | 
 129 |     |     // 'tag1' is read from calldata and placed in memory.
 130 |     |     Tag tag1;
 131 |     |     assembly {
 132 |     |       tag1 := calldataload(68)
 133 |     |     }
 134 |     |     setTag1(tag1);
 135 |     | 
 136 |     |     // Throws if the two tags are out of order.
 137 |     |     require(tag1 > tag0, TagsOutOfOrder(tag0, tag1));
 138 |     |   }
 139 |     | 
 140 |     |   {
 141 |     |     // 'poolGrowthPortion' is read from calldata and placed in memory.
 142 |     |     X47 poolGrowthPortion;
 143 |     |     assembly {
 144 |     |       poolGrowthPortion := calldataload(100)
 145 |     |     }
 146 |     |     // Throws if 'poolGrowthPortion' is greater than 'oneX47'.
 147 |     |     require(
 148 |     |       poolGrowthPortion <= oneX47,
 149 |     |       InvalidGrowthPortion(poolGrowthPortion)
 150 |     |     );
 151 |     |     setPoolGrowthPortion(poolGrowthPortion);
 152 |     |   }
 153 |     | 
 154 |     |   {
 155 |     |     // This is the pointer referring to the start of the kernel in memory.
 156 |     |     Kernel kernel;
 157 |     | 
 158 |     |     // This value refers to the start of 'kernelCompactArray' in calldata.
 159 |     |     uint256 kernelCompactStart;
 160 |     | 
 161 |     |     // The byte count of 'kernelCompact'.
 162 |     |     uint256 kernelCompactByteCount;
 163 |     | 
 164 |     |     assembly {
 165 |     |       kernelCompactStart := add(0x04, calldataload(0x84))
 166 |     | 
 167 |     |       // kernel starts immediately after static parameters in memory.
 168 |     |       kernel := _endOfStaticParams_
 169 |     | 
 170 |     |       // The number of bytes to be occupied by 'kernelCompact'.
 171 |     |       kernelCompactByteCount := shl(5, calldataload(kernelCompactStart))
 172 |     | 
 173 |     |       // Each breakpoint occupies 80-bits in 'kernelCompact'.
 174 |     |       // Each breakpoint occupies 512-bits in 'kernel'.
 175 |     |       // Hence, '512 * calldataload(kernelCompactStart) / 80' is an upper 
 176 |     |       // bound on the number of slots to be occupied by 'kernel'.
 177 |     |       // And, '32 * (512 * calldataload(kernelCompactStart) / 80)' is an upper
 178 |     |       // bound on the number of bytes to be occupied by 'kernel'.
 179 |     |       // Since 'kernelCompact' comes immediately after 'kernel' in memory, we
 180 |     |       // need to set its memory pointer accordingly.
 181 |     |       kernelCompact := add(kernel, shl(5, div(kernelCompactByteCount, 5)))
 182 |     |     }
 183 |     |     setKernel(kernel);
 184 |     | 
 185 |     |     {
 186 |     |       // This is the pointer referring to the start of the curve sequence in
 187 |     |       // memory.
 188 |     |       Curve curve;
 189 |     | 
 190 |     |       // This value refers to the start of 'curveArray' in calldata.
 191 |     |       uint256 curveStart;
 192 |     | 
 193 |     |       // The byte count of the curve sequence.
 194 |     |       uint256 curveByteCount;
 195 |     | 
 196 |     |       assembly {
 197 |     |         curveStart := add(0x04, calldataload(0xA4))
 198 |     | 
 199 |     |         // 'curve' appears after 'kernelCompact' in memory.
 200 |     |         curve := add(kernelCompact, kernelCompactByteCount)
 201 |     | 
 202 |     |         // The number of bytes to be occupied by 'curve'.
 203 |     |         curveByteCount := shl(5, calldataload(curveStart))
 204 |     |       }
 205 |     |       require(curveByteCount >= 32, CurveLengthIsZero());
 206 |     |       setCurve(curve);
 207 |     | 
 208 |     |       {
 209 |     |         // This is the pointer referring to the start of hookData in memory.
 210 |     |         uint256 hookData;
 211 |     |         
 212 |     |         // The byte count of 'hookData'.
 213 |     |         uint256 hookDataByteCount;
 214 |     | 
 215 |     |         // The total number of bytes of the memory snapshot to be used as
 216 |     |         // input for the hook contract.
 217 |     |         uint256 hookInputByteCount;
 218 |     |         
 219 |     |         // The free memory pointer which is set at the end.
 220 |     |         uint256 freeMemoryPointer;
 221 |     | 
 222 |     |         assembly {
 223 |     |           // This value refers to the start of 'hookData' in calldata (the
 224 |     |           // length slot).
 225 |     |           let hookDataStart := add(0x04, calldataload(0xC4))
 226 |     | 
 227 |     |           // 'hookData' appears after 'curve' in memory.
 228 |     |           // 8 bytes are added to seperate the curve sequence from hook data.
 229 |     |           hookData := add(add(curve, curveByteCount), 8)
 230 |     | 
 231 |     |           // The number of bytes to be occupied by 'hookData'.
 232 |     |           hookDataByteCount := calldataload(hookDataStart)
 233 |     | 
 234 |     |           // 'freeMemoryPointer' appears after 'hookData' in memory.
 235 |     |           freeMemoryPointer := add(hookData, hookDataByteCount)
 236 |     | 
 237 |     |           // The total number of bytes to be given to the hook as input.
 238 |     |           // 32 is subtracted to exclude the '_hookInputByteCount_' slot.
 239 |     |           hookInputByteCount := 
 240 |     |             sub(sub(freeMemoryPointer, _hookInputByteCount_), 32)
 241 |     | 
 242 |     |           // Data is copied from calldata to memory.
 243 |     |           calldatacopy(
 244 |     |             kernelCompact,
 245 |     |             // The length slot of 'kernelCompactArray' is excluded.
 246 |     |             add(kernelCompactStart, 32),
 247 |     |             kernelCompactByteCount
 248 |     |           )
 249 |     |           calldatacopy(
 250 |     |             curve,
 251 |     |             // The length slot of 'curveArray' is excluded.
 252 |     |             add(curveStart, 32),
 253 |     |             curveByteCount
 254 |     |           )
 255 |     |           calldatacopy(
 256 |     |             hookData,
 257 |     |             // The length slot of 'hookData' is excluded.
 258 |     |             add(hookDataStart, 32),
 259 |     |             hookDataByteCount
 260 |     |           )
 261 |     |         }
 262 |     |         setHookData(hookData);
 263 |     |         require(
 264 |     |           hookDataByteCount <= type(uint16).max,
 265 |     |           HookDataTooLong(hookDataByteCount)
 266 |     |         );
 267 |     |         setHookDataByteCount(uint16(hookDataByteCount));
 268 |     |         setHookInputByteCount(hookInputByteCount);
 269 |     |         setFreeMemoryPointer(freeMemoryPointer);
 270 |     |       }
 271 |     |     }
 272 |     |   }
 273 |     | }
 274 |     | 
 275 |     | /// @notice Reads inputs of the external function 'modifyPosition' and places
 276 |     | /// each in the appropriate memory location.
 277 |     | function readModifyPositionInput() view {
 278 |     |   // Calldata layout for 'modifyPosition' is as follows:
 279 |     |   //
 280 |     |   // '0x00': 'INofeeswapDelegatee.modifyPosition.selector'
 281 |     |   // '0x04': 'poolId'
 282 |     |   // '0x24': 'logPriceMin'
 283 |     |   // '0x44': 'logPriceMax'
 284 |     |   // '0x64': 'shares'
 285 |     |   // '0x84': 'calldata pointer to the beginning of hookData - 0x04'
 286 |     |   // '0x04 + calldataload(0x84)': 'hookData'
 287 |     | 
 288 |     |   // 'msg.sender' is placed in memory to be passed to hook as calldata.
 289 | *   |   setMsgSender(msg.sender);
 290 |     | 
 291 |     |   {
 292 |     |     // 'poolId' is read from calldata and placed in memory.
 293 |     |     uint256 poolId;
 294 | *   |     assembly {
 295 |     |       poolId := calldataload(4)
 296 |     |     }
 297 | *   |     setPoolId(poolId);
 298 |     | 
 299 |     |     // Normalized log price values are calculated next.
 300 |     |     X59 shift = getLogOffsetFromPoolId(poolId) - sixteenX59;
 301 |     | 
 302 |     |     // 'logPriceMin' is read from calldata and placed in memory.
 303 |     |     X59 logPriceMin;
 304 | *   |     assembly {
 305 |     |       logPriceMin := calldataload(36)
 306 |     |     }
 307 | *   |     setLogPriceMin(logPriceMin);
 308 |     |     X59 qMin = logPriceMin - shift;
 309 | *   |     require(qMin > zeroX59, LogPriceOutOfRange(logPriceMin));
 310 | *   |     require(qMin < thirtyTwoX59, LogPriceOutOfRange(logPriceMin));
 311 | *   |     setLogPriceMinOffsetted(qMin);
 312 |     | 
 313 |     |     // 'logPriceMax' is read from calldata and placed in memory.
 314 |     |     X59 logPriceMax;
 315 | *   |     assembly {
 316 |     |       logPriceMax := calldataload(68)
 317 |     |     }
 318 | *   |     setLogPriceMax(logPriceMax);
 319 |     |     X59 qMax = logPriceMax - shift;
 320 | *   |     require(qMax > zeroX59, LogPriceOutOfRange(logPriceMax));
 321 | *   |     require(qMax < thirtyTwoX59, LogPriceOutOfRange(logPriceMax));
 322 | *   |     setLogPriceMaxOffsetted(qMax);
 323 |     |   }
 324 |     | 
 325 |     |   {
 326 |     |     // The number of shares to be minted/burned is read from calldata capped by
 327 |     |     // '-type(int128).max' and '+type(int128).max', and placed in memory.
 328 |     |     int256 shares;
 329 | *   |     assembly {
 330 |     |       shares := calldataload(100)
 331 |     |     }
 332 |     |     // Checks the number of shares.
 333 | *   |     require(shares <= type(int128).max, InvalidNumberOfShares(shares));
 334 | *   |     require(shares >= 0 - type(int128).max, InvalidNumberOfShares(shares));
 335 | *   |     require(shares != 0, InvalidNumberOfShares(shares));
 336 | *   |     setShares(shares);
 337 |     |   }
 338 |     | 
 339 |     |   {
 340 |     |     // This is the pointer referring to the start of the curve sequence in
 341 |     |     // memory.
 342 |     |     Curve curve;
 343 |     | 
 344 |     |     // This is the pointer referring to the start of hookData in memory.
 345 |     |     uint256 hookData;
 346 |     | 
 347 |     |     // The byte count of 'hookData'.
 348 |     |     uint256 hookDataByteCount;
 349 |     | 
 350 |     |     // The total number of bytes of the memory snapshot to be used as input for
 351 |     |     // the hook contract.
 352 |     |     uint256 hookInputByteCount;
 353 |     | 
 354 |     |     // The free memory pointer which is set at the end.
 355 |     |     uint256 freeMemoryPointer;
 356 |     | 
 357 | *   |     assembly {
 358 |     |       // This value refers to the start of 'hookData' in calldata (the length
 359 |     |       // slot).
 360 |     |       let hookDataStart := add(0x04, calldataload(0x84))
 361 |     | 
 362 |     |       // 32 bytes are reserved for the first slot of the curve sequence and no
 363 |     |       // member of kernel is loaded.
 364 |     |       curve := _endOfStaticParams_
 365 |     | 
 366 |     |       // 'hookData' appears immediately after.
 367 |     |       hookData := add(_endOfStaticParams_, 32)
 368 |     | 
 369 |     |       // The number of bytes to be occupied by 'hookData'.
 370 |     |       hookDataByteCount := calldataload(hookDataStart)
 371 |     | 
 372 |     |       // 'freeMemoryPointer' appears after 'hookData' in memory.
 373 |     |       freeMemoryPointer := add(hookData, hookDataByteCount)
 374 |     | 
 375 |     |       // The total number of bytes to be given to the hook as input.
 376 |     |       hookInputByteCount := 
 377 |     |         sub(sub(freeMemoryPointer, _hookInputByteCount_), 32)
 378 |     | 
 379 |     |       // Data is copied from calldata to memory.
 380 |     |       calldatacopy(
 381 |     |         hookData,
 382 |     |         // The length slot of 'hookData' is excluded.
 383 |     |         add(hookDataStart, 32),
 384 |     |         hookDataByteCount
 385 |     |       )
 386 |     |     }
 387 | *   |     setCurve(curve);
 388 | *   |     setHookData(hookData);
 389 | *   |     require(
 390 | *   |       hookDataByteCount <= type(uint16).max,
 391 |     |       HookDataTooLong(hookDataByteCount)
 392 |     |     );
 393 |     |     setHookDataByteCount(uint16(hookDataByteCount));
 394 |     |     setHookInputByteCount(hookInputByteCount);
 395 | *   |     setFreeMemoryPointer(freeMemoryPointer);
 396 |     |   }
 397 |     | }
 398 |     | 
 399 |     | /// @notice Reads inputs of the external function 'donate' and places each in
 400 |     | /// the appropriate memory location.
 401 |     | function readDonateInput() view {
 402 |     |   // Calldata layout for 'donate' is as follows:
 403 |     |   //
 404 |     |   // '0x00': 'INofeeswapDelegatee.donate.selector'
 405 |     |   // '0x04': 'poolId'
 406 |     |   // '0x24': 'shares'
 407 |     |   // '0x44': 'calldata pointer to the beginning of hookData - 0x04'
 408 |     |   // '0x04 + calldataload(0x44)': 'hookData'
 409 |     | 
 410 |     |   // 'msg.sender' is placed in memory to be passed to hook as calldata.
 411 |     |   setMsgSender(msg.sender);
 412 |     | 
 413 |     |   {
 414 |     |     // 'poolId' is read from calldata and placed in memory.
 415 |     |     uint256 poolId;
 416 |     |     assembly {
 417 |     |       poolId := calldataload(4)
 418 |     |     }
 419 |     |     setPoolId(poolId);
 420 |     |   }
 421 |     | 
 422 |     |   {
 423 |     |     // The number of shares to be minted/burned is read from calldata capped by
 424 |     |     // '+type(int128).max', and placed in memory.
 425 |     |     int256 shares;
 426 |     |     assembly {
 427 |     |       shares := calldataload(36)
 428 |     |     }
 429 |     |     require(shares <= type(int128).max, InvalidNumberOfShares(shares));
 430 |     |     require(shares > 0, InvalidNumberOfShares(shares));
 431 |     |     setShares(shares);
 432 |     |   }
 433 |     | 
 434 |     |   {
 435 |     |     // This is the pointer referring to the start of the curve sequence in
 436 |     |     // memory.
 437 |     |     Curve curve;
 438 |     | 
 439 |     |     // This is the pointer referring to the start of hookData in memory.
 440 |     |     uint256 hookData;
 441 |     | 
 442 |     |     // The byte count of 'hookData'.
 443 |     |     uint256 hookDataByteCount;
 444 |     | 
 445 |     |     // The total number of bytes of the memory snapshot to be used as input for
 446 |     |     // the hook contract.
 447 |     |     uint256 hookInputByteCount;
 448 |     | 
 449 |     |     // The free memory pointer which is set at the end.
 450 |     |     uint256 freeMemoryPointer;
 451 |     | 
 452 | *   |     assembly {
 453 |     |       // This value refers to the start of 'hookData' in calldata (the length
 454 |     |       // slot).
 455 |     |       let hookDataStart := add(0x04, calldataload(0x44))
 456 |     | 
 457 |     |       // 32 bytes are reserved for the first slot of the curve sequence and no
 458 |     |       // member of kernel is loaded.
 459 |     |       curve := _endOfStaticParams_
 460 |     | 
 461 |     |       // 'hookData' appears immediately after.
 462 |     |       hookData := add(_endOfStaticParams_, 32)
 463 |     | 
 464 |     |       // The number of bytes to be occupied by 'hookData'.
 465 |     |       hookDataByteCount := calldataload(hookDataStart)
 466 |     | 
 467 |     |       // 'freeMemoryPointer' appears after 'hookData' in memory.
 468 |     |       freeMemoryPointer := add(hookData, hookDataByteCount)
 469 |     | 
 470 |     |       // The total number of bytes to be given to the hook as input.
 471 |     |       hookInputByteCount := 
 472 |     |         sub(sub(freeMemoryPointer, _hookInputByteCount_), 32)
 473 |     | 
 474 |     |       // Data is copied from calldata to memory.
 475 |     |       calldatacopy(
 476 |     |         hookData,
 477 |     |         // The length slot of 'hookData' is excluded.
 478 |     |         add(hookDataStart, 32),
 479 |     |         hookDataByteCount
 480 |     |       )
 481 |     |     }
 482 |     |     setCurve(curve);
 483 |     |     setHookData(hookData);
 484 | *   |     require(
 485 |     |       hookDataByteCount <= type(uint16).max,
 486 |     |       HookDataTooLong(hookDataByteCount)
 487 |     |     );
 488 | *   |     setHookDataByteCount(uint16(hookDataByteCount));
 489 | *   |     setHookInputByteCount(hookInputByteCount);
 490 | *   |     setFreeMemoryPointer(freeMemoryPointer);
 491 |     |   }
 492 |     | }
 493 |     | 
 494 |     | /// @notice Reads the inputs of the external function 'modifyKernel' and
 495 |     | /// places each in the appropriate memory location.
 496 |     | /// @return kernelCompact The memory pointer for the given 'kernelCompact'.
 497 |     | /// Observe that 'kernel', 'kernelCompact', 'curve', and 'hookData' are loaded
 498 |     | /// in memory in this order. Hence, the place of 'kernelCompact' is not
 499 |     | /// constant and depends on the size of 'kernel'.
 500 |     | function readModifyKernelInput() view returns (KernelCompact kernelCompact) {
 501 |     |   // Calldata layout for 'modifyKernel' is as follows:
 502 |     |   //
 503 |     |   // '0x00': 'INofeeswapDelegatee.modifyKernel.selector'
 504 |     |   // '0x04': 'poolId'
 505 |     |   // '0x24': 'calldata pointer to the beginning of kernelCompactArray - 0x04'
 506 |     |   // '0x44': 'calldata pointer to the beginning of hookData - 0x04'
 507 |     |   // '0x04 + calldataload(0x24)': 'kernelCompactArray'
 508 |     |   // '0x04 + calldataload(0x44)': 'hookData'
 509 |     | 
 510 |     |   // 'msg.sender' is placed in memory to be passed to hook as calldata.
 511 |     |   setMsgSender(msg.sender);
 512 |     | 
 513 |     |   // 'poolId' is read from calldata and placed in memory.
 514 |     |   uint256 poolId;
 515 |     |   assembly {
 516 |     |     poolId := calldataload(4)
 517 |     |   }
 518 |     |   setPoolId(poolId);
 519 |     | 
 520 |     |   // This is the pointer referring to the start of the kernel in memory.
 521 |     |   Kernel kernel;
 522 |     | 
 523 |     |   // This value refers to the start of 'kernelCompactArray' in calldata.
 524 |     |   uint256 kernelCompactStart;
 525 |     | 
 526 |     |   // The byte count of 'kernelCompact'.
 527 |     |   uint256 kernelCompactByteCount;
 528 |     | 
 529 |     |   assembly {
 530 |     |     kernelCompactStart := add(0x04, calldataload(0x24))
 531 |     | 
 532 |     |     // kernel starts immediately after static parameters in memory.
 533 |     |     kernel := _endOfStaticParams_
 534 |     | 
 535 |     |     // The number of bytes to be occupied by 'kernelCompact'.
 536 |     |     kernelCompactByteCount := shl(5, calldataload(kernelCompactStart))
 537 |     | 
 538 |     |     // Each breakpoint occupies 80-bits in kernelCompact.
 539 |     |     // Each breakpoint occupies 512-bits in kernel.
 540 |     |     // Hence, '512 * calldataload(kernelCompactStart) / 80' is an upper 
 541 |     |     // bound for the number of slots to be occupied by 'kernel'.
 542 |     |     // And, '32 * (512 * calldataload(kernelCompactStart) / 80)' is an upper
 543 |     |     // bound for the number of bytes to be occupied by 'kernel'.
 544 |     |     // Since 'kernelCompact' comes immediately after 'kernel' in memory, we
 545 |     |     // need to set its memory pointer accordingly:
 546 |     |     kernelCompact := add(kernel, shl(5, div(kernelCompactByteCount, 5)))
 547 |     |   }
 548 |     |   setKernel(kernel);
 549 |     | 
 550 |     |   // This is the pointer referring to the start of hookData in memory.
 551 |     |   uint256 hookData;
 552 |     |   
 553 |     |   // The byte count of 'hookData'.
 554 |     |   uint256 hookDataByteCount;
 555 |     | 
 556 |     |   // The total number of bytes of the memory snapshot to be used as input for
 557 |     |   // the hook contract.
 558 |     |   uint256 hookInputByteCount;
 559 |     |   
 560 |     |   // The free memory pointer which is set at the end.
 561 |     |   uint256 freeMemoryPointer;
 562 |     | 
 563 |     |   assembly {
 564 |     |     // This value refers to the start of 'hookData' in calldata (the length
 565 |     |     // slot).
 566 |     |     let hookDataStart := add(0x04, calldataload(0x44))
 567 |     | 
 568 |     |     // 'hookData' appears after 'kernelCompact' in memory.
 569 |     |     hookData := add(kernelCompact, kernelCompactByteCount)
 570 |     | 
 571 |     |     // The number of bytes to be occupied by 'hookData'.
 572 |     |     hookDataByteCount := calldataload(hookDataStart)
 573 |     | 
 574 |     |     // 'freeMemoryPointer' appears after 'hookData' in memory.
 575 |     |     freeMemoryPointer := add(hookData, hookDataByteCount)
 576 |     | 
 577 |     |     // The total number of bytes to be given to the hook as input.
 578 |     |     // 32 is subtracted to exclude the '_hookInputByteCount_' slot.
 579 |     |     hookInputByteCount := 
 580 |     |       sub(sub(freeMemoryPointer, _hookInputByteCount_), 32)
 581 |     | 
 582 |     |     // Data is copied from calldata to memory.
 583 |     |     calldatacopy(
 584 |     |       kernelCompact,
 585 |     |       // The length slot of 'kernelCompactArray' is excluded.
 586 |     |       add(kernelCompactStart, 32),
 587 |     |       kernelCompactByteCount
 588 |     |     )
 589 |     |     calldatacopy(
 590 |     |       hookData,
 591 |     |       // The length slot of 'hookData' is excluded.
 592 |     |       add(hookDataStart, 32),
 593 |     |       hookDataByteCount
 594 |     |     )
 595 |     |   }
 596 |     |   setHookData(hookData);
 597 |     |   require(
 598 |     |     hookDataByteCount <= type(uint16).max,
 599 |     |     HookDataTooLong(hookDataByteCount)
 600 |     |   );
 601 |     |   setHookDataByteCount(uint16(hookDataByteCount));
 602 |     |   setHookInputByteCount(hookInputByteCount);
 603 |     |   setFreeMemoryPointer(freeMemoryPointer);
 604 |     | }
 605 |     | 
 606 |     | /// @notice Reads inputs of the external function 'modifyPoolGrowthPortion' and
 607 |     | /// places each in the appropriate memory location.
 608 |     | function readModifyPoolGrowthPortionInput() view {
 609 |     |   // Calldata layout for 'modifyKernel' is as follows:
 610 |     |   //
 611 |     |   // '0x00': 'INofeeswapDelegatee.modifyPoolGrowthPortion.selector'
 612 |     |   // '0x04': 'poolId'
 613 |     |   // '0x24': 'poolGrowthPortion'
 614 |     | 
 615 |     |   // 'msg.sender' is placed in memory to be passed to sentinel as calldata.
 616 |     |   setMsgSender(msg.sender);
 617 |     | 
 618 |     |   // 'poolId' is read from calldata and placed in memory.
 619 |     |   uint256 poolId;
 620 |     |   assembly {
 621 |     |     poolId := calldataload(4)
 622 |     |   }
 623 |     |   setPoolId(poolId);
 624 |     | 
 625 |     |   {
 626 |     |     // 'poolGrowthPortion' is read from calldata and placed in memory.
 627 |     |     X47 poolGrowthPortion;
 628 |     |     assembly {
 629 |     |       poolGrowthPortion := calldataload(36)
 630 |     |     }
 631 |     |     require(
 632 |     |       poolGrowthPortion <= oneX47,
 633 |     |       InvalidGrowthPortion(poolGrowthPortion)
 634 |     |     );
 635 |     |     setPoolGrowthPortion(poolGrowthPortion);
 636 |     |   }
 637 |     | 
 638 |     |   // The total number of bytes of the memory snapshot to be used as input for
 639 |     |   // the sentinel contract.
 640 |     |   uint256 hookInputByteCount;
 641 |     |   assembly {
 642 |     |     // The total number of bytes to be given to the sentinel as input.
 643 |     |     hookInputByteCount := 
 644 |     |       sub(sub(_endOfStaticParams_, _hookInputByteCount_), 32)
 645 |     |   }
 646 |     |   setHookInputByteCount(hookInputByteCount);
 647 |     | 
 648 |     |   // Free memory appears immediately after staticParams.
 649 |     |   setFreeMemoryPointer(_endOfStaticParams_);
 650 |     | }
 651 |     | 
 652 |     | /// @notice Reads inputs of the external function 'updateGrowthPortions' and
 653 |     | /// places each in the appropriate memory location.
 654 |     | function readUpdateGrowthPortionsInput() pure {
 655 |     |   // Calldata layout for 'updateGrowthPortions' is as follows:
 656 |     |   //
 657 |     |   // '0x00': 'INofeeswapDelegatee.updateGrowthPortions.selector'
 658 |     |   // '0x04': 'poolId'
 659 |     | 
 660 |     |   // 'poolId' is read from calldata and placed in memory.
 661 |     |   uint256 poolId;
 662 |     |   assembly {
 663 |     |     poolId := calldataload(4)
 664 |     |   }
 665 |     |   setPoolId(poolId);
 666 |     | 
 667 |     |   // The total number of bytes of the memory snapshot to be used as input for
 668 |     |   // the sentinel contract.
 669 |     |   uint256 hookInputByteCount;
 670 |     |   assembly {
 671 |     |     // The total number of bytes to be given to the sentinel as input.
 672 |     |     hookInputByteCount := 
 673 |     |       sub(sub(_endOfStaticParams_, _hookInputByteCount_), 32)
 674 |     |   }
 675 |     |   setHookInputByteCount(hookInputByteCount);
 676 |     | 
 677 |     |   // Free memory appears immediately after staticParams.
 678 |     |   setFreeMemoryPointer(_endOfStaticParams_);
 679 |     | }
 680 |     | 
 681 |     | /// @notice Reads the inputs of the external function 'swap' and places each in
 682 |     | /// the appropriate memory location.
 683 |     | function readSwapInput() view {
 684 |     |   // Calldata layout for 'swap' is as follows:
 685 |     |   //
 686 |     |   // '0x00': 'INofeeswap.swap.selector'
 687 |     |   // '0x04': 'poolId'
 688 |     |   // '0x24': 'amountSpecified'
 689 |     |   // '0x44': 'logPriceLimit'
 690 |     |   // '0x64': 'zeroForOne'
 691 |     |   // '0x84': 'calldata pointer to the beginning of hookData - 0x04'
 692 |     |   // '0x04 + calldataload(0x84)': 'hookData'
 693 |     | 
 694 |     |   // 'msg.sender' is placed in memory to be passed to hook as calldata.
 695 |     |   setMsgSender(msg.sender);
 696 |     | 
 697 |     |   // 'poolId' is read from calldata and placed in memory.
 698 |     |   uint256 poolId;
 699 |     |   assembly {
 700 |     |     poolId := calldataload(4)
 701 |     |   }
 702 |     |   setPoolId(poolId);
 703 |     | 
 704 |     |   // 'amountSpecified' is read from calldata, capped by '-type(int128).max' and 
 705 |     |   // '+type(int128).max', transformed to X127, and placed in memory.
 706 |     |   X127 amountSpecified;
 707 | *   |   assembly {
 708 |     |     amountSpecified := calldataload(36)
 709 |     |     if slt(amountSpecified, sub(0, 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) {
 710 |     |       amountSpecified := sub(0, 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)
 711 |     |     }
 712 |     |     if sgt(amountSpecified, 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) {
 713 |     |       amountSpecified := 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
 714 |     |     }
 715 |     |     amountSpecified := mul(amountSpecified, shl(127, 1))
 716 |     |   }
 717 |     |   setAmountSpecified(amountSpecified);
 718 |     | 
 719 |     |   // 'logPriceLimit' is read from calldata and placed in memory.
 720 |     |   X59 logPriceLimit;
 721 |     |   assembly {
 722 |     |     logPriceLimit := calldataload(68)
 723 |     |   }
 724 |     |   setLogPriceLimit(logPriceLimit);
 725 |     | 
 726 |     |   // 'crossThreshold' is read from calldata and placed in memory.
 727 |     |   uint256 crossThreshold;
 728 |     |   assembly {
 729 |     |     crossThreshold := shr(128, calldataload(100))
 730 |     |     if gt(crossThreshold, 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) {
 731 |     |       crossThreshold := 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
 732 |     |     }
 733 |     |   }
 734 |     |   setCrossThreshold(crossThreshold);
 735 |     | 
 736 |     |   // 'zeroForOne' is read from calldata, capped by '2' and placed in memory.
 737 |     |   assembly {
 738 |     |     let zeroForOne := shr(128, calldataload(116))
 739 |     |     if gt(zeroForOne, 2) {
 740 |     |       zeroForOne := 2
 741 |     |     }
 742 |     |     mstore8(_zeroForOne_, zeroForOne)
 743 |     |   }
 744 |     | 
 745 |     |   {
 746 |     |     // This is the pointer referring to the start of the kernel in memory.
 747 |     |     Kernel kernel;
 748 |     | 
 749 |     |     // This is the pointer referring to the start of hookData in memory.
 750 |     |     uint256 hookData;
 751 |     | 
 752 |     |     // The byte count of 'hookData'.
 753 |     |     uint256 hookDataByteCount;
 754 |     | 
 755 |     |     // The total number of bytes of the memory snapshot to be used as input for
 756 |     |     // the hook contract.
 757 |     |     uint256 hookInputByteCount;
 758 |     | 
 759 |     |     assembly {
 760 |     |       // This value refers to the start of 'hookData' in calldata (the length
 761 |     |       // slot).
 762 |     |       let hookDataStart := add(0x04, calldataload(0x84))
 763 |     | 
 764 |     |       // 'hookData' appears immediately after static parameters.
 765 |     |       hookData := _endOfStaticParams_
 766 |     | 
 767 |     |       // The number of bytes to be occupied by 'hookData'.
 768 |     |       hookDataByteCount := calldataload(hookDataStart)
 769 |     | 
 770 |     |       // 'kernel' appears immediately after 'hookData'.
 771 |     |       kernel := add(hookData, hookDataByteCount)
 772 |     | 
 773 |     |       // The total number of bytes to be given to the 'preSwap' hook as input.
 774 |     |       // 32 is subtracted to exclude the '_hookInputByteCount_' slot.
 775 |     |       hookInputByteCount := sub(sub(kernel, _hookInputByteCount_), 32)
 776 |     | 
 777 |     |       // Data is copied from calldata to memory.
 778 |     |       calldatacopy(
 779 |     |         hookData,
 780 |     |         // The length slot of 'hookData' is excluded.
 781 |     |         add(hookDataStart, 32),
 782 |     |         hookDataByteCount
 783 |     |       )
 784 |     |     }
 785 |     |     setHookData(hookData);
 786 |     |     require(
 787 |     |       hookDataByteCount <= type(uint16).max,
 788 |     |       HookDataTooLong(hookDataByteCount)
 789 |     |     );
 790 |     |     setHookDataByteCount(uint16(hookDataByteCount));
 791 |     |     setHookInputByteCount(hookInputByteCount);
 792 |     |     setKernel(kernel);
 793 |     |   }
 794 |     | }
 795 |     | 
 796 |     | /// @notice Reads input of the external functions 'collectPool' and 
 797 |     | /// 'collectProtocol'.
 798 |     | function readCollectInput() pure {
 799 |     |   // Calldata layout is as follows:
 800 |     |   //
 801 |     |   // '0x00': function selector
 802 |     |   // '0x04': 'poolId'
 803 |     | 
 804 |     |   // 'poolId' is read from calldata and placed in memory.
 805 |     |   uint256 poolId;
 806 |     |   assembly {
 807 |     |     poolId := calldataload(4)
 808 |     |   }
 809 |     |   setPoolId(poolId);
 810 |     | 
 811 |     |   // Determines the largest used memory slot.
 812 |     |   setFreeMemoryPointer(_swapInput_);
 813 |     | }

R:/LIAT.AI/question2-calldata/contracts/utilities/Curve.sol
   1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
   2 |     | pragma solidity ^0.8.28;
   3 |     | 
   4 |     | import {
   5 |     |   _spacing_,
   6 |     |   getCurveLength,
   7 |     |   setLogPriceCurrent,
   8 |     |   setCurveLength
   9 |     | } from "./Memory.sol";
  10 |     | import {
  11 |     |   Index,
  12 |     |   zeroIndex,
  13 |     |   oneIndex,
  14 |     |   twoIndex,
  15 |     |   maxCurveIndex
  16 |     | } from "./Index.sol";
  17 |     | import {PriceLibrary} from "./Price.sol";
  18 |     | import {
  19 |     |   X59,
  20 |     |   min,
  21 |     |   max,
  22 |     |   zeroX59,
  23 |     |   thirtyTwoX59,
  24 |     |   minLogSpacing
  25 |     | } from "./X59.sol";
  26 |     | import {
  27 |     |   LogSpacingIsTooSmall,
  28 |     |   BlankIntervalsShouldBeAvoided,
  29 |     |   InvalidCurveArrangement,
  30 |     |   CurveIndexOutOfRange
  31 |     | } from "./Errors.sol";
  32 |     | 
  33 |     | // The curve sequence comprises 64 bit logarithmic prices in the form of
  34 |     | //
  35 |     | //  '(2 ** 59) * (16 + qHistorical)'
  36 |     | //
  37 |     | // where
  38 |     | //
  39 |     | //  'qHistorical := log(pHistorical / pOffset)'.
  40 |     | //
  41 |     | // Hence, each slot of the curve sequence consists of up to four members. The
  42 |     | // curve sequence should have at least two members. The first and the second
  43 |     | // members are 'qLower' and 'qUpper' (i.e., boundaries of the active liquidity
  44 |     | // interval) with the order depending on the pool's history. The last member is
  45 |     | // always 'qCurrent'. Consider the following curve sequence:
  46 |     | // 
  47 |     | //  'q[0], q[1], q[2], ..., q[l - 1]'
  48 |     | //
  49 |     | // where 'l' is the number of members. In order for the above sequence to be
  50 |     | // considered valid, we should have:
  51 |     | //
  52 |     | //  'min(q[i - 1], q[i - 2]) < q[i] < max(q[i - 1], q[i - 2])'.
  53 |     | //
  54 |     | // This ordering rule is verified upon initialization of any pool and it is
  55 |     | // preserved by each amendment to the curve sequence.
  56 |     | type Curve is uint256;
  57 |     | 
  58 |     | using PriceLibrary for uint16;
  59 |     | using CurveLibrary for Curve global;
  60 |     | 
  61 |     | library CurveLibrary {
  62 |     |   /// @notice Returns the member of the curve sequence corresponding to the
  63 |     |   /// given index.
  64 |     |   ///
  65 |     |   /// Index out-of-range should be avoided externally.
  66 |     |   function member(
  67 |     |     Curve curve,
  68 |     |     Index index
  69 |     |   ) internal pure returns (
  70 |     |     X59 q
  71 |     |   ) {
  72 |     |     assembly {
  73 |     |       // Each member of the curve sequence is '64 bits == 8 bytes' which is why
  74 |     |       // we are shifting index by '3' bits (i.e., we are multiplying index by
  75 |     |       // '8 == 2 ** 3'). We load the memory slot whose most significant 64 bits
  76 |     |       // host the member that we are interested in. Then, we shift the content
  77 |     |       // by 192 bits to the right in order to discard the remaining bits.
  78 |     |       //
  79 |     |       //       ----------------------------------------------------
  80 |     |       //       | 64 bit member to be loaded | 192 additional bits |
  81 |     |       //       +---------------------------------------------------
  82 |     |       //       |
  83 |     |       //    pointer == curve + (index << 3)
  84 |     |       //
  85 |     |       // The addition is safe because index out-of-range is avoided externally.
  86 |     |       q := shr(192, mload(add(curve, shl(3, index))))
  87 |     |     }
  88 |     |   }
  89 |     | 
  90 |     |   /// @notice Returns the leftmost and rightmost members of the curve sequence.
  91 |     |   function boundaries(
  92 |     |     Curve curve
  93 |     |   ) internal pure returns (
  94 |     |     X59 qLower,
  95 |     |     X59 qUpper
  96 |     |   ) {
  97 |     |     // The first and the second members of the curve sequence are loaded.
  98 |     |     // Index-out-of-range is not possible because the curve sequence has at
  99 |     |     // least two members.
 100 |     |     qLower = curve.member(zeroIndex);
 101 |     |     qUpper = curve.member(oneIndex);
 102 |     | 
 103 |     |     // The two boundaries are arranged in order.
 104 |     |     //
 105 |     |     // Signed comparison is valid because both values are nonnegative and 
 106 |     |     // do not exceed '2 ** 64' since each one is loaded from 64 bits of memory.
 107 |     |     (qLower, qUpper) = (qUpper <= qLower) ? 
 108 |     |                        (qUpper, qLower) : 
 109 |     |                        (qLower, qUpper);
 110 |     |   }
 111 |     | 
 112 |     |   /// @notice Validates an initial curve provided by the pool creator.
 113 |     |   function validate(
 114 |     |     Curve curve
 115 |     |   ) internal pure returns (
 116 |     |     X59 qLower,
 117 |     |     X59 qUpper
 118 |     |   ) {
 119 |     |     // The first and the second members of the curve sequence to be verified
 120 |     |     // are loaded. The curve sequence is read from an 'uint256[]' calldata
 121 |     |     // array, whose length is non-zero due to the custom error
 122 |     |     // 'CurveLengthIsZero()'. Hence, index out of range is not possible at this
 123 |     |     // point.
 124 |     |     X59 q0 = curve.member(zeroIndex);
 125 |     |     X59 q1 = curve.member(oneIndex);
 126 |     |     
 127 |     |     // The output of 'member' is always non-negative and never exceeds 
 128 |     |     // '2 ** 64' (read from 64 bits of memory). Hence, signed comparison is
 129 |     |     // valid.
 130 |     |     (qLower, qUpper) = (q0 <= q1) ? (q0, q1) : (q1, q0);
 131 |     | 
 132 |     |     // Underflow is not possible due to the above rearrangement of 'qLower' and
 133 |     |     // 'qUpper'.
 134 |     |     X59 qSpacing = qUpper - qLower;
 135 |     | 
 136 |     |     // This is a one time calculation of 'sqrtSpacing' and 
 137 |     |     // 'sqrtInverseSpacing'. They will be used later for swaps.
 138 |     |     _spacing_.storePrice(qSpacing);
 139 |     | 
 140 |     |     // Since both sides are non-negative and less than '2 ** 64', all three 
 141 |     |     // signed comparisons are valid.
 142 |     |     require(qSpacing >= minLogSpacing, LogSpacingIsTooSmall(qSpacing));
 143 |     |     require(
 144 |     |       qLower > qSpacing,
 145 |     |       BlankIntervalsShouldBeAvoided(qLower, qUpper)
 146 |     |     );
 147 |     | 
 148 |     |     // Underflow is not possible because 'qSpacing' does not exceed '64' bits.
 149 |     |     // Hence, 'qSpacing <= (2 ** 64) - 1 < thirtyTwoX59'.
 150 |     |     require(
 151 |     |       qUpper < thirtyTwoX59 - qSpacing,
 152 |     |       BlankIntervalsShouldBeAvoided(qLower, qUpper)
 153 |     |     );
 154 |     | 
 155 |     |     Index length = twoIndex;
 156 |     |     while (true) {
 157 |     |       // This may be an out-of-range access which is intentional, because we
 158 |     |       // break before using 'q2' if 'length' is out of range.
 159 |     |       X59 q2 = curve.member(length);
 160 |     | 
 161 |     |       // During initialization of a pool, the provided 'curve' is always
 162 |     |       // followed by at least '64' bits of '0'. Hence, this indicates that we
 163 |     |       // have reached the end of the curve.
 164 |     |       if (q2 == zeroX59) break;
 165 |     | 
 166 |     |       // Here, we are checking the requirement:
 167 |     |       //
 168 |     |       //  'min(q0, q1) < q2 < max(q0, q1)'
 169 |     |       //
 170 |     |       // The output of 'member' is always non-negative and never exceeds 64
 171 |     |       // bits (loaded from 64 bits of memory). Hence signed comparisons are
 172 |     |       // valid.
 173 |     |       if ((q2 <= q0) || (q1 <= q2)) {
 174 |     |         if ((q2 <= q1) || (q0 <= q2)) {
 175 |     |           revert InvalidCurveArrangement(q0, q1, q2);
 176 |     |         }
 177 |     |       }
 178 |     | 
 179 |     |       // The two most recent members are shifted so that a new member can be
 180 |     |       // loaded as 'q2'.
 181 |     |       q0 = q1;
 182 |     |       q1 = q2;
 183 |     | 
 184 |     |       // This addition is safe and never exceeds the '2 ** 256 - 1' limit.
 185 |     |       length = length + oneIndex;
 186 |     |     }
 187 |     | 
 188 |     |     // The length of the given curve should not exceed 'maxCurveIndex'.
 189 |     |     require(length <= maxCurveIndex, CurveIndexOutOfRange(length));
 190 |     | 
 191 |     |     // 'q1' is the last valid member of the curve and therefore, it is set in
 192 |     |     // memory as 'qCurrent'.
 193 |     |     setLogPriceCurrent(q1);
 194 |     | 
 195 |     |     // The 'length' of the curve is stored in its appropriate memory location.
 196 |     |     // Due to the above check, this value is less than '2 ** 16' and can be
 197 |     |     // safely stored in the allocated 2 bytes of memory space.
 198 |     |     setCurveLength(length);
 199 |     |   }
 200 |     | 
 201 |     |   /// @notice Generates a new curve with two members and stores its memory
 202 |     |   /// pointer in the appropriate memory location.
 203 |     |   ///
 204 |     |   /// 'qCurrent' and 'qOther' should be positive and smaller than 
 205 |     |   /// 'thirtyTwoX59'.
 206 |     |   function newCurve(
 207 |     |     Curve curve,
 208 |     |     X59 qCurrent,
 209 |     |     X59 qOther
 210 |     |   ) internal pure {
 211 |     |     assembly {
 212 |     |       mstore(
 213 |     |         curve,
 214 |     |         or(
 215 |     |           // 'qOther' is written in the first place.
 216 |     |           shl(192, qOther),
 217 |     |           // 'qCurrent' is written in the second place.
 218 |     |           shl(128, qCurrent)
 219 |     |         )
 220 |     |       )
 221 |     |     }
 222 |     | 
 223 |     |     // The new length is stored in the allocated memory location.
 224 |     |     setCurveLength(twoIndex);
 225 |     |   }
 226 |     | 
 227 |     |   /// @notice Amends the curve by adding a new member.
 228 |     |   /// @param q is the given logarithmic price to be added to the curve
 229 |     |   /// sequence.
 230 |     |   /// 'q' must be positive and less than '2 ** 64'.
 231 |     |   function amend(
 232 |     |     Curve curve,
 233 |     |     X59 q
 234 |     |   ) internal pure {
 235 |     |     // The first and second members of the curve are loaded.
 236 |     |     // Index out of range is not possible because the curve has at least two 
 237 |     |     // members.
 238 |     |     X59 q0 = curve.member(zeroIndex);
 239 |     |     X59 q1 = curve.member(oneIndex);
 240 |     | 
 241 |     |     // If 'q' is not within the current active interval, then a new curve
 242 |     |     // sequence is constructed. Signed comparison is valid because 'q0', 'q1',
 243 |     |     // and 'q' are nonnegative and do not exceed 64 bits.
 244 |     |     if (q <= min(q0, q1)) {
 245 |     |       newCurve(curve, min(q0, q1), max(q0, q1));
 246 |     |       return;
 247 |     |     }
 248 |     |     if (max(q0, q1) <= q) {
 249 |     |       newCurve(curve, max(q0, q1), min(q0, q1));
 250 |     |       return;
 251 |     |     }
 252 |     | 
 253 |     |     // The length of the curve is loaded from the memory.
 254 |     |     Index length = getCurveLength();
 255 |     | 
 256 |     |     // Every member of the curve is exhausted until either the following rule
 257 |     |     // is violated or runs out of members:
 258 |     |     //
 259 |     |     // 'min(q[k - 1], q[k - 2]) < q[k] < max(q[k - 1], q[k - 2])'.
 260 |     |     //
 261 |     |     // Then, 'q' is written in the corresponding place and the rest of that
 262 |     |     // slot is cleared.
 263 |     |     Index index = oneIndex;
 264 |     |     while (true) {
 265 |     |       // Is 'q' between 'q0' and 'q1'? If so, we proceed forward, otherwise,
 266 |     |       // 'q' is written in place of 'q1' and the rest of that slot is cleared.
 267 |     |       // Signed comparisons are valid because 'q0', 'q1', and 'q' are
 268 |     |       // non-negative and do not exceed 64 bits.
 269 |     |       if ((q0 < q1) ? (q < q1) : (q1 < q)) {
 270 |     |         // This addition is safe and never exceeds the '2 ** 256 - 1' limit.
 271 |     |         index = index + oneIndex;
 272 |     |         q0 = q1;
 273 |     |         if (index < length) {
 274 |     |           // Index out-of-range is not possible due to the above check.
 275 |     |           q1 = curve.member(index);
 276 |     |         } else {
 277 |     |           break;
 278 |     |         }
 279 |     |       } else {
 280 |     |         break;
 281 |     |       }
 282 |     |     }
 283 |     | 
 284 |     |     // 'q' is added to the end.
 285 |     |     // This is not an out-of-range addition because one additional slot is
 286 |     |     // always reserved for the amendment of the curve. A maximum of 2
 287 |     |     // amendments occur per swap.
 288 |     |     assembly {
 289 |     |       mstore(add(curve, shl(3, index)), shl(192, q))
 290 |     |     }
 291 |     | 
 292 |     |     // 'index + oneIndex' must not exceed 'maxIndex'.
 293 |     |     require(index < maxCurveIndex, CurveIndexOutOfRange(index));
 294 |     | 
 295 |     |     // Lastly, 'curveLength' is updated.
 296 |     |     // Due to the above check, this value is less than '2 ** 16' and can be
 297 |     |     // safely stored in the allocated 2 bytes of memory space.
 298 |     |     setCurveLength(index + oneIndex);
 299 |     |   }
 300 |     | }

R:/LIAT.AI/question2-calldata/contracts/utilities/Errors.sol
   1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
   2 |     | pragma solidity ^0.8.28;
   3 |     | 
   4 |     | import {Index} from "./Index.sol";
   5 |     | import {X15} from "./X15.sol";
   6 |     | import {X47} from "./X47.sol";
   7 |     | import {X59} from "./X59.sol";
   8 |     | import {X111} from "./X111.sol";
   9 |     | import {X127} from "./X127.sol";
  10 |     | import {X208} from "./X208.sol";
  11 |     | import {X216} from "./X216.sol";
  12 |     | import {Tag} from "./Tag.sol";
  13 |     | 
  14 |     | /// @notice Thrown in case of overflow when attempting to calculate
  15 |     | /// '(a * b) / denominator'.
  16 |     | error MulDivOverflow(uint256 a, uint256 b, uint256 denominator);
  17 |     | 
  18 |     | /// @notice Thrown in case of overflow or underflow when attempting to
  19 |     | /// calculate 'a + b'.
  20 |     | error SafeAddFailed(X127 a, X127 b);
  21 |     | 
  22 |     | /// @notice Thrown when balance exceeds 'type(uint128).max'.
  23 |     | error BalanceOverflow(uint256 balance);
  24 |     | 
  25 |     | /// @notice Thrown when safe cast into an int256 overflows.
  26 |     | error SafeCastOverflow(uint256 value);
  27 |     | 
  28 |     | /// @notice Thrown when the given 'qSpacing' is less than 'minLogSpacing'.
  29 |     | error LogSpacingIsTooSmall(X59 qSpacing);
  30 |     | 
  31 |     | /// @notice Thrown when attempting to initialize a curve sequence on blank
  32 |     | /// intervals.
  33 |     | error BlankIntervalsShouldBeAvoided(X59 qLower, X59 qUpper);
  34 |     | 
  35 |     | /// @notice Thrown when 'curveLength' is zero upon initialization.
  36 |     | error CurveLengthIsZero();
  37 |     | 
  38 |     | /// @notice Each member of the curve sequence should be in-between the
  39 |     | /// preceding two members. Thrown when a given initial curve sequence violates
  40 |     | /// this rule.
  41 |     | error InvalidCurveArrangement(X59 q0, X59 q1, X59 q2);
  42 |     | 
  43 |     | /// @notice Thrown when 'curveLength' is out of range.
  44 |     | error CurveIndexOutOfRange(Index length);
  45 |     | 
  46 |     | /// @notice Thrown in case of overflow when attempting to calculate 
  47 |     | ///
  48 |     | /// 'amount := ceiling(
  49 |     | ///
  50 |     | ///     shares *
  51 |     | ///
  52 |     | ///     (getZeroForOne() ? sqrtOffset : sqrtInverseOffset) * 
  53 |     | ///
  54 |     | ///      multiplier
  55 |     | ///     ------------
  56 |     | ///       2 ** 208
  57 |     | ///  )'.
  58 |     | error SafeOutOfRangeAmountOverflow(
  59 |     |   X127 sqrtOffsetOrSqrtInverseOffset,
  60 |     |   X208 growthMultiplier,
  61 |     |   int256 shares
  62 |     | );
  63 |     | 
  64 |     | /// @notice Thrown in case of overflow when attempting to calculate 
  65 |     | ///
  66 |     | /// 'amount := ceiling(
  67 |     | ///
  68 |     | ///     (zeroOrOne ? sqrtOffset : sqrtInverseOffset) * 
  69 |     | ///
  70 |     | ///      liquidity      integral
  71 |     | ///     ----------- * -------------
  72 |     | ///       2 ** 111     outgoingMax
  73 |     | ///  )'.
  74 |     | error SafeInRangeAmountOverflow(
  75 |     |   X127 sqrtOffsetOrSqrtInverseOffset,
  76 |     |   X216 integral,
  77 |     |   X111 liquidity,
  78 |     |   X216 outgoingMax,
  79 |     |   uint256 outgoingMaxModularInverse
  80 |     | );
  81 |     | 
  82 |     | /// @notice Thrown when the second horizontal coordinate of a given kernel is
  83 |     | /// '0'. In this case, we have a vertical jump at the origin which limits
  84 |     | /// liquidity growth.
  85 |     | error SecondHorizontalCoordinateIsZero();
  86 |     | 
  87 |     | /// @notice The horizontal coordinates should be monotonically non-decreasing.
  88 |     | error NonMonotonicHorizontalCoordinates(X59 q_i, X59 q_j);
  89 |     | 
  90 |     | /// @notice The vertical coordinates should be monotonically non-decreasing.
  91 |     | error NonMonotonicVerticalCoordinates(X15 c_i, X15 c_j);
  92 |     | 
  93 |     | /// @notice There should not be repetitive points.
  94 |     | error RepetitiveKernelPoints(X15 c_i, X59 q_i);
  95 |     | 
  96 |     | /// @notice Thrown when the horizontal coordinates of a non-vertical and 
  97 |     | /// non-horizontal segment are closer than '2 ** 32'.
  98 |     | error SlopeTooHigh(X59 q_i, X59 q_j);
  99 |     | 
 100 |     | /// @notice Thrown when the horizontal coordinates of a given 'kernelCompact'
 101 |     | /// exceeds 'qSpacing'.
 102 |     | error HorizontalCoordinatesMayNotExceedLogSpacing(X59 q_j, X59 qSpacing);
 103 |     | 
 104 |     | /// @notice There should not be three repetitive horizontal coordinates. A 
 105 |     | /// vertical jump (i.e., discontinuity) is permitted and can be constructed
 106 |     | /// via two repetitive horizontal coordinates. However, three repetitive
 107 |     | /// horizontal coordinates are always redundant and should be avoided.
 108 |     | error RepetitiveHorizontalCoordinates(X59 q_i);
 109 |     | 
 110 |     | /// @notice There should not be three repetitive vertical coordinates. A 
 111 |     | /// horizontal segment (i.e., constant range) is permitted and can be 
 112 |     | /// constructed via two repetitive vertical coordinates. However, three
 113 |     | /// repetitive vertical coordinates are always redundant and should be
 114 |     | /// avoided.
 115 |     | error RepetitiveVerticalCoordinates(X15 c_i);
 116 |     | 
 117 |     | /// @notice Thrown when 'kernelLength' is out of range.
 118 |     | error KernelIndexOutOfRange(Index length);
 119 |     | 
 120 |     | /// @notice The last vertical coordinate should be equal to 'oneX15'.
 121 |     | error LastVerticalCoordinateMismatch(X15 c_j);
 122 |     | 
 123 |     | /// @notice Thrown when growth exceeds maximum permitted value of 'maxGrowth'.
 124 |     | error GrowthOverflow();
 125 |     | 
 126 |     | /// @notice Thrown when accrued growth portion values exceed '2 ** 104 - 1'.
 127 |     | error AccruedGrowthPortionOverflow(X127 accruedValue);
 128 |     | 
 129 |     | /// @notice Thrown when given flags are invalid or not consistent with hook.
 130 |     | error InvalidFlags(uint256);
 131 |     | 
 132 |     | /// @notice Thrown when the numerical search for outgoing target fails which 
 133 |     | /// should never heappen.
 134 |     | error SearchingForOutgoingTargetFailed();
 135 |     | 
 136 |     | /// @notice Thrown when the numerical search for incoming target fails which
 137 |     | /// should never heappen.
 138 |     | error SearchingForIncomingTargetFailed();
 139 |     | 
 140 |     | /// @notice Thrown when the numerical search for overshoot fails which should
 141 |     | /// never heappen.
 142 |     | error SearchingForOvershootFailed();
 143 |     | 
 144 |     | /// @notice Thrown if attempting to unlock the protocol while already unlocked.
 145 |     | error AlreadyUnlocked(address currentCaller);
 146 |     | 
 147 |     | /// @notice Thrown when any of the following methods are invoked prior to the
 148 |     | /// protocol being unlocked:
 149 |     | ///
 150 |     | ///   'INofeeswap.clear'
 151 |     | ///   'INofeeswap.take'
 152 |     | ///   'INofeeswap.settle'
 153 |     | ///   'INofeeswap.transferTransientBalanceFrom'
 154 |     | ///   'INofeeswap.modifyBalance'
 155 |     | ///   'INofeeswap.swap'
 156 |     | ///   'INofeeswapDelegatee.modifyPosition'
 157 |     | ///   'INofeeswapDelegatee.donate'
 158 |     | ///
 159 |     | error ProtocolIsLocked();
 160 |     | 
 161 |     | /// @notice Thrown when attempting to perform the following operations on a 
 162 |     | /// pool which is locked:
 163 |     | ///
 164 |     | ///   'INofeeswap.swap'
 165 |     | ///   'INofeeswapDelegatee.modifyPosition'
 166 |     | ///   'INofeeswapDelegatee.donate'
 167 |     | ///   'INofeeswapDelegatee.modifyKernel'
 168 |     | ///   'INofeeswapDelegatee.modifyPoolGrowthPortion'
 169 |     | ///   'INofeeswapDelegatee.updateGrowthPortions'
 170 |     | ///   'INofeeswapDelegatee.collectPool'
 171 |     | ///   'INofeeswapDelegatee.collectProtocol'
 172 |     | ///
 173 |     | error PoolIsLocked(uint256 poolId);
 174 |     | 
 175 |     | /// @notice Thrown when the deployment of static parameters fail.
 176 |     | error DeploymentFailed();
 177 |     | 
 178 |     | /// @notice Thrown when the method 'redeployStaticParamsAndKernel' is run
 179 |     | /// externally.
 180 |     | error CannotRedeployStaticParamsAndKernelExternally();
 181 |     | 
 182 |     | /// @notice Thrown when attempting to sync protocol's reserve of native token.
 183 |     | error NativeTokenCannotBeSynced();
 184 |     | 
 185 |     | /// @notice Thrown when the spender allowance for a tag is insufficient.
 186 |     | error InsufficientPermission(address spender, Tag tag);
 187 |     | 
 188 |     | /// @notice Thrown when the total number of shares accross all liquidity
 189 |     | /// intervals exceed '2 ** 127 - 1'.
 190 |     | error SharesGrossOverflow(int256 sharesGross);
 191 |     | 
 192 |     | /// @notice Thrown when attempting to access a pool which does not exist.
 193 |     | error PoolDoesNotExist(uint256 poolId);
 194 |     | 
 195 |     | /// @notice Thrown when the owner balance for a tag is insufficient.
 196 |     | error InsufficientBalance(address owner, Tag tag);
 197 |     | 
 198 |     | /// @notice Throws when Sentinel response is invalid.
 199 |     | error InvalidSentinelResponse(bytes4 response);
 200 |     | 
 201 |     | /// @notice Thrown when the given 'zeroForOne' is not in agreement with 
 202 |     | /// 'logPriceLimitOffsetted'.
 203 |     | error InvalidDirection(X59 current, X59 limit);
 204 |     | 
 205 |     | /// @notice Thrown when attempting to initialize a pool that already exists.
 206 |     | error PoolExists(uint256 poolId);
 207 |     | 
 208 |     | /// @notice Thrown when 'log(pOffset)' is not within the range '[-89, +89]'.
 209 |     | error LogOffsetOutOfRange(X59 qOffset);
 210 |     | 
 211 |     | /// @notice Thrown when the given tags are not in the correct order, i.e.,
 212 |     | /// 'tag0 < tag1'.
 213 |     | error TagsOutOfOrder(Tag tag0, Tag tag1);
 214 |     | 
 215 |     | /// @notice Thrown when a given growth portion is greater than one.
 216 |     | error InvalidGrowthPortion(X47 poolGrowthPortion);
 217 |     | 
 218 |     | /// @notice Thrown when a given logarithmic price does not belong to the range
 219 |     | /// '[log(pOffset) - 16 + 1 / (2 ** 59), log(pOffset) + 16 - 1 / (2 ** 59)]'.
 220 |     | error LogPriceOutOfRange(X59 logPrice);
 221 |     | 
 222 |     | /// @notice Thrown when attempting to mint/burn a position with zero shares or
 223 |     | /// when the number of shares does not belong to 
 224 |     | /// '[- type(int128).max, type(int128).max]'.
 225 |     | error InvalidNumberOfShares(int256 shares);
 226 |     | 
 227 |     | /// @notice Thrown when attempting to initialize a pool with 'poolId == 0'.
 228 |     | error PoolIdCannotBeZero();
 229 |     | 
 230 |     | /// @notice Thrown when attempting to access protocol operations via an
 231 |     | /// unauthorized address.
 232 |     | error OnlyByProtocol(address attemptingAddress, address protocolAddress);
 233 |     | 
 234 |     | /// @notice Thrown when attempting to access pool operations via an
 235 |     | /// unauthorized address.
 236 |     | error OnlyByPoolOwner(address attemptingAddress, address poolOwnerAddress);
 237 |     | 
 238 |     | /// @notice Thrown when attempting to mint/burn a position with invalid
 239 |     | /// lower bound which is not equal to interval boundaries modulo 'qSpacing'.
 240 |     | error LogPriceMinIsNotSpaced(X59 logPriceMin);
 241 |     | 
 242 |     | /// @notice Thrown when attempting to mint/burn a position with invalid
 243 |     | /// upper bound which is not equal to interval boundaries modulo 'qSpacing'.
 244 |     | error LogPriceMaxIsNotSpaced(X59 logPriceMax);
 245 |     | 
 246 |     | /// @notice Thrown when attempting to mint/burn a position with invalid
 247 |     | /// lower bound which is not greater than 'qSpacing'
 248 |     | error LogPriceMinIsInBlankArea(X59 logPriceMin);
 249 |     | 
 250 |     | /// @notice Thrown when attempting to mint/burn a position with invalid
 251 |     | /// lower bound which is not less than 'thirtyTwoX59 - qSpacing'.
 252 |     | error LogPriceMaxIsInBlankArea(X59 logPriceMax);
 253 |     | 
 254 |     | /// @notice Thrown when the given logPrices for a position are not in the
 255 |     | /// correct order.
 256 |     | error LogPricesOutOfOrder(X59 logPriceMin, X59 logPriceMax);
 257 |     | 
 258 |     | /// @notice Thrown when attempting donate to a pool whose donate flag is not 
 259 |     | /// active.
 260 |     | error DonateIsNotAllowed(uint256 poolId);
 261 |     | 
 262 |     | /// @notice Thrown when attempting to perform a donate to an empty interval.
 263 |     | error CannotDonateToEmptyInterval();
 264 |     | 
 265 |     | /// @notice Thrown when attempting to change an immutable kernel.
 266 |     | error ImmutableKernel(uint256 poolId);
 267 |     | 
 268 |     | /// @notice Thrown when attempting to change an immutable poolGrowthPortion.
 269 |     | error ImmutablePoolGrowthPortion(uint256 poolId);
 270 |     | 
 271 |     | /// @notice Thrown when attempting to make a delegate call to the protocol.
 272 |     | error NoDelegateCall(address context);
 273 |     | 
 274 |     | /// @notice Thrown when transient balances are not cleared.
 275 |     | error OutstandingAmount();
 276 |     | 
 277 |     | /// @notice Thrown when attempting to transfer NofeeAssets to address 0.
 278 |     | error CannotTransferToAddressZero();
 279 |     | 
 280 |     | /// @notice Thrown when the amount to be cleared is not equal to the transient
 281 |     | /// balance of 'msg.sender'.
 282 |     | error NotEqualToTransientBalance(int256 currentBalance);
 283 |     | 
 284 |     | /// @notice Thrown when the size of 'hookData' exceeds 'type(uint16).max'.
 285 |     | error HookDataTooLong(uint256 hookDataByteCount);
 286 |     | 
 287 |     | /// @notice Thrown when attempting to transfer ownership to address 0.
 288 |     | error AdminCannotBeAddressZero();
 289 |     | 
 290 |     | /// @notice Thrown when attempting to settle a tag with nonzero 'msg.value'.
 291 |     | error MsgValueIsNonZero(uint256 msgValue);
 292 |     | 
 293 |     | /// @notice Thrown when attempting to mint a position after burning it in the
 294 |     | /// same transaction.
 295 |     | error CannotMintAfterBurning(uint256 poolId, X59 qMin, X59 qMax);

R:/LIAT.AI/question2-calldata/contracts/utilities/Events.sol
   1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
   2 |     | pragma solidity ^0.8.28;
   3 |     | 
   4 |     | import {ISentinel} from "../interfaces/ISentinel.sol";
   5 |     | import {INofeeswap} from "../interfaces/INofeeswap.sol";
   6 |     | import {
   7 |     |   _staticParams_,
   8 |     |   _modifyPositionInput_,
   9 |     |   _endOfModifyPosition_,
  10 |     |   _poolGrowthPortion_,
  11 |     |   _maxPoolGrowthPortion_,
  12 |     |   _growth_,
  13 |     |   getPoolId,
  14 |     |   getTag0,
  15 |     |   getTag1,
  16 |     |   getHookData,
  17 |     |   getCurve,
  18 |     |   getCurveLength
  19 |     | } from "./Memory.sol";
  20 |     | import {getProtocolOwner} from "./Storage.sol";
  21 |     | import {KernelCompact} from "./KernelCompact.sol";
  22 |     | import {Tag} from "./Tag.sol";
  23 |     | import {Curve} from "./Curve.sol";
  24 |     | import {Index} from "./Index.sol";
  25 |     | import {X47} from "./X47.sol";
  26 |     | 
  27 |     | function emitTransferEvent(
  28 |     |   address caller,
  29 |     |   address from,
  30 |     |   address to,
  31 |     |   Tag tag,
  32 |     |   uint256 amount
  33 |     | ) {
  34 |     |   emit INofeeswap.Transfer(caller, from, to, tag, amount);
  35 |     | }
  36 |     | 
  37 |     | function emitOperatorSetEvent(
  38 |     |   address owner,
  39 |     |   address operator,
  40 |     |   bool approved
  41 |     | ) {
  42 |     |   emit INofeeswap.OperatorSet(owner, operator, approved);
  43 |     | }
  44 |     | 
  45 |     | function emitApprovalEvent(
  46 |     |   address owner,
  47 |     |   address spender,
  48 |     |   Tag tag,
  49 |     |   uint256 amount
  50 |     | ) {
  51 |     |   emit INofeeswap.Approval(owner, spender, tag, amount);
  52 |     | }
  53 |     | 
  54 |     | function emitModifyDoubleBalanceEvent(
  55 |     |   address caller,
  56 |     |   address owner,
  57 |     |   Tag tag,
  58 |     |   int256 increment,
  59 |     |   uint256 balance
  60 |     | ) {
  61 |     |   emit INofeeswap.ModifyDoubleBalanceEvent(
  62 |     |     caller,
  63 |     |     owner,
  64 |     |     tag,
  65 |     |     increment,
  66 |     |     balance
  67 |     |   );
  68 |     | }
  69 |     | 
  70 |     | function emitPoolCollectionEvent(
  71 |     |   uint256 poolId,
  72 |     |   address owner,
  73 |     |   uint256 amount0,
  74 |     |   uint256 amount1
  75 |     | ) {
  76 |     |   emit INofeeswap.PoolCollection(poolId, owner, amount0, amount1);
  77 |     | }
  78 |     | 
  79 |     | function emitProtocolCollectionEvent(
  80 |     |   uint256 poolId,
  81 |     |   uint256 amount0,
  82 |     |   uint256 amount1
  83 |     | ) {
  84 |     |   emit INofeeswap.ProtocolCollection(poolId, amount0, amount1);
  85 |     | }
  86 |     | 
  87 |     | function emitModifyProtocolEvent(
  88 |     |   uint256 newProtocol
  89 |     | ) {
  90 |     |   emit INofeeswap.ModifyProtocol(getProtocolOwner(newProtocol), newProtocol);
  91 |     | }
  92 |     | 
  93 |     | function emitModifySentinelEvent(
  94 |     |   ISentinel oldSentinel,
  95 |     |   ISentinel newSentinel
  96 |     | ) {
  97 |     |   emit INofeeswap.ModifySentinel(oldSentinel, newSentinel);
  98 |     | }
  99 |     | 
 100 |     | function emitModifyPoolOwnerEvent(
 101 |     |   uint256 poolId,
 102 |     |   address oldOwner,
 103 |     |   address newOwner
 104 |     | ) {
 105 |     |   emit INofeeswap.ModifyPoolOwner(poolId, oldOwner, newOwner);
 106 |     | }
 107 |     | 
 108 |     | function emitInitializeEvent() {
 109 |     |   uint256 poolId = getPoolId();
 110 |     |   Tag tag0 = getTag0();
 111 |     |   Tag tag1 = getTag1();
 112 |     |   uint256 hookData = getHookData();
 113 |     |   bytes32 selector = INofeeswap.Initialize.selector;
 114 |     |   assembly {
 115 |     |     // The byte count of the data to be emitted which does not include the abi
 116 |     |     // offset and length slot.
 117 |     |     // The subtraction is safe because 'hookData' is always ahead of
 118 |     |     // '_staticParams_' per 'Calldata.sol'.
 119 |     |     let size := sub(hookData, _staticParams_)
 120 |     |     
 121 |     |     // This slot should be populated with the abi offset. Hence, we cache its
 122 |     |     // current content so that it can be written back. Then we store a '0x20'
 123 |     |     // abi offset for the data to be emitted.
 124 |     |     // The subtractions are safe because both values are constants.
 125 |     |     let content0 := mload(sub(_staticParams_, 64))
 126 |     |     mstore(sub(_staticParams_, 64), 0x20)
 127 |     | 
 128 |     |     // This slot should be populated with 'size'. Hence, we cache its current
 129 |     |     // content so that it can be written back. Then we store a 'size'.
 130 |     |     // The subtractions are safe because both values are constants.
 131 |     |     let content1 := mload(sub(_staticParams_, 32))
 132 |     |     mstore(sub(_staticParams_, 32), size)
 133 |     | 
 134 |     |     // The number of bytes to be emitted should be divisible by '32'. If
 135 |     |     // '32 * ceiling(size / 32)' goes beyond 'size', then the extra bytes
 136 |     |     // should be equal to zero. Hence, we cache the content of this slot, so
 137 |     |     // that it can be restored after being zeroed. We then write zero in this
 138 |     |     // slot.
 139 |     |     let content2 := mload(hookData)
 140 |     |     mstore(hookData, 0)
 141 |     | 
 142 |     |     // Here, we calculate '32 * ceiling(size / 32)' which is the actual number
 143 |     |     // of bytes to be given as input to 'log4'.
 144 |     |     let module := mod(size, 0x20)
 145 |     |     if gt(module, 0) {
 146 |     |       size := add(sub(size, module), 0x20)
 147 |     |     }
 148 |     | 
 149 |     |     log4(
 150 |     |       // During initialization, 'staticParams', 'kernel', 'kernelCompact',
 151 |     |       // 'curve', and 'hookData' appear in this order in memory. Hence, the
 152 |     |       // beginning of event data is '_staticParams_' which points to the start
 153 |     |       // of 'staticParams' and the end of event data is 'hookData' which points
 154 |     |       // to the end of 'curve'. '64' is subtracted in order to include the abi
 155 |     |       // offset and 'size' slots.
 156 |     |       sub(_staticParams_, 64),
 157 |     |       // As argued above, 'hookData - _staticParams_' is the number of bytes to
 158 |     |       // be emitted. '64' is added in order to include the abi offset and
 159 |     |       // 'size' slots.
 160 |     |       add(size, 64),
 161 |     |       selector,
 162 |     |       poolId,
 163 |     |       tag0,
 164 |     |       tag1
 165 |     |     )
 166 |     | 
 167 |     |     // Now we restore all of the cached content.
 168 |     |     mstore(sub(_staticParams_, 64), content0)    
 169 |     |     mstore(sub(_staticParams_, 32), content1)
 170 |     |     mstore(hookData, content2)
 171 |     |   }
 172 |     | }
 173 |     | 
 174 |     | function emitModifyPositionEvent() {
 175 |     |   uint256 poolId = getPoolId();
 176 |     |   bytes32 selector = INofeeswap.ModifyPosition.selector;
 177 |     |   assembly {
 178 |     |     // The number of bytes to be emitted should be divisible by '32'. Since
 179 |     |     // '32 * ceiling((_endOfModifyPosition_ - _modifyPositionInput_) / 32)'
 180 |     |     // goes beyond '_endOfModifyPosition_ - _modifyPositionInput_', the extra
 181 |     |     // bytes should be equal to zero. Hence, we cache the content of this slot,
 182 |     |     // so that it can be restored after being zeroed. We then write zero in
 183 |     |     // this slot.
 184 |     |     let content := mload(_endOfModifyPosition_)
 185 |     |     mstore(_endOfModifyPosition_, 0)
 186 |     | 
 187 |     |     log3(
 188 |     |       // As described in 'Memory.sol', in order to include all of the above
 189 |     |       // seven parameters, the beginning of event data should be
 190 |     |       // '_modifyPositionInput_' and the end of event data should be
 191 |     |       // '_endOfModifyPosition_'.
 192 |     |       _modifyPositionInput_,
 193 |     |       // As argued above, '_endOfModifyPosition_ - _modifyPositionInput_' is
 194 |     |       // the number of bytes to be emitted.
 195 |     |       // '16' is added because we want the number of bytes to be emitted to be
 196 |     |       // divisible by '32'.
 197 |     |       add(sub(_endOfModifyPosition_, _modifyPositionInput_), 16),
 198 |     |       selector,
 199 |     |       poolId,
 200 |     |       caller()
 201 |     |     )
 202 |     | 
 203 |     |     // Now we restore the cached content.
 204 |     |     mstore(_endOfModifyPosition_, content)
 205 |     |   }
 206 |     | }
 207 |     | 
 208 |     | function emitDonateEvent() {
 209 |     |   uint256 poolId = getPoolId();
 210 |     |   bytes32 selector = INofeeswap.Donate.selector;
 211 |     |   assembly {
 212 |     |     // We copy zeros to the end of 'growth' and emit the total '32' bytes.
 213 |     |     let content := mload(add(_growth_, 16))
 214 |     |     mstore(add(_growth_, 16), 0)
 215 |     | 
 216 |     |     // As described in 'Memory.sol', the pointer '_growth_' points to the
 217 |     |     // memory slot whose most significant '128' bits host 'growth'. Hence,
 218 |     |     // the beginning of event data should be '_growth_' and the size of event
 219 |     |     // data should be exactly '32' bytes.
 220 |     |     log3(_growth_, 32, selector, poolId, caller())
 221 |     | 
 222 |     |     // Now we restore the cached content.
 223 |     |     mstore(add(_growth_, 16), content)
 224 |     |   }
 225 |     | }
 226 |     | 
 227 |     | function emitSwapEvent() {
 228 |     |   uint256 poolId = getPoolId();
 229 |     |   Curve curve = getCurve();
 230 |     |   Index curveLength = getCurveLength();
 231 |     |   bytes32 selector = INofeeswap.Swap.selector;
 232 |     |   assembly {
 233 |     |     // The end of the curve sequence is calculated.
 234 |     |     let endOfCurve := add(curve, shl(3, curveLength))
 235 |     | 
 236 |     |     // We copy 'growth' to the end of 'curve' and emit the total '32' bytes.
 237 |     |     let content := mload(endOfCurve)
 238 |     |     mcopy(endOfCurve, _growth_, 16)
 239 |     | 
 240 |     |     log3(
 241 |     |       // The subtraction is safe because the curve sequence has at least '2'
 242 |     |       // members at all times.
 243 |     |       //
 244 |     |       // Each member of the curve sequence is '64 bits == 8 bytes' which is why
 245 |     |       // we shift 'curveLength - 2' by '3' bits (i.e., we are multiplying this
 246 |     |       // value by '8 == 2 ** 3'). We load the memory slot whose most
 247 |     |       // significant 128 bits host the last two members of the curve sequence.
 248 |     |       //
 249 |     |       //       ------------------------------------------------------------
 250 |     |       //       | 64 bits overshoot | 64 bits target | 128 additional bits |
 251 |     |       //       +-----------------------------------------------------------
 252 |     |       //       |
 253 |     |       //    pointer == curve + ((curveLength - 2) << 3)
 254 |     |       //
 255 |     |       // The addition is safe because we do not exceed the length of the curve
 256 |     |       // sequence.
 257 |     |       sub(endOfCurve, 16),
 258 |     |       // 32 bytes is 128 bits which covers exactly two members of the curve
 259 |     |       // sequence and the 'growth' that we have just copied.
 260 |     |       32,
 261 |     |       selector,
 262 |     |       poolId,
 263 |     |       caller()
 264 |     |     )
 265 |     | 
 266 |     |     // Now we restore the cached content.
 267 |     |     mstore(endOfCurve, content)
 268 |     |   }
 269 |     | }
 270 |     | 
 271 |     | function emitModifyKernelEvent() {
 272 |     |   uint256 poolId = getPoolId();
 273 |     |   bytes32 selector = INofeeswap.ModifyKernel.selector;
 274 |     |   uint256 hookData = getHookData();
 275 |     |   assembly {
 276 |     |     // The byte count of the data to be emitted which does not include the abi
 277 |     |     // offset and length slot.
 278 |     |     // The subtraction is safe because 'hookData' is always ahead of
 279 |     |     // '_staticParams_' per 'Calldata.sol'.
 280 |     |     let size := sub(hookData, _staticParams_)
 281 |     |     
 282 |     |     // This slot should be populated with the abi offset. Hence, we cache its
 283 |     |     // current content so that it can be written back. Then we store a '0x20'
 284 |     |     // abi offset for the data to be emitted.
 285 |     |     // The subtractions are safe because both values are constants.
 286 |     |     let content0 := mload(sub(_staticParams_, 64))
 287 |     |     mstore(sub(_staticParams_, 64), 0x20)
 288 |     | 
 289 |     |     // This slot should be populated with 'size'. Hence, we cache its current
 290 |     |     // content so that it can be written back. Then we store a 'size.
 291 |     |     // The subtractions are safe because both values are constants.
 292 |     |     let content1 := mload(sub(_staticParams_, 32))
 293 |     |     mstore(sub(_staticParams_, 32), size)
 294 |     | 
 295 |     |     // The number of bytes to be emitted should be divisible by '32'. If
 296 |     |     // '32 * ceiling(size / 32)' goes beyond 'size', then the extra bytes
 297 |     |     // should be equal to zero. Hence, we cache the content of this slot, so
 298 |     |     // that it can be restored after being zeroed. We then write zero in this
 299 |     |     // slot.
 300 |     |     let content2 := mload(hookData)
 301 |     |     mstore(hookData, 0)
 302 |     | 
 303 |     |     // Here, we calculate '32 * ceiling(size / 32)' which is the actual number
 304 |     |     // of bytes to be given as input to 'log4'.
 305 |     |     let module := mod(size, 0x20)
 306 |     |     if gt(module, 0) {
 307 |     |       size := add(sub(size, module), 0x20)
 308 |     |     }
 309 |     | 
 310 |     |     log3(
 311 |     |       // During modifyKernel, 'staticParams', 'kernel', 'kernelCompact', and
 312 |     |       // 'hookData' appear in this order in memory. Hence, the beginning of
 313 |     |       // event data is '_staticParams_' which points to the start of
 314 |     |       // 'staticParams' and the end of event data is 'hookData' which points
 315 |     |       // to the end of 'kernelCompact'. '64' is subtracted in order to include
 316 |     |       // the abi offset and 'size' slots.
 317 |     |       sub(_staticParams_, 64),
 318 |     |       // As argued above, 'hookData - _staticParams_' is the number of bytes to
 319 |     |       // be emitted. '64' is added in order to include the abi offset and
 320 |     |       // 'size' slots.
 321 |     |       add(size, 64),      
 322 |     |       selector,
 323 |     |       poolId,
 324 |     |       caller()
 325 |     |     )
 326 |     | 
 327 |     |     // Now we restore all of the cached content.
 328 |     |     mstore(sub(_staticParams_, 64), content0)    
 329 |     |     mstore(sub(_staticParams_, 32), content1)
 330 |     |     mstore(hookData, content2)
 331 |     |   }
 332 |     | }
 333 |     | 
 334 |     | function emitModifyPoolGrowthPortionEvent() {
 335 |     |   uint256 poolId = getPoolId();
 336 |     |   bytes32 selector = INofeeswap.ModifyPoolGrowthPortion.selector;
 337 |     |   assembly {
 338 |     |     // We copy zeros to the end of 'poolGrowthPortion' and emit the total '32'
 339 |     |     // bytes.
 340 |     |     let content := mload(add(_poolGrowthPortion_, 6))
 341 |     |     mstore(add(_poolGrowthPortion_, 6), 0)
 342 |     | 
 343 |     |     // As described in 'Memory.sol', the pointer '_poolGrowthPortion_' points
 344 |     |     // to the memory slot whose most significant '48' bits host
 345 |     |     // 'poolGrowthPortion'. Hence, the beginning of event data should be
 346 |     |     // '_poolGrowthPortion_' and the size of event data should be exactly '32'
 347 |     |     // bytes.
 348 |     |     log3(_poolGrowthPortion_, 32, selector, poolId, caller())
 349 |     | 
 350 |     |     // Now we restore the cached content.
 351 |     |     mstore(add(_poolGrowthPortion_, 6), content)
 352 |     |   }
 353 |     | }
 354 |     | 
 355 |     | function emitUpdateGrowthPortionsEvent() {
 356 |     |   uint256 poolId = getPoolId();
 357 |     |   bytes32 selector = INofeeswap.UpdateGrowthPortions.selector;
 358 |     |   assembly {
 359 |     |     // We copy zeros to the end of 'protocolGrowthPortion' and emit the total
 360 |     |     // '32' bytes.
 361 |     |     let content := mload(add(_maxPoolGrowthPortion_, 12))
 362 |     |     mstore(add(_maxPoolGrowthPortion_, 12), 0)
 363 |     | 
 364 |     |     // As described in 'Memory.sol', the pointer '_maxPoolGrowthPortion_'
 365 |     |     // points to the memory slot whose most significant '48' bits host
 366 |     |     // 'maxPoolGrowthPortion'. The next '48' bits that appear immediately after
 367 |     |     // 'maxPoolGrowthPortion' host 'protocolGrowthPortion'. Hence, the
 368 |     |     // beginning of event data should be '_maxPoolGrowthPortion_' and the size
 369 |     |     // of event data should be exactly '32' bytes.
 370 |     |     log3(_maxPoolGrowthPortion_, 32, selector, poolId, caller())
 371 |     | 
 372 |     |     // Now we restore the cached content.
 373 |     |     mstore(add(_maxPoolGrowthPortion_, 12), content)
 374 |     |   }
 375 |     | }

R:/LIAT.AI/question2-calldata/contracts/utilities/FullMath.sol
   1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
   2 |     | pragma solidity ^0.8.28;
   3 |     | 
   4 |     | import {MulDivOverflow} from "./Errors.sol";
   5 |     | 
   6 |     | /// @title Contains 512-bit multiplication and division functions
   7 |     | /// Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv
   8 |     | /// for several functions in this library.
   9 |     | library FullMathLibrary {
  10 |     |   ///                           _____   _____   _____
  11 |     |   /// @notice 512-bit addition 'r1 r0 = a1 a0 + b1 b0'.
  12 |     |   /// Overflow should be avoided externally.
  13 |     |   /// @param a0 Least significant 256 bits of the first number.
  14 |     |   /// @param a1 Most significant 256 bits of the first number.
  15 |     |   /// @param b0 Least significant 256 bits of the second number.
  16 |     |   /// @param b1 Most significant 256 bits of the second number.
  17 |     |   /// @return r0 Least significant 256 bits of the addition.
  18 |     |   /// @return r1 Most significant 256 bits of the addition.
  19 |     |   function add512(
  20 |     |     uint256 a0,
  21 |     |     uint256 a1,
  22 |     |     uint256 b0,
  23 |     |     uint256 b1
  24 |     |   ) internal pure returns (
  25 |     |     uint256 r0,
  26 |     |     uint256 r1
  27 |     |   ) {
  28 |     |     //      s0
  29 |     |     //      a1 a0
  30 |     |     // +    b1 b0
  31 |     |     // -----------
  32 |     |     //      r1 r0
  33 |     |     //
  34 |     |     // where 's0 := lt(r0, a0)'.
  35 |     |     assembly {
  36 |     |       r0 := add(a0, b0)
  37 |     |       r1 := add(
  38 |     |         add(a1, b1),
  39 |     |         // 'r0 < a0' indicates that the addition 'a0 + b0' has overflowed. In
  40 |     |         // this case '1' needs to be added to the most significant 256 bits of
  41 |     |         // the output.
  42 |     |         lt(r0, a0)
  43 |     |       )
  44 |     |     }
  45 |     |   }
  46 |     | 
  47 |     |   ///                              _____   _____   _____
  48 |     |   /// @notice 512-bit subtraction 'r1 r0 = a1 a0 - b1 b0'.
  49 |     |   /// Underflow should be avoided externally.
  50 |     |   /// @param a0 Least significant 256 bits of the minuend.
  51 |     |   /// @param a1 Most significant 256 bits of the minuend.
  52 |     |   /// @param b0 Least significant 256 bits of the subtrahend.
  53 |     |   /// @param b1 Most significant 256 bits of the subtrahend.
  54 |     |   /// @return r0 Least significant 256 bits of the subtraction.
  55 |     |   /// @return r1 Most significant 256 bits of the subtraction.
  56 |     |   function sub512(
  57 |     |     uint256 a0,
  58 |     |     uint256 a1,
  59 |     |     uint256 b0,
  60 |     |     uint256 b1
  61 |     |   ) internal pure returns (
  62 |     |     uint256 r0,
  63 |     |     uint256 r1
  64 |     |   ) {
  65 |     |     //      a1 a0
  66 |     |     // -    b1 b0
  67 |     |     // -----------
  68 |     |     //      s1 r0
  69 |     |     // -    s0
  70 |     |     // -----------
  71 |     |     //      r1 r0
  72 |     |     //
  73 |     |     // where 's0 := lt(a0, b0)' and 's1 := (a1 - b1) % (2 ** 256)'.
  74 |     |     assembly {
  75 |     |       r0 := sub(a0, b0)
  76 |     |       r1 := sub(
  77 |     |         sub(a1, b1),
  78 |     |         // 'a0 < b0' indicates that the subtraction 'a0 - b0' has underflowed.
  79 |     |         // In this case '1' needs to be subtracted from the most significant
  80 |     |         // 256 bits of the output.
  81 |     |         lt(a0, b0)
  82 |     |       )
  83 |     |     }
  84 |     |   }
  85 |     | 
  86 |     |   ///                           ___________
  87 |     |   /// @notice 512-bit multiply 'prod1 prod0 = a * b'.
  88 |     |   /// @param a The multiplicand.
  89 |     |   /// @param b The multiplier.
  90 |     |   /// @return prod0 Least significant 256 bits of the product.
  91 |     |   /// @return prod1 Most significant 256 bits of the product.
  92 |     |   function mul512(
  93 |     |     uint256 a,
  94 |     |     uint256 b
  95 |     |   ) internal pure returns (
  96 |     |     uint256 prod0, 
  97 |     |     uint256 prod1
  98 |     |   ) {
  99 |     |     assembly {
 100 |     |       // 'mm := a * b - (2 ** 256 - 1) * q'
 101 |     |       let mm := mulmod(a, b, not(0))
 102 |     | 
 103 |     |       // 'prod0 := a * b - (2 ** 256) * p'
 104 |     |       prod0 := mul(a, b)
 105 |     | 
 106 |     |       prod1 := sub(
 107 |     |         // 'mm - prod0 == q'.
 108 |     |         sub(mm, prod0),
 109 |     |         //               a * b                 a * b
 110 |     |         // p == floor(----------) <= floor(--------------) == q
 111 |     |         //             2 ** 256             2 ** 256 - 1
 112 |     |         //
 113 |     |         // On the other hand, since
 114 |     |         //
 115 |     |         //      a * b          a * b                  a * b
 116 |     |         // -------------- - ---------- == ----------------------------- < 1
 117 |     |         //  2 ** 256 - 1     2 ** 256      (2 ** 256) * (2 ** 256 - 1)
 118 |     |         //
 119 |     |         // we have 'q - p <= 1'.
 120 |     |         //
 121 |     |         // Hence, either 'p == q' or 'p == q - 1'.
 122 |     |         //
 123 |     |         // If 'p == q', then 'mm - prod0 == q >= 0'.
 124 |     |         // If 'p == q - 1', then 'prod0 - mm == (2 ** 256) - q > 0'.
 125 |     |         //
 126 |     |         // Since 'p == q' and 'p == q - 1' are mutually exclusive, we can argue
 127 |     |         // that:
 128 |     |         //
 129 |     |         // 'p == q' if and only if 'mm >= prod0'.
 130 |     |         // 'p == q - 1' if and only if 'mm < prod0'.
 131 |     |         //
 132 |     |         // Hence, in the latter case, we should subtract by '1'.
 133 |     |         lt(mm, prod0)
 134 |     |       )
 135 |     |     }
 136 |     |   }
 137 |     | 
 138 |     |   /// @notice Calculates (a * b) / denominator when 
 139 |     |   /// 'a * b < denominator * (denominator - 1)'.
 140 |     |   /// @param a The multiplicand.
 141 |     |   /// @param b The multiplier.
 142 |     |   /// @param denominator The divisor.
 143 |     |   /// @return result '(a * b) / denominator'.
 144 |     |   function cheapMulDiv(
 145 |     |     uint256 a,
 146 |     |     uint256 b,
 147 |     |     uint256 denominator
 148 |     |   ) internal pure returns (
 149 |     |     uint256 result
 150 |     |   ) {
 151 |     |     assembly {
 152 |     |       result := sub(denominator, 1)
 153 |     | 
 154 |     |       // 's := a * b - q * (denominator - 1)'
 155 |     |       // 'r := a * b - p * denominator'
 156 |     |       // 's - r == p * denominator == p' [mod (denominator - 1)]
 157 |     |       result := addmod(
 158 |     |         mulmod(a, b, result),
 159 |     |         // This subtraction is safe because 
 160 |     |         // '(a * b) % denominator <= denominator - 1'.
 161 |     |         sub(result, mulmod(a, b, denominator)),
 162 |     |         result
 163 |     |       )
 164 |     |       // Notice that 'result <= denominator - 1' and because of the input
 165 |     |       // requirement, we have 'p = (a * b) / denominator <= denominator - 1'.
 166 |     |       // Hence, 'result == s - r == p'.
 167 |     |     }
 168 |     |   }
 169 |     | 
 170 |     |   /// @notice Calculates the modular inverse of an odd number modulo '2 ** 256'
 171 |     |   /// Input should be odd.
 172 |     |   /// @param value The number whose modular inverse to be calculated.
 173 |     |   /// @return inverse A 256-bit inverse satisfying
 174 |     |   /// 'value * inverse == 1' [mod 2 ** 256].
 175 |     |   function modularInverse(
 176 |     |     uint256 value
 177 |     |   ) internal pure returns (
 178 |     |     uint256 inverse
 179 |     |   ) {
 180 |     |     unchecked {
 181 |     |       // Compute the inverse by starting with a seed that is correct for four
 182 |     |       // bits. That is, 'value * inverse = 1' [mod 2 ** 4].
 183 |     |       inverse = 3 * value ^ 2;
 184 |     |       // Now use Newton-Raphson iterations to improve the precision. Thanks to
 185 |     |       // Hensel's lifting lemma, this also works in modular arithmetic,
 186 |     |       // doubling the correct bits in each step.
 187 |     |       inverse *= 2 - value * inverse;
 188 |     |       inverse *= 2 - value * inverse;
 189 |     |       inverse *= 2 - value * inverse;
 190 |     |       inverse *= 2 - value * inverse;
 191 |     |       inverse *= 2 - value * inverse;
 192 |     |       inverse *= 2 - value * inverse;
 193 |     |     }
 194 |     |   }
 195 |     | 
 196 |     |   ///                          ________
 197 |     |   /// @notice 768-bit multiply q2 q1 q0 = a * b * c
 198 |     |   /// @param a The multiplicand.
 199 |     |   /// @param b The first multiplier.
 200 |     |   /// @param c The second multiplier.
 201 |     |   /// @return q0 Least significant 256 bits of the product.
 202 |     |   /// @return q1 Middle 256 bits of the product.
 203 |     |   /// @return q2 Most significant 256 bits of the product.
 204 |     |   function mul768(
 205 |     |     uint256 a,
 206 |     |     uint256 b,
 207 |     |     uint256 c
 208 |     |   ) internal pure returns (
 209 |     |     uint256 q0,
 210 |     |     uint256 q1,
 211 |     |     uint256 q2
 212 |     |   ) {
 213 |     |     //          a
 214 |     |     // x        b
 215 |     |     // -----------
 216 |     |     //      q1 q0
 217 |     |     // x        c
 218 |     |     // -----------
 219 |     |     //   ss 
 220 |     |     //      mm q0
 221 |     |     // + q2 q1  0
 222 |     |     // -----------
 223 |     |     //   q2 q1 q0
 224 |     |     //
 225 |     |     uint256 mm;
 226 |     |     (q0, q1) = mul512(a, b);
 227 |     |     (q1, q2) = mul512(q1, c);
 228 |     |     (q0, mm) = mul512(q0, c);
 229 |     |     assembly {
 230 |     |       q1 := add(q1, mm)
 231 |     |       // 'q1 < mm' indicates that the above addition has overflowed (i.e.,
 232 |     |       // 'ss == 1') and hence, '1' needs to be added to the most significant
 233 |     |       // 256 bits of the product.
 234 |     |       q2 := add(q2, lt(q1, mm))
 235 |     |     }
 236 |     |   }
 237 |     | 
 238 |     |   /// @notice Calculates 
 239 |     |   ///
 240 |     |   ///         a * b * c
 241 |     |   /// 'min(----------------, 2 ** 216 - 1)'
 242 |     |   ///       d * (2 ** 143)
 243 |     |   ///
 244 |     |   /// with full precision when 'a * b * c != 0'.
 245 |     |   /// @param a The multiplicand.
 246 |     |   /// @param b The first multiplier.
 247 |     |   /// @param c The second multiplier.
 248 |     |   /// @param d The denominator.
 249 |     |   /// @param roundUp Whether to round up the result.
 250 |     |   /// @return result The output value '(a * b * c) / (d * (2 ** 143))' which is
 251 |     |   /// capped by '2 ** 216 - 1'.
 252 |     |   function mulDiv(
 253 |     |     uint256 a,
 254 |     |     uint256 b,
 255 |     |     uint256 c,
 256 |     |     uint256 d,
 257 |     |     bool roundUp
 258 |     |   ) internal pure returns (
 259 |     |     uint256 result
 260 |     |   ) {
 261 |     |     unchecked {
 262 |     |       // ________
 263 |     |       // q2 q1 q0 = a * b * c
 264 |     |       (uint256 q0, uint256 q1, uint256 q2) = mul768(a, b, c);
 265 |     | 
 266 |     |       // If 'q2 >= (1 << 103)', then the output is greater than or equal to
 267 |     |       //
 268 |     |       //  (2 ** 103) * (2 ** 256) * (2 ** 256)
 269 |     |       // -------------------------------------- == 2 ** 216
 270 |     |       //        (2 ** 256) * (2 ** 143)
 271 |     |       //
 272 |     |       // In this case, '2 ** 216 - 1' should be returned.
 273 |     |       if (q2 >= (1 << 103)) return ((1 << 216) - 1);
 274 |     | 
 275 |     |       // Divide the numerator by '2 ** 143'
 276 |     |       (q2, q1) = (
 277 |     |         (q2 << 113) | (q1 >> 143),
 278 |     |         (q1 << 113) | (q0 >> 143)
 279 |     |       );
 280 |     | 
 281 |     |       // Calculating the remainder of the numerator modulo 'd'.
 282 |     |       uint256 r;
 283 |     |       assembly {
 284 |     |         r := addmod(
 285 |     |           addmod(q1, q2, d), // (q1 + q2) % d
 286 |     |           mulmod(q2, not(0), d), // (q2 * (2 ** 256 - 1)) % d
 287 |     |           d
 288 |     |         ) // (q1 + q2 * (2 ** 256)) % d
 289 |     |       }
 290 |     |       
 291 |     |       //                         _____
 292 |     |       // 'r' is subtracted from 'q2 q1'.
 293 |     |       assembly {
 294 |     |         // 'q1 < r' indicates that the subtraction 'q1 - r' underflows.
 295 |     |         // In this case '1' needs to be subtracted from q2.
 296 |     |         q2 := sub(q2, lt(q1, r))
 297 |     |         q1 := sub(q1, r)
 298 |     |       }
 299 |     | 
 300 |     |       // Determines whether to return '2 ** 216 - 1'.
 301 |     |       //                _____
 302 |     |       // Check whether 'q2 q1 >= (2 ** 256) * d'.
 303 |     |       if (q2 >= d) return ((1 << 216) - 1);
 304 |     | 
 305 |     |       // 'd' is factored into an odd part and a power of two. 
 306 |     |       // Then, the numerator is divided by the power of two.
 307 |     |       {
 308 |     |         // This is the largest power of two that 'd' is divisible by.
 309 |     |         uint256 twos = (0 - d) & d;
 310 |     |         assembly {
 311 |     |           // Dividing 'd' by 'twos'.
 312 |     |           d := div(d, twos)
 313 |     | 
 314 |     |           //           _____
 315 |     |           // Dividing 'q2 q1' by 'twos' and storing the least significant '256'
 316 |     |           // bits in 'q1'.
 317 |     |           q1 := or(
 318 |     |             div(q1, twos), // 'q1 / (2 ** k)'
 319 |     |             mul(
 320 |     |               q2,
 321 |     |               add(
 322 |     |                 div(
 323 |     |                   sub(0, twos), // '2 ** 256 - 2 ** k'
 324 |     |                   twos // '2 ** k'
 325 |     |                 ), // '2 ** (256 - k) - 1'
 326 |     |                 1
 327 |     |               ) // '(2 ** (256 - k)) % (2 ** 256)'
 328 |     |             ) // '(q2 * (2 ** (256 - k))) % (2 ** 256)'
 329 |     |           ) // '(q2 * (2 ** (256 - k)) + q1 / (2 ** k)) % (2 ** 256)'
 330 |     |         }
 331 |     |       }
 332 |     | 
 333 |     |       // The result can now be calculated precisely using modular inverse.
 334 |     |       // Let 'di := modularInverse(d)'.
 335 |     |       //
 336 |     |       //  _____
 337 |     |       // 'q2 q1 == d * result'
 338 |     |       // '(2 ** 256) * q2 + q1 == d * result'
 339 |     |       // 'di * (2 ** 256) * q2 + di * q1 == di * d * result'
 340 |     |       // 'di * (2 ** 256) * q2 + di * q1 == ((2 ** 256) * k + 1) * result'
 341 |     |       // 'di * q1 == result' [mod 2 ** 256]
 342 |     |       result = modularInverse(d) * q1;
 343 |     | 
 344 |     |       // If either of the remainders are positive, then the result should be
 345 |     |       // rounded up.
 346 |     |       if (roundUp) {
 347 |     |         if ((q0 & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) > 0 || r > 0) {
 348 |     |           ++result;
 349 |     |         }
 350 |     |       }
 351 |     | 
 352 |     |       // Determines whether to return '2 ** 216 - 1'.
 353 |     |       if (result >= (1 << 216)) return ((1 << 216) - 1);
 354 |     |     }
 355 |     |   }
 356 |     | 
 357 |     |   /// @notice Calculates
 358 |     |   ///
 359 |     |   ///      a * b * c
 360 |     |   /// '----------------'
 361 |     |   ///   d * (2 ** 111)
 362 |     |   ///
 363 |     |   /// with full precision. Overflows if the result exceeds 'type(int256).max'.
 364 |     |   /// 'e' must be the modular inverse of 'd / (2 ** k)' where 'k' is the
 365 |     |   /// largest power of two within 'd'.
 366 |     |   /// We should have 'a * b * c != 0' and 'd != 0'.
 367 |     |   /// @param a The multiplicand.
 368 |     |   /// @param b The first multiplier.
 369 |     |   /// @param c The second multiplier.
 370 |     |   /// @param d The denominator.
 371 |     |   /// @param e Modular inverse of the odd part of the denominator.
 372 |     |   /// @param roundUp Whether to round up the result.
 373 |     |   /// @return result The output value '(a * b * c) / (d * (2 ** 111))' if there
 374 |     |   /// is no overflow.
 375 |     |   /// @return overflow Whether the result overflows.
 376 |     |   function mulDiv(
 377 |     |     uint256 a,
 378 |     |     uint256 b,
 379 |     |     uint256 c,
 380 |     |     uint256 d,
 381 |     |     uint256 e,
 382 |     |     bool roundUp
 383 |     |   ) internal pure returns (
 384 |     |     uint256 result,
 385 |     |     bool overflow
 386 |     |   ) {
 387 |     |     unchecked {
 388 |     |       // ________
 389 |     |       // q2 q1 q0 = a * b * c
 390 |     |       (uint256 q0, uint256 q1, uint256 q2) = mul768(a, b, c);
 391 |     | 
 392 |     |       // If 'q2 >= (1 << 111)', then the output is greater than or equal to
 393 |     |       //
 394 |     |       //  (2 ** 111) * (2 ** 256) * (2 ** 256)
 395 |     |       // -------------------------------------- == 2 ** 256
 396 |     |       //        (2 ** 256) * (2 ** 111)
 397 |     |       //
 398 |     |       // In this case, we return overflow.
 399 |     |       if (q2 >= (1 << 111)) return (0, true);
 400 |     | 
 401 |     |       // Divide the numerator by '2 ** 111'
 402 |     |       (q2, q1) = (
 403 |     |         (q2 << 145) | (q1 >> 111),
 404 |     |         (q1 << 145) | (q0 >> 111)
 405 |     |       );
 406 |     | 
 407 |     |       // Calculating the remainder of the numerator modulo 'd'.
 408 |     |       uint256 r;
 409 |     |       assembly {
 410 |     |         r := addmod(
 411 |     |           addmod(q1, q2, d), // (q1 + q2) % d
 412 |     |           mulmod(q2, not(0), d), // (q2 * (2 ** 256 - 1)) % d
 413 |     |           d
 414 |     |         ) // (q1 + q2 * (2 ** 256)) % d
 415 |     |       }
 416 |     | 
 417 |     |       //                         _____
 418 |     |       // 'r' is subtracted from 'q2 q1'.
 419 |     |       assembly {
 420 |     |         // 'q1 < r' indicates that the subtraction 'q1 - r' underflowes.
 421 |     |         // In this case '1' needs to be subtracted from q2.
 422 |     |         q2 := sub(q2, lt(q1, r))
 423 |     |         q1 := sub(q1, r)
 424 |     |       }
 425 |     | 
 426 |     |       // Determines whether to return overflow.
 427 |     |       // The following equality is satisfied if and only if
 428 |     |       //
 429 |     |       //      a * b * c
 430 |     |       // '---------------- >= (2 ** 256)'
 431 |     |       //   d * (2 ** 111)
 432 |     |       //
 433 |     |       if (q2 >= d) return (0, true);
 434 |     | 
 435 |     |       // 'd' is factored into an odd part and a power of two and the numerator
 436 |     |       // is divided by the power of two.
 437 |     |       d = (0 - d) & d;
 438 |     |       assembly {
 439 |     |         q1 := or(
 440 |     |           div(q1, d), // q1 / (2 ** k)
 441 |     |           mul(
 442 |     |             q2,
 443 |     |             add(
 444 |     |               div(
 445 |     |                 sub(0, d), // '2 ** 256 - 2 ** k'
 446 |     |                 d // '2 ** k'
 447 |     |               ), // '2 ** (256 - k) - 1'
 448 |     |               1
 449 |     |             ) // '(2 ** (256 - k)) % (2 ** 256)'
 450 |     |           ) // '(q2 * (2 ** (256 - k))) % (2 ** 256)'
 451 |     |         ) // '(q2 * (2 ** (256 - k)) + q1 / (2 ** k)) % (2 ** 256)'
 452 |     |       }
 453 |     | 
 454 |     |       // The result can now be calculated precisely using 'e'.
 455 |     |       //  _____
 456 |     |       // 'q2 q1 == d * result'
 457 |     |       // '(2 ** 256) * q2 + q1 == d * result'
 458 |     |       // 'e * (2 ** 256) * q2 + e * q1 == e * d * result'
 459 |     |       // 'e * (2 ** 256) * q2 + e * q1 == ((2 ** 256) * k + 1) * result'
 460 |     |       // 'e * q1 == result' [mod 2 ** 256]
 461 |     |       result = e * q1;
 462 |     | 
 463 |     |       // If either of the remainders are positive, then the result should be
 464 |     |       // rounded up.
 465 |     |       if (roundUp) {
 466 |     |         if ((q0 & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFF) > 0 || r > 0) {
 467 |     |           ++result;
 468 |     |         }
 469 |     |       }
 470 |     | 
 471 |     |       // Determines whether to overflow.
 472 |     |       if (result >= (1 << 255)) return (0, true);
 473 |     |     }
 474 |     |   }
 475 |     | 
 476 |     |   /// @notice Calculates floor((a * b) / denominator) with full precision.
 477 |     |   /// Overflow should be avoided externally.
 478 |     |   /// @param a The multiplicand
 479 |     |   /// @param b The multiplier
 480 |     |   /// @param denominator The divisor
 481 |     |   /// @return result The 256-bit result
 482 |     |   function mulDiv(
 483 |     |     uint256 a,
 484 |     |     uint256 b,
 485 |     |     uint256 denominator
 486 |     |   ) internal pure returns (
 487 |     |     uint256 result
 488 |     |   ) {
 489 |     |     unchecked {
 490 |     |       //                   ___________
 491 |     |       // 512-bit multiply 'prod1 prod0 = a * b'
 492 |     |       // Compute the product mod 2**256 and mod 2 ** 256 - 1
 493 |     |       // then use the Chinese Remainder Theorem to reconstruct
 494 |     |       // the 512 bit result. The result is stored in two 256
 495 |     |       // variables such that product = prod1 * (2 ** 256) + prod0
 496 |     |       (uint256 prod0, uint256 prod1) = mul512(a, b);
 497 |     | 
 498 |     |       // Short circuit 256 by 256 division
 499 |     |       // This saves gas when a * b is small, at the cost of making the
 500 |     |       // large case a bit more expensive. Depending on your use case you
 501 |     |       // may want to remove this short circuit and always go through the
 502 |     |       // 512 bit path.
 503 |     |       if (prod1 == 0) {
 504 |     |         assembly {
 505 |     |           result := div(prod0, denominator)
 506 |     |         }
 507 |     |         return result;
 508 |     |       }
 509 |     |       
 510 |     |       ///////////////////////////////////////////////
 511 |     |       // 512 by 256 division.
 512 |     |       ///////////////////////////////////////////////
 513 |     | 
 514 |     |       //                                                        ___________
 515 |     |       // Make division exact by subtracting the remainder from 'prod1 prod0'
 516 |     |       // Compute remainder using mulmod
 517 |     |       // Note mulmod(_, _, 0) == 0
 518 |     |       uint256 remainder;
 519 |     |       assembly {
 520 |     |         remainder := mulmod(a, b, denominator)
 521 |     |       }
 522 |     | 
 523 |     |       // Subtract 256 bit number from 512 bit number
 524 |     |       assembly {
 525 |     |         prod1 := sub(prod1, gt(remainder, prod0))
 526 |     |         prod0 := sub(prod0, remainder)
 527 |     |       }
 528 |     |       
 529 |     |       // Factor powers of two out of denominator
 530 |     |       // Compute largest power of two-divisor of denominator.
 531 |     |       // Always >= 1 unless the denominator is zero, then twos is zero.
 532 |     |       uint256 twos = (0 - denominator) & denominator;
 533 |     |       // Divide denominator by power of two
 534 |     |       assembly {
 535 |     |         denominator := div(denominator, twos)
 536 |     |       }
 537 |     |       
 538 |     |       //         ___________
 539 |     |       // Divide 'prod1 prod0' by the factors of two
 540 |     |       assembly {
 541 |     |         prod0 := div(prod0, twos)
 542 |     |       }
 543 |     |       // Shift in bits from prod1 into prod0. For this we need
 544 |     |       // to flip `twos` such that it is 2**256 / twos.
 545 |     |       // If twos is zero, then it becomes one
 546 |     |       assembly {
 547 |     |         twos := add(div(sub(0, twos), twos), 1)
 548 |     |       }
 549 |     |       prod0 |= prod1 * twos;
 550 |     |       
 551 |     |       // Invert denominator mod 2**256
 552 |     |       // Now that denominator is an odd number, it has an inverse
 553 |     |       // modulo 2**256 such that denominator * inv = 1 mod 2**256.
 554 |     |       // Compute the inverse by starting with a seed that is correct
 555 |     |       // correct for four bits. That is, denominator * inv = 1 mod 2**4
 556 |     |       // If denominator is zero the inverse starts with 2
 557 |     |       // Now use Newton-Raphson iteration to improve the precision.
 558 |     |       // Thanks to Hensel's lifting lemma, this also works in modular
 559 |     |       // arithmetic, doubling the correct bits in each step.
 560 |     |       uint256 inv = modularInverse(denominator);
 561 |     |       // If denominator is zero, inv is now 128
 562 |     |       
 563 |     |       // Because the division is now exact we can divide by multiplying
 564 |     |       // with the modular inverse of the denominator. This will give us the
 565 |     |       // correct result modulo 2**256. Since the preconditions guarantee
 566 |     |       // that the outcome is less than 2**256, this is the final result.
 567 |     |       // We don't need to compute the high bits of the result and prod1
 568 |     |       // is no longer required.
 569 |     |       result = prod0 * inv;
 570 |     |       return result;
 571 |     |     }
 572 |     |   }
 573 |     | 
 574 |     |   /// @notice Calculates ceiling((a * b) / denominator) with full precision.
 575 |     |   /// Overflow should be avoided externally.
 576 |     |   /// @param a The multiplicand
 577 |     |   /// @param b The multiplier
 578 |     |   /// @param denominator The divisor
 579 |     |   /// @return result The 256-bit result
 580 |     |   function mulDivRoundUp(
 581 |     |     uint256 a,
 582 |     |     uint256 b,
 583 |     |     uint256 denominator
 584 |     |   ) internal pure returns (uint256 result) {
 585 |     |     result = mulDiv(a, b, denominator);
 586 |     |     // The result is incremented if 'a * b' is not divisible by 'denominator'.
 587 |     |     assembly {
 588 |     |       result := add(result, gt(mulmod(a, b, denominator), 0))
 589 |     |     }
 590 |     |   }
 591 |     | 
 592 |     |   /// @notice Calculates floor((a * b) / denominator) with full precision.
 593 |     |   /// Throws in case of overflow.
 594 |     |   /// @param a The multiplicand
 595 |     |   /// @param b The multiplier
 596 |     |   /// @param denominator The divisor
 597 |     |   /// @return result The 256-bit result
 598 |     |   function safeMulDiv(
 599 |     |     uint256 a,
 600 |     |     uint256 b,
 601 |     |     uint256 denominator
 602 |     |   ) internal pure returns (uint256 result) {
 603 |     |     (, uint256 prod1) = mul512(a, b);
 604 |     |     require(prod1 < denominator, MulDivOverflow(a, b, denominator));
 605 |     |     result = mulDiv(a, b, denominator);
 606 |     |   }
 607 |     | 
 608 |     |   /// @notice Calculates ceiling((a * b) / denominator) with full precision.
 609 |     |   /// Throws in case of overflow.
 610 |     |   /// @param a The multiplicand
 611 |     |   /// @param b The multiplier
 612 |     |   /// @param denominator The divisor
 613 |     |   /// @return result The 256-bit result
 614 |     |   function safeMulDivRoundUp(
 615 |     |     uint256 a,
 616 |     |     uint256 b,
 617 |     |     uint256 denominator
 618 |     |   ) internal pure returns (uint256 result) {
 619 |     |     // The result is incremented if 'a * b' is not divisible by 'denominator'.
 620 |     |     assembly {
 621 |     |       result := gt(mulmod(a, b, denominator), 0)
 622 |     |     }
 623 |     |     result += safeMulDiv(a, b, denominator);
 624 |     |   }
 625 |     | }

R:/LIAT.AI/question2-calldata/contracts/utilities/Index.sol
   1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
   2 |     | pragma solidity ^0.8.28;
   3 |     | 
   4 |     | // Type index is used to enumerate members of the curve and kernel.
   5 |     | type Index is uint256;
   6 |     | 
   7 |     | Index constant zeroIndex = Index.wrap(0);
   8 |     | Index constant oneIndex = Index.wrap(1);
   9 |     | Index constant twoIndex = Index.wrap(2);
  10 |     | Index constant threeIndex = Index.wrap(3);
  11 |     | Index constant maxCurveIndex = Index.wrap(type(uint16).max);
  12 |     | Index constant maxKernelIndex = Index.wrap(1020);
  13 |     | 
  14 |     | using {equals as ==, notEquals as !=} for Index global;
  15 |     | using {lessThan as <, greaterThan as >} for Index global;
  16 |     | using {lessThanOrEqualTo as <=, greaterThanOrEqualTo as >=} for Index global;
  17 |     | using {add as +, sub as -} for Index global;
  18 |     | 
  19 |     | function equals(
  20 |     |   Index value0,
  21 |     |   Index value1
  22 |     | ) pure returns (
  23 |     |   bool result
  24 |     | ) {
  25 |     |   assembly {
  26 |     |     result := eq(value0, value1)
  27 |     |   }
  28 |     | }
  29 |     | 
  30 |     | function notEquals(
  31 |     |   Index value0,
  32 |     |   Index value1
  33 |     | ) pure returns (
  34 |     |   bool result
  35 |     | ) {
  36 |     |   return !(value0 == value1);
  37 |     | }
  38 |     | 
  39 |     | function lessThan(
  40 |     |   Index value0,
  41 |     |   Index value1
  42 |     | ) pure returns (
  43 |     |   bool result
  44 |     | ) {
  45 |     |   assembly {
  46 |     |     result := lt(value0, value1)
  47 |     |   }
  48 |     | }
  49 |     | 
  50 |     | function greaterThan(
  51 |     |   Index value0,
  52 |     |   Index value1
  53 |     | ) pure returns (
  54 |     |   bool result
  55 |     | ) {
  56 |     |   assembly {
  57 |     |     result := gt(value0, value1)
  58 |     |   }
  59 |     | }
  60 |     | 
  61 |     | function lessThanOrEqualTo(
  62 |     |   Index value0,
  63 |     |   Index value1
  64 |     | ) pure returns (
  65 |     |   bool result
  66 |     | ) {
  67 |     |   return !(value0 > value1);
  68 |     | }
  69 |     | 
  70 |     | function greaterThanOrEqualTo(
  71 |     |   Index value0,
  72 |     |   Index value1
  73 |     | ) pure returns (
  74 |     |   bool result
  75 |     | ) {
  76 |     |   return !(value0 < value1);
  77 |     | }
  78 |     | 
  79 |     | // Overflow should be avoided externally.
  80 |     | function add(
  81 |     |   Index value0,
  82 |     |   Index value1
  83 |     | ) pure returns (
  84 |     |   Index result
  85 |     | ) {
  86 |     |   assembly {
  87 |     |     result := add(value0, value1)
  88 |     |   }
  89 |     | }
  90 |     | 
  91 |     | // Underflow should be avoided externally.
  92 |     | function sub(
  93 |     |   Index value0,
  94 |     |   Index value1
  95 |     | ) pure returns (
  96 |     |   Index result
  97 |     | ) {
  98 |     |   assembly {
  99 |     |     result := sub(value0, value1)
 100 |     |   }
 101 |     | }
 102 |     | 
 103 |     | function min(
 104 |     |   Index value0,
 105 |     |   Index value1
 106 |     | ) pure returns (
 107 |     |   Index result
 108 |     | ) {
 109 |     |   return (value0 < value1) ? value0 : value1;
 110 |     | }
 111 |     | 
 112 |     | function max(
 113 |     |   Index value0,
 114 |     |   Index value1
 115 |     | ) pure returns (
 116 |     |   Index result
 117 |     | ) {
 118 |     |   return (value0 < value1) ? value1 : value0;
 119 |     | }
 120 |     | 
 121 |     | library IndexLibrary {
 122 |     |   /// @notice Returns the current 16-bit index of the curve or kernel under 
 123 |     |   /// exploration given the corresponding pointer.
 124 |     |   ///
 125 |     |   /// 'pointer' should be a constant value.
 126 |     |   function getIndex(
 127 |     |     uint256 pointer
 128 |     |   ) internal pure returns (
 129 |     |     Index value
 130 |     |   ) {
 131 |     |     assembly {
 132 |     |       // First, the memory slot whose most significant 16 bits host the index
 133 |     |       // is loaded and then the least significant 240 bits are discarded.
 134 |     |       value := shr(240, mload(pointer))
 135 |     |     }
 136 |     |   }
 137 |     | 
 138 |     |   /// @notice Increases a 16-bit index stored in memory by one, given a 
 139 |     |   /// pointer. The new value for the index is then returned.
 140 |     |   /// Overflow should be avoided externally.
 141 |     |   ///
 142 |     |   /// 'pointer' should be a constant value.
 143 |     |   function incrementIndex(
 144 |     |     uint256 pointer
 145 |     |   ) internal pure returns (
 146 |     |     Index value
 147 |     |   ) {
 148 |     |     assembly {
 149 |     |       // Index is the most significant 16 bit. Hence, to increment it we need
 150 |     |       // to add the slot by '2 ** 240'.
 151 |     |       value := add(mload(pointer), shl(240, 1))
 152 |     |       mstore(pointer, value)
 153 |     | 
 154 |     |       // Then, the least significant 240 bits are discarded and the resulting
 155 |     |       // value is returned.
 156 |     |       value := shr(240, value)
 157 |     |     }
 158 |     |   }
 159 |     | 
 160 |     |   /// @notice Decreases a 16-bit index stored in memory by one, given a 
 161 |     |   /// pointer. The new value for the index is then returned.
 162 |     |   /// Underflow should be avoided externally.
 163 |     |   ///
 164 |     |   /// 'pointer' should be a constant value.
 165 |     |   function decrementIndex(
 166 |     |     uint256 pointer
 167 |     |   ) internal pure returns (
 168 |     |     Index value
 169 |     |   ) {
 170 |     |     assembly {
 171 |     |       // Index is the most significant 16 bit. Hence, to decrement it we need
 172 |     |       // to subtract the slot by '2 ** 240'.
 173 |     |       value := sub(mload(pointer), shl(240, 1))
 174 |     |       mstore(pointer, value)
 175 |     | 
 176 |     |       // Then, the least significant 240 bits are discarded and the resulting
 177 |     |       // value is returned.
 178 |     |       value := shr(240, value)
 179 |     |     }
 180 |     |   }
 181 |     | }

R:/LIAT.AI/question2-calldata/contracts/utilities/Kernel.sol
   1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
   2 |     | pragma solidity ^0.8.28;
   3 |     | 
   4 |     | import {Index, zeroIndex} from "./Index.sol";
   5 |     | import {X15} from "./X15.sol";
   6 |     | import {X59} from "./X59.sol";
   7 |     | import {X216, oneX216} from "./X216.sol";
   8 |     | import {PriceLibrary} from "./Price.sol";
   9 |     | 
  10 |     | using PriceLibrary for uint16;
  11 |     | using PriceLibrary for uint256;
  12 |     | 
  13 |     | // For every pool, the kernel function 'k : [0, qSpacing] -> [0, 1]' represents
  14 |     | // a monotonically non-decreasing piece-wise linear function whose breakpoints
  15 |     | // are listed in the storage smart contract. Let 'm + 1' denote the number
  16 |     | // of these breakpoints. For every integer '0 <= i <= m' the i-th breakpoint of
  17 |     | // the kernel represents the pair '(b[i], c[i])' where
  18 |     | //
  19 |     | //  '0 == b[0] <  b[1] <= b[2] <= ... <= b[m - 1] <  b[m] == qSpacing',
  20 |     | //  '0 == c[0] <= c[1] <= c[2] <= ... <= c[m - 1] <= c[m] == 1'.
  21 |     | // 
  22 |     | // Each breakpoint occupies 64 bytes, in which:
  23 |     | //
  24 |     | //  - the 'X15' representation of '(2 ** 15) * c[i]' occupies 2 bytes,
  25 |     | //
  26 |     | //  - the 'X59' representation of '(2 ** 59) * b[i]' occupies 8 bytes,
  27 |     | //
  28 |     | //  - the 'X216' representation of '(2 ** 216) * exp(- b[i] / 2)' occupies 27
  29 |     | //    bytes,
  30 |     | //
  31 |     | //  - the 'X216' representation of '(2 ** 216) * exp(- 16 + b[i] / 2)' occupies
  32 |     | //    27 bytes.
  33 |     | //
  34 |     | // The above-mentioned layout is illustrated as follows:
  35 |     | //
  36 |     | //                      A 512 bit kernel breakpoint
  37 |     | //  +--+--------+---------------------------+---------------------------+
  38 |     | //  |  | 8 byte |          27 byte          |          27 byte          |
  39 |     | //  +--+--------+---------------------------+---------------------------+
  40 |     | //  |  |        |                           |
  41 |     | //  |  |        |                            \
  42 |     | //  |  |        |                             (2 ** 216) * exp(- 16 + b[i] / 2)
  43 |     | //  |  |         \
  44 |     | //  |  |          (2 ** 216) * exp(- b[i] / 2)
  45 |     | //  |   \
  46 |     | //  |    (2 ** 59) * b[i]
  47 |     | //   \
  48 |     | //    (2 ** 15) * c[i]
  49 |     | //
  50 |     | // Consider the following list of kernel breakpoints:
  51 |     | //
  52 |     | //  '(b[0], c[0]), (b[1], c[1]), (b[2], c[2]), ..., (b[m], c[m])'
  53 |     | //
  54 |     | // and for every integer '0 < i <= m', define
  55 |     | //
  56 |     | //  'k_i : [0, qSpacing] -> [0, 1]'
  57 |     | //
  58 |     | // as
  59 |     | //
  60 |     | //  'k_i(q) :=
  61 |     | //
  62 |     | //    /            c[i] - c[i - 1]
  63 |     | //   | c[i - 1] + ----------------- * (q - b[i - 1])  if  b[i - 1] < q < b[i]
  64 |     | //   |             b[i] - b[i - 1]                                           ',
  65 |     | //   | 0                                              otherwise
  66 |     | //    \
  67 |     | //
  68 |     | // which means that if 'b[i - 1] == b[i]', then 'k_i(q) := 0'. Now, the kernel
  69 |     | // function
  70 |     | // 
  71 |     | //  'k : [0, qSpacing] -> [0, 1]'
  72 |     | //
  73 |     | // is defined as
  74 |     | //
  75 |     | //             m
  76 |     | //           -----
  77 |     | //           \
  78 |     | //  'k(q) := /     k_i(q)'.
  79 |     | //           -----
  80 |     | //           i = 1
  81 |     | //
  82 |     | type Kernel is uint256;
  83 |     | 
  84 |     | using KernelLibrary for Kernel global;
  85 |     | 
  86 |     | library KernelLibrary {
  87 |     |   /// @notice Returns the components of the kernel breakpoint which corresponds
  88 |     |   /// to the given index.
  89 |     |   ///
  90 |     |   /// Index out of range should be avoided externally.
  91 |     |   function member(
  92 |     |     Kernel kernel,
  93 |     |     Index index
  94 |     |   ) internal pure returns (
  95 |     |     X15 height,
  96 |     |     X59 logShift,
  97 |     |     X216 sqrtShift,
  98 |     |     X216 sqrtInverseShift
  99 |     |   ) {
 100 |     |     // If 'index' is equal to 0, then this function should return 
 101 |     |     // '(zeroX15, zeroX59, oneX216, floor((2 ** 216) * exp(-16)))'. Because the
 102 |     |     // first member of kernelCompact is always '(zeroX15, zeroX59)'.
 103 |     |     if (index > zeroIndex) {
 104 |     |       uint256 pointer;
 105 |     |       assembly {
 106 |     |         // Each member of Kernel is '64 == 2 ** 6' bytes. Hence we shift
 107 |     |         // 'index' by '6' digits which is equivalent to multiplying by '64'.
 108 |     |         // The origin is omitted and handled separately. We subtract by
 109 |     |         // '62 = 8 + 27 + 27' so that the pointer corresponding to 
 110 |     |         // 'index == oneIndex' follows this layout:
 111 |     |         //
 112 |     |         //        pointer
 113 |     |         //      /
 114 |     |         //     |        A 512 bit kernel breakpoint
 115 |     |         //  +--+--------+-----------------+-----------------+
 116 |     |         //  |  | 8 byte |     27 byte     |     27 byte     |
 117 |     |         //  +--+--------+-----------------+-----------------+
 118 |     |         //  |  |        |                 |
 119 |     |         //  |  |        |                  \
 120 |     |         //  |  |        |                   (2 ** 216) * exp(- 16 + b[i] / 2)
 121 |     |         //  |  |         \
 122 |     |         //  |  |          (2 ** 216) * exp(- b[i] / 2)
 123 |     |         //  |   \
 124 |     |         //  |    (2 ** 59) * b[i]
 125 |     |         //   \
 126 |     |         //    (2 ** 15) * c[i]
 127 |     |         //
 128 |     |         pointer := add(kernel, sub(shl(6, index), 62))
 129 |     |       }
 130 |     |       // Now that 'pointer' points to a price with height according to the
 131 |     |       // above layout, all four values are loaded from memory using
 132 |     |       // 'PriceLibrary'.
 133 |     |       height = pointer.height();
 134 |     |       logShift = pointer.log();
 135 |     |       sqrtShift = pointer.sqrt(false);
 136 |     |       sqrtInverseShift = pointer.sqrt(true);
 137 |     |     } else {
 138 |     |       // 'height' and 'logShift' are zero by default.
 139 |     |       sqrtShift = oneX216;
 140 |     |       sqrtInverseShift = X216.wrap(
 141 |     |         0x0000000000000001E355BBAEE85CADA65F73F32E88FB3CC629B709109F57564D
 142 |     |       ); // floor((2 ** 216) * exp(-16))
 143 |     |     }
 144 |     |   }
 145 |     | 
 146 |     |   /// @notice This function calculates the resultant of the logarithmic price
 147 |     |   /// 'q' which is stored in 'basePrice' and the 'index' breakpoint of
 148 |     |   /// 'kernel'. The resultant is then stored in memory.
 149 |     |   ///
 150 |     |   /// If 'left == false', the resulting log price is equal to 
 151 |     |   ///
 152 |     |   ///  'qResultant := q + b[index]'.
 153 |     |   ///
 154 |     |   /// In this case we should have: '0 < q + b[index] < 2 ** 64'.
 155 |     |   ///
 156 |     |   /// If 'left == true', the resulting log price is equal to 
 157 |     |   ///
 158 |     |   ///  'qResultant := q - b[index]'.
 159 |     |   ///
 160 |     |   /// In this case we should have: '0 < q - b[index] < 2 ** 64'.
 161 |     |   ///
 162 |     |   /// Index out of range should be avoided externally.
 163 |     |   /// 'resultant' should not be less than '34'.
 164 |     |   function impose(
 165 |     |     Kernel kernel,
 166 |     |     uint256 resultant,
 167 |     |     uint256 basePrice,
 168 |     |     Index index,
 169 |     |     bool left
 170 |     |   ) internal pure {
 171 |     |     // These four values correspond to the kernel's member.
 172 |     |     (X15 height, X59 logShift, X216 sqrtShift, X216 sqrtInverseShift) = 
 173 |     |       kernel.member(index);
 174 |     |     
 175 |     |     // Addition or subtraction is safe due to the above requirements.
 176 |     |     // The multiplication does not overflow because both values are loaded from
 177 |     |     // 216 bits of memory. Hence, they are non-negative and are less than
 178 |     |     // oneX216.
 179 |     |     // The requirements of 'mulDivByExpInv16' are met because both values are 
 180 |     |     // loaded from 216 bits of memory. Hence, they are non-negative and are 
 181 |     |     // less than oneX216. Additionally, 'mulDivByExpInv16' does not overflow
 182 |     |     // and fits within 216 bits, because if 'left == false':
 183 |     |     //
 184 |     |     // '(basePrice.sqrt(true) ^ sqrtInverseShift) / (2 ** 216) == 
 185 |     |     //  exp(- 16 - 16 + (basePrice.log() + logShift) / (2 ** 60)) / exp(-16)
 186 |     |     //  == exp(- 16 + (basePrice.log() + logShift) / (2 ** 60)) <
 187 |     |     //  == exp(- 16 + (2 ** 64) / (2 ** 60)) <= 1'
 188 |     |     //
 189 |     |     // and if 'left == true':
 190 |     |     //
 191 |     |     // '(basePrice.sqrt(false) ^ sqrtInverseShift) / (2 ** 216) == 
 192 |     |     //  exp(-16 - (basePrice.log() - logShift) / (2 ** 60)) / exp(-16) == 
 193 |     |     //  exp(- (basePrice.log() - logShift) / (2 ** 60)) < exp(0) <= 1'
 194 |     |     //
 195 |     |     // Hence, the outcome of the multiplication and 'mulDivByExpInv16' do not
 196 |     |     // exceed 216 bits.
 197 |     |     (X59 logPrice, X216 sqrtPrice, X216 sqrtInversePrice) = left ? (
 198 |     |       basePrice.log() - logShift,
 199 |     |       basePrice.sqrt(false) ^ sqrtInverseShift,
 200 |     |       basePrice.sqrt(true) * sqrtShift
 201 |     |     ) : (
 202 |     |       basePrice.log() + logShift,
 203 |     |       basePrice.sqrt(false) * sqrtShift,
 204 |     |       basePrice.sqrt(true) ^ sqrtInverseShift
 205 |     |     );
 206 |     | 
 207 |     |     // The requirements of 'storePrice' are satisfied due to the above
 208 |     |     // arguments and the input requirements.
 209 |     |     resultant.storePrice(height, logPrice, sqrtPrice, sqrtInversePrice);
 210 |     |   }
 211 |     | }

R:/LIAT.AI/question2-calldata/contracts/utilities/KernelCompact.sol
   1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
   2 |     | pragma solidity ^0.8.28;
   3 |     | 
   4 |     | import {
   5 |     |   _spacing_,
   6 |     |   getKernel,
   7 |     |   getKernelLength,
   8 |     |   setKernelLength
   9 |     | } from "./Memory.sol";
  10 |     | import {
  11 |     |   Index,
  12 |     |   zeroIndex,
  13 |     |   oneIndex,
  14 |     |   twoIndex,
  15 |     |   maxKernelIndex
  16 |     | } from "./Index.sol";
  17 |     | import {X15, oneX15} from "./X15.sol";
  18 |     | import {X59, zeroX59, minLogStep} from "./X59.sol";
  19 |     | import {X216} from "./X216.sol";
  20 |     | import {PriceLibrary} from "./Price.sol";
  21 |     | import {Kernel} from "./Kernel.sol";
  22 |     | import {
  23 |     |   SecondHorizontalCoordinateIsZero,
  24 |     |   NonMonotonicHorizontalCoordinates,
  25 |     |   NonMonotonicVerticalCoordinates,
  26 |     |   RepetitiveKernelPoints,
  27 |     |   SlopeTooHigh,
  28 |     |   HorizontalCoordinatesMayNotExceedLogSpacing,
  29 |     |   RepetitiveHorizontalCoordinates,
  30 |     |   RepetitiveVerticalCoordinates,
  31 |     |   KernelIndexOutOfRange,
  32 |     |   LastVerticalCoordinateMismatch
  33 |     | } from "./Errors.sol";
  34 |     | 
  35 |     | using PriceLibrary for uint16;
  36 |     | using PriceLibrary for uint256;
  37 |     | 
  38 |     | // For every pool, the kernel function 'k : [0, qSpacing] -> [0, 1]' represents
  39 |     | // a monotonically non-decreasing piece-wise linear function. Let 'm + 1'
  40 |     | // denote the number of these breakpoints. For every integer '0 <= i <= m' the
  41 |     | // i-th breakpoint of the kernel represents the pair '(b[i], c[i])' where
  42 |     | //
  43 |     | //  '0 == b[0] <  b[1] <= b[2] <= ... <= b[m - 1] <  b[m] == qSpacing',
  44 |     | //  '0 == c[0] <= c[1] <= c[2] <= ... <= c[m - 1] <= c[m] == 1'.
  45 |     | // 
  46 |     | // In its compact form, each breakpoint occupies 10 bytes, in which:
  47 |     | //
  48 |     | //  - the 'X15' representation of '(2 ** 15) * c[i]' occupies 2 bytes,
  49 |     | //
  50 |     | //  - the 'X59' representation of '(2 ** 59) * b[i]' occupies 8 bytes,
  51 |     | //
  52 |     | // The above-mentioned layout is illustrated as follows:
  53 |     | //
  54 |     | //          A 80 bit kernel breakpoint
  55 |     | //  +--------+--------------------------------+
  56 |     | //  | 2 byte |             8 byte             |
  57 |     | //  +--------+--------------------------------+
  58 |     | //  |        |
  59 |     | //  |         \
  60 |     | //  |          (2 ** 59) * b[i]
  61 |     | //   \
  62 |     | //    (2 ** 15) * c[i]
  63 |     | //
  64 |     | // These 80 bit breakpoints are compactly encoded in a 'uint256[]' array and
  65 |     | // given as input to 'initialize' or 'modifyKernel' methods.
  66 |     | //
  67 |     | // The expanded form of kernel is calculated based on the given compact form
  68 |     | // and stored on the storage smart contract.
  69 |     | type KernelCompact is uint256;
  70 |     | 
  71 |     | using KernelCompactLibrary for KernelCompact global;
  72 |     | 
  73 |     | library KernelCompactLibrary {
  74 |     |   /// @notice Returns the breakpoint components corresponding to the given
  75 |     |   /// index of a compact kernel.
  76 |     |   ///
  77 |     |   /// Index out of range should be avoided externally.
  78 |     |   function member(
  79 |     |     KernelCompact kernelCompact,
  80 |     |     Index index
  81 |     |   ) internal pure returns (
  82 |     |     X15 height,
  83 |     |     X59 logShift
  84 |     |   ) {
  85 |     |     // If 'index' is equal to 0, then this function should return 
  86 |     |     // '(zeroX15, zeroX59)', because the first member of 'kernelCompact' is
  87 |     |     // always '(zeroX15, zeroX59)'.
  88 |     |     if (index > zeroIndex) {
  89 |     |       uint256 pointer;
  90 |     |       assembly {
  91 |     |         // Each member of 'kernelCompact' is 10 bytes. 2 bytes for the 'height'
  92 |     |         // and 8 bytes for the 'logShift'.
  93 |     |         // '8 == 10 - 2'. We move 2 bytes forward because 'priceLibrary' uses
  94 |     |         // the following layout to read prices from the memory:
  95 |     |         //
  96 |     |         //          A 80 bit kernel breakpoint
  97 |     |         //
  98 |     |         //              pointer
  99 |     |         //            /
 100 |     |         //  +--------+--------------------------------+
 101 |     |         //  | 2 byte |             8 byte             |
 102 |     |         //  +--------+--------------------------------+
 103 |     |         //  |        |
 104 |     |         //  |         \
 105 |     |         //  |          (2 ** 59) * b[i]
 106 |     |         //   \
 107 |     |         //    (2 ** 15) * c[i]
 108 |     |         //
 109 |     |         // In other words, the pointer to be used to access the 'height' and 
 110 |     |         // 'logShift' should point to the end of 'height' and the beginning of
 111 |     |         // 'logShift'. Since 'height' occupies 2 bytes, we move 2 bytes forward
 112 |     |         // to point to the end of it. We move 10 bytes backward because the
 113 |     |         // first breakpoint which is supposed to be '(zeroX15, zeroX59)' is 
 114 |     |         // always omitted.
 115 |     |         // The addition and multiplication are safe because index out-of-range
 116 |     |         // is handled externally.
 117 |     |         pointer := add(kernelCompact, sub(mul(10, index), 8))
 118 |     |       }
 119 |     |       // Now that we have the pointer, we can load both the 'height' and
 120 |     |       // 'logShift' from the memory.
 121 |     |       height = pointer.height();
 122 |     |       logShift = pointer.log();
 123 |     |     }
 124 |     |   }
 125 |     | 
 126 |     |   /// @notice Sqrt values are calculated and the kernel array is constructed.
 127 |     |   function expand(
 128 |     |     KernelCompact kernelCompact
 129 |     |   ) internal pure {
 130 |     |     Index i = oneIndex;
 131 |     |     uint256 pointer;
 132 |     |     // This is the place in memory where the expanded kernel is stored.
 133 |     |     Kernel kernel = getKernel();
 134 |     |     assembly {
 135 |     |       // We move '62 = 8 + 27 + 27' bytes backward. When we later move 64 bytes
 136 |     |       // forward, the pointer would point to 'kernel + 2' which follows this
 137 |     |       // layout:
 138 |     |       //
 139 |     |       //        pointer to the first price
 140 |     |       //      /
 141 |     |       //     |        A 512 bit kernel breakpoint
 142 |     |       //  +--+--------+-----------------+-----------------+
 143 |     |       //  |  | 8 byte |     27 byte     |     27 byte     |
 144 |     |       //  +--+--------+-----------------+-----------------+
 145 |     |       //  |  |        |                 |
 146 |     |       //  |  |        |                  \
 147 |     |       //  |  |        |                   (2 ** 216) * exp(- 16 + b[i] / 2)
 148 |     |       //  |  |         \
 149 |     |       //  |  |          (2 ** 216) * exp(- b[i] / 2)
 150 |     |       //  |   \
 151 |     |       //  |    (2 ** 59) * b[i]
 152 |     |       //   \
 153 |     |       //    (2 ** 15) * c[i]
 154 |     |       //
 155 |     |       pointer := sub(kernel, 62)
 156 |     |     }
 157 |     |     Index length = getKernelLength();
 158 |     |     while (i < length) {
 159 |     |       // We move 64 bytes forward because each member of kernel occupies 
 160 |     |       // exactly 64 bytes.
 161 |     |       // The addition is safe because we do not go beyond the length of the
 162 |     |       // kernel which is calculated prior to calling this method by the
 163 |     |       // function 'validate'.
 164 |     |       unchecked {
 165 |     |         pointer = pointer + 64;
 166 |     |       }
 167 |     | 
 168 |     |       // 'height' and 'logShift' are loaded first.
 169 |     |       // Index-out-of-range is not possible, because we do not go beyond the 
 170 |     |       // length of the kernel which is calculated prior to calling this method
 171 |     |       // by the function 'validate'.
 172 |     |       (X15 c_i, X59 b_i) = kernelCompact.member(i);
 173 |     | 
 174 |     |       // The requirements of 'exp' are met because 'kernelCompact' is validated
 175 |     |       // prior to calling this function. The custom errors
 176 |     |       // 'SecondHorizontalCoordinateIsZero' and 
 177 |     |       // 'NonMonotonicHorizontalCoordinates' safeguard against any horizontal
 178 |     |       // coordinate being zero.
 179 |     |       // On the other hand, the custom errors 'BlankIntervalsShouldBeAvoided'
 180 |     |       // and 'HorizontalCoordinatesMayNotExceedLogSpacing' safeguard against
 181 |     |       // any horizontal coordinate exceeding '2 ** 64 - 1'.
 182 |     |       (X216 iSqrt, X216 iSqrtInverse) = b_i.exp();
 183 |     | 
 184 |     |       // The requirements of 'storePrice' are met because the custom errors
 185 |     |       // 'LastVerticalCoordinateMismatch' and 'NonMonotonicVerticalCoordinates'
 186 |     |       // safeguard against any vertical coordinate exceeding 'oneX15'. As 
 187 |     |       // discussed above, all horizontal coordinates are between '0' and 
 188 |     |       // '2 ** 64'. The outputs of the function 'exp()' never exceed 'oneX216'
 189 |     |       // because both 'exp(- x / (2 ** 60))' and  'exp(-16 + x / (2 ** 60))'
 190 |     |       // are positive and smaller than '1'. Lastly, since 'kernel' always
 191 |     |       // appears after the end of static parameters, (i.e., 
 192 |     |       // 'kernel >= _endOfStaticParams_') the value of 'pointer' is not less
 193 |     |       // than 32.
 194 |     |       pointer.storePrice(c_i, b_i, iSqrt, iSqrtInverse);
 195 |     | 
 196 |     |       // The addition is safe because we do not go beyond the length of the
 197 |     |       // kernel which is calculated prior to calling this method by the
 198 |     |       // function 'validate'.
 199 |     |       i = i + oneIndex;
 200 |     |     }
 201 |     |   }
 202 |     | 
 203 |     |   /// @notice Validates a given kernel for compliance.
 204 |     |   function validate(
 205 |     |     KernelCompact kernelCompact
 206 |     |   ) internal pure {
 207 |     |     X59 qSpacing = _spacing_.log();
 208 |     | 
 209 |     |     // The length of any given 'kernelCompact' is at least 2. The first member
 210 |     |     // is '(zeroX15, zeroX59)' which is omitted. The last member is
 211 |     |     // '(oneX15, qSpacing)'.
 212 |     |     Index length = twoIndex;
 213 |     | 
 214 |     |     // 'i', 'j', and 'k' are indices representing consecutive members of
 215 |     |     // the given 'kernelCompact', respectively.
 216 |     |     Index i = zeroIndex;
 217 |     |     Index j = oneIndex;
 218 |     | 
 219 |     |     // The following two coordinates are zero by default to represent the first
 220 |     |     // member '(zeroX15, zeroX59)'.
 221 |     |     X15 c_i;
 222 |     |     X59 b_i;
 223 |     | 
 224 |     |     // The second member of 'kernelCompact' is loaded next. 
 225 |     |     (X15 c_j, X59 b_j) = kernelCompact.member(j);
 226 |     | 
 227 |     |     // The third member of 'kernelCompact' is loaded next. 'k' may be an out of
 228 |     |     // range index in which case its values will not be used. This is
 229 |     |     // intentional, because the line 'if (b_j == qSpacing) break;' appears
 230 |     |     // prior to using 'k'.
 231 |     |     (X15 c_k, X59 b_k) = kernelCompact.member(length);
 232 |     | 
 233 |     |     // The second horizontal coordinate may not be zero. Remember that the
 234 |     |     // first member of the kernel is '(zeroX15, zeroX59)'. If the second
 235 |     |     // horizontal coordinate is 'zeroX59', it means that we have a vertical
 236 |     |     // jump at the origin. This is not permitted because it would limit
 237 |     |     // liquidity growth.
 238 |     |     require(b_j != zeroX59, SecondHorizontalCoordinateIsZero());
 239 |     | 
 240 |     |     // A loop over every member of 'kernelCompact'.
 241 |     |     while (true) {
 242 |     |       // The horizontal coordinates should be monotonically nondecreasing. This
 243 |     |       // is because we are inputting breakpoints from the left to the right and
 244 |     |       // from the bottom to the top.
 245 |     |       require(b_i <= b_j, NonMonotonicHorizontalCoordinates(b_i, b_j));
 246 |     | 
 247 |     |       // The vertical coordinates should be monotonically nondecreasing. This
 248 |     |       // is because we are inputting breakpoints from the left to the right and
 249 |     |       // from the bottom to the top.
 250 |     |       require(
 251 |     |         c_i <= c_j,
 252 |     |         NonMonotonicVerticalCoordinates(c_i, c_j)
 253 |     |       );
 254 |     | 
 255 |     |       // Repetitive breakpoints should be avoided.
 256 |     |       require(
 257 |     |         (b_i != b_j) || (c_i != c_j),
 258 |     |         RepetitiveKernelPoints(c_i, b_i)
 259 |     |       );
 260 |     | 
 261 |     |       // If 'b_i == b_j', we have a vertical jump (discontinuity) which is
 262 |     |       // permitted. If 'c_i == c_j', we have a flat segment which is
 263 |     |       // also permitted. However, in case of a sloped segment, 'b_j - b_i'
 264 |     |       // may not be less than 'minLogStep' which corresponds to a price
 265 |     |       // movement by a factor of approximately '1.0000000075'.
 266 |     |       require(
 267 |     |         (b_i == b_j) || (c_i == c_j) || (b_j - b_i >= minLogStep),
 268 |     |         SlopeTooHigh(b_i, b_j)
 269 |     |       );
 270 |     | 
 271 |     |       // The kernel is characterized via a sequence of monotonically 
 272 |     |       // non-decreasing horizontal coordinates from 'zeroX59' to 'qSpacing'
 273 |     |       // and a sequence of monotonically non-decreasing vertical coordinates
 274 |     |       // from 'zeroX15' to 'oneX15'. Hence, no horizontal coordinate may exceed
 275 |     |       // 'qSpacing'.
 276 |     |       require(
 277 |     |         b_j <= qSpacing,
 278 |     |         HorizontalCoordinatesMayNotExceedLogSpacing(b_j, qSpacing)
 279 |     |       );
 280 |     | 
 281 |     |       // 'b_j == qSpacing' indicates that we have reached the end of
 282 |     |       // 'kernelCompact'. This is because the last member is supposed to be
 283 |     |       // '(oneX15, qSpacing)' and the horizontal coordinates for all other
 284 |     |       // members should be less than 'qSpacing'.
 285 |     |       if (b_j == qSpacing) break;
 286 |     | 
 287 |     |       // A horizontal coordinate cannot be repeated twice. It may be repeated
 288 |     |       // once, which would indicate a vertical jump (kernel discontinuity).
 289 |     |       require(
 290 |     |         (b_i != b_j) || (b_j != b_k),
 291 |     |         RepetitiveHorizontalCoordinates(b_i)
 292 |     |       );
 293 |     | 
 294 |     |       // A vertical coordinate cannot be repeated twice. It may be repeated
 295 |     |       // once, which would indicate a flat segment.
 296 |     |       require(
 297 |     |         (c_i != c_j) || (c_j != c_k),
 298 |     |         RepetitiveVerticalCoordinates(c_i)
 299 |     |       );
 300 |     | 
 301 |     |       // We substitute 'i' with 'j' to move one step forward.
 302 |     |       i = j;
 303 |     |       c_i = c_j;
 304 |     |       b_i = b_j;
 305 |     | 
 306 |     |       // We substitute 'j' with 'k' to move one step forward.
 307 |     |       j = length;
 308 |     |       c_j = c_k;
 309 |     |       b_j = b_k;
 310 |     | 
 311 |     |       // 'length' is incremented. The addition is safe because of the following
 312 |     |       // check.
 313 |     |       length = length + oneIndex;
 314 |     | 
 315 |     |       // The deployment code for static parameters and kernel reserves 2 bytes
 316 |     |       // for the byte count of the content to be deployed. Because of this
 317 |     |       // limit, we should have:
 318 |     |       //
 319 |     |       // '_endOfStaticParams_ - _staticParams_ + 64*(length - 1) + 1 < 2 ** 16'
 320 |     |       //
 321 |     |       // where
 322 |     |       //
 323 |     |       // - '64' accounts for the number of bytes that each member of kernel
 324 |     |       // occupies.
 325 |     |       // - '-1' accounts for the omitted origin point.
 326 |     |       // - '+1' accounts for a '00' padding byte.
 327 |     |       //
 328 |     |       // Hence:
 329 |     |       //
 330 |     |       // 'length <= 1 + (
 331 |     |       //    ((2 ** 16 - 1) - 1 - _endOfStaticParams_ + _staticParams_) / 64
 332 |     |       // ) == 1020'
 333 |     |       //
 334 |     |       require(length <= maxKernelIndex, KernelIndexOutOfRange(length));
 335 |     | 
 336 |     |       // 'k' may be an out of range index in which case its values will not be 
 337 |     |       // used. This is intentional, because the line
 338 |     |       // 'if (b_j == qSpacing) break;' appears prior to using 'k'.
 339 |     |       (c_k, b_k) = kernelCompact.member(length);
 340 |     |     }
 341 |     | 
 342 |     |     // The last member of 'kernelCompact' should be '(oneX15, qSpacing)'.
 343 |     |     // The loop is already broken at 'b_j == qSpacing' and now we check the
 344 |     |     // vertical coordinate.
 345 |     |     require(c_j == oneX15, LastVerticalCoordinateMismatch(c_j));
 346 |     | 
 347 |     |     // The length for 'kernel' is set in memory. Due to the above check, this
 348 |     |     // value does not exceed 'maxKernelIndex' and can be safely stored in the
 349 |     |     // allocated 2 bytes of memory.
 350 |     |     setKernelLength(length);
 351 |     |   }
 352 |     | }

R:/LIAT.AI/question2-calldata/contracts/utilities/Memory.sol
    1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
    2 |     | pragma solidity ^0.8.28;
    3 |     | 
    4 |     | /// @dev Nofeeswap's memory layout.
    5 |     | /// @notice Each 'uint16' value is a memory pointer referring to the
    6 |     | /// corresponding value in memory. This file is generated using 'Memory.py'.
    7 |     | 
    8 |     | import {Tag} from "./Tag.sol";
    9 |     | import {Index} from "./Index.sol";
   10 |     | import {X15} from "./X15.sol";
   11 |     | import {X23} from "./X23.sol";
   12 |     | import {X47} from "./X47.sol";
   13 |     | import {X59} from "./X59.sol";
   14 |     | import {X111} from "./X111.sol";
   15 |     | import {X127} from "./X127.sol";
   16 |     | import {X208} from "./X208.sol";
   17 |     | import {X216} from "./X216.sol";
   18 |     | import {Curve} from "./Curve.sol";
   19 |     | import {Kernel} from "./Kernel.sol";
   20 |     | 
   21 |     | // Refers to the third slot of the memory which contains the free memory
   22 |     | // pointer.
   23 |     | uint16 constant _freeMemoryPointer_ = 64;
   24 |     | 
   25 |     | // Refers to the fourth slot of the memory which remains blank.
   26 |     | uint16 constant _blank_ = 96;
   27 |     | 
   28 |     | // When the protocol calls a hook or the sentinel contract, a snapshot of the
   29 |     | // memory (with '_hookSelector_' as the starting point) is sent to the target
   30 |     | // contract as calldata. Before calling the target contract, this 4 byte space
   31 |     | // is populated with the intended function selector of the target contract.
   32 |     | uint16 constant _hookSelector_ = 128;
   33 |     | 
   34 |     | // This space is populated with the abi offset '0x20' so that the hook or the
   35 |     | // sentinel contract can decode the given calldata. This offset value points to
   36 |     | // the slot that contains the byte count of the snapshot given to the hook or
   37 |     | // the sentinel contract
   38 |     | uint16 constant _hookInputHeader_ = 132;
   39 |     | 
   40 |     | // This space is populated with the byte count of 'bytes calldata hookInput'
   41 |     | // which is passed as input to the hook or the sentinel contract.
   42 |     | uint16 constant _hookInputByteCount_ = 164;
   43 |     | 
   44 |     | // 'msg.sender' in the current execution context is placed in this space to be
   45 |     | // passed to the hook or the sentinel contract. This way, the hook or the
   46 |     | // sentinel contract have access to 'msg.sender' in the prior execution
   47 |     | // context (i.e., in the context where the protocol is called).
   48 |     | uint16 constant _msgSender_ = 196;
   49 |     | 
   50 |     | // This space is dedicated to the identifier of the intended pool. The least
   51 |     | // significant 160 bits of this memory space refer to the hook address. The
   52 |     | // next 20 bits are referred to as flags that are used by the protocol to know
   53 |     | // which methods from 'IHook.sol' should be invoked and what permissions are
   54 |     | // activated. Flags are further explained in 'IHook.sol'. The next 8 bits
   55 |     | // represent the natural logarithm of 'pOffset' which must be greater than or
   56 |     | // equal to '-89' and less than or equal to '89' in 'int8' representation
   57 |     | // (two's complement). Hence, 'pOffset' is greater than or equal to 'exp(-89)'
   58 |     | // and less than or equal to 'exp(+89)'. As will be discussed later, the price
   59 |     | // of the pool is always greater than or equal to
   60 |     | //
   61 |     | //  'pOffset * exp(- 16 + 1 / (2 ** 59))'
   62 |     | //
   63 |     | // and less than or equal to
   64 |     | //
   65 |     | //  'pOffset * exp(+ 16 - 1 / (2 ** 59))'.
   66 |     | uint16 constant _poolId_ = 216;
   67 |     | 
   68 |     | // How does a swap work?
   69 |     | // ----------------------------------------------------------------------------
   70 |     | // A swap in a pool can be interpreted as a change in that pool's price. There
   71 |     | // are two types of swaps:
   72 |     | //
   73 |     | //  - If 'tag0' is outgoing from the pool and 'tag1' is incoming to the pool as
   74 |     | //    a result of a swap, then the swap is price increasing, i.e., the price
   75 |     | //    prior to the execution of the swap is lower than the price after the
   76 |     | //    execution of the swap.
   77 |     | //
   78 |     | //  - If 'tag0' is incoming to the pool and 'tag1' is outgoing from the pool as
   79 |     | //    a result of a swap, then the swap is price decreasing, i.e., the price
   80 |     | //    prior to the execution of the swap is higher than the price after the
   81 |     | //    execution of the swap.
   82 |     | //
   83 |     | // Let 'pOffset' represent the offset price whose natural logarithm is encoded
   84 |     | // in 'poolId' as described above (in the definition of 'poolId'). The protocol
   85 |     | // offers liquidity providers (LPs) the flexibility to deposit their liquidity
   86 |     | // in a range of their choosing. To this end, the price horizon is partitioned
   87 |     | // into a number of liquidity intervals with equal length in the natural
   88 |     | // logarithmic scale. An LP may choose any consecutive range of liquidity
   89 |     | // intervals to deposit their liquidity. By doing so, the LP acquires a number
   90 |     | // of shares in every liquidity interval that belongs to the given range. The
   91 |     | // shares can be used later to withdraw liquidity along with any accumulated
   92 |     | // growth which is accrued as a result of swap and donate actions.
   93 |     | //
   94 |     | // At each moment, a single one of the above-mentioned intervals is active to
   95 |     | // which the current price of the pool belongs. Let 'pLower' and 'pUpper',
   96 |     | // respectively, denote the minimum and maximum price in the current active
   97 |     | // liquidity interval and define
   98 |     | //
   99 |     | //  'qLower := log(pLower / pOffset)'
  100 |     | //  'qUpper := log(pUpper / pOffset)'
  101 |     | //  'qSpacing := log(pUpper / pLower)'.
  102 |     | //
  103 |     | // Then, for every integer 'j', the interval
  104 |     | //
  105 |     | //  '[qLower + j * qSpacing, qUpper + j * qSpacing]'
  106 |     | //
  107 |     | // is a valid liquidity interval if and only if:
  108 |     | //
  109 |     | //  '- 16 + 1 / (2 ** 59) + qSpacing < qLower + j * qSpacing'
  110 |     | //
  111 |     | // and
  112 |     | //
  113 |     | //  'qUpper + j * qSpacing <= + 16 - 1 / (2 ** 59) - qSpacing'.
  114 |     | //
  115 |     | // This includes the current active liquidity interval '[qLower, qUpper]'
  116 |     | // which corresponds to 'j == 0'.
  117 |     | //
  118 |     | // Every swap has the following input parameters:
  119 |     | //
  120 |     | //  - 'logPriceLimit': This value is the natural logarithm of a price limit in
  121 |     | //    'X59' representation. It imposes a constraint on the price of the pool
  122 |     | //    post execution of the swap. For price increasing swaps, 'logPriceLimit'
  123 |     | //    serves as an upper bound, in which case the price of the pool must not
  124 |     | //    exceed 'exp(logPriceLimit / (2 ** 59))'. For price decreasing swaps,
  125 |     | //    'logPriceLimit' serves as a lower bound, in which case the price of the
  126 |     | //    pool must not subceed 'exp(logPriceLimit / (2 ** 59))'. In both cases,
  127 |     | //    once the price of the pool reaches 'exp(logPriceLimit / (2 ** 59))', the
  128 |     | //    execution of the swap is halted. Put simply, no amount of tags are traded
  129 |     | //    with any price worst than 'exp(logPriceLimit / (2 ** 59))' for the
  130 |     | //    swapper.
  131 |     | //
  132 |     | //  - 'zeroForOne': If 'zeroForOne == 0', then the swap is price increasing in
  133 |     | //    which case 'tag0' is outgoing from the pool and 'tag1' is incoming to the
  134 |     | //    pool. If 'zeroForOne == 1', then the swap is price decreasing in which
  135 |     | //    case 'tag0' is incoming to the pool and 'tag1' is outgoing from the pool.
  136 |     | //    Given any other value, the movement of the price is towards
  137 |     | //    'logPriceLimit', i.e., the swap is price increasing if
  138 |     | //
  139 |     | //      'pCurrent < exp(logPriceLimit / (2 ** 59))'
  140 |     | //
  141 |     | //    and the swap is price decreasing if
  142 |     | //
  143 |     | //      'exp(logPriceLimit / (2 ** 59)) < pCurrent'
  144 |     | //
  145 |     | //    where 'pCurrent' represents the current price of the pool.
  146 |     | //
  147 |     | //  - 'amountSpecified': If 'amountSpecified > 0' then 'amountSpecified'
  148 |     | //    represents the amount of 'tag0' (if the swap is price decreasing) or the
  149 |     | //    amount of 'tag1' (if the swap is price increasing) to be given to the
  150 |     | //    pool subject to the constraint imposed by 'logPriceLimit'. If
  151 |     | //    'amountSpecified < 0' then '0 - amountSpecified' represents the amount of
  152 |     | //    'tag0' (if the swap is price increasing) or the amount of 'tag1' (if the
  153 |     | //    swap is price decreasing) to be taken from the pool. Define
  154 |     | //
  155 |     | //      'exactInput := amountSpecified > 0'
  156 |     | //
  157 |     | //    which determines whether 'amountSpecified' is incoming to the pool or
  158 |     | //    outgoing from the pool. Additionally, if 'zeroForOne == exactInput', then
  159 |     | //    'amountSpecified' is with respect to 'tag0' and if
  160 |     | //    'zeroForOne != exactInput' then 'amountSpecified' is with respect to
  161 |     | //    'tag1'.
  162 |     | //
  163 |     | //  - 'crossThreshold': If large enough, a swap may involve transitioning from
  164 |     | //    the active liquidity interval to other intervals. 'crossThreshold'
  165 |     | //    imposes a lower bound on the total number of shares that should be
  166 |     | //    available in any interval for the swapper to transact in that interval.
  167 |     | //    For example, if 'crossThreshold == 0', which is the default, no minimum
  168 |     | //    number of shares is imposed. If 'crossThreshold == 100', there has to be
  169 |     | //    at least 100 shares in the interval for the swap function to either swap
  170 |     | //    within or enter that interval.
  171 |     | //
  172 |     | // Consider a hypothetical pool that satisfies
  173 |     | //
  174 |     | //  'qLower < qCurrent < qUpper',
  175 |     | //
  176 |     | // where
  177 |     | //
  178 |     | //  'qCurrent := log(pCurrent / pOffset)'
  179 |     | //
  180 |     | // and 'pCurrent' is the current price of the pool.
  181 |     | //
  182 |     | // Consider a swap in this pool with the following parameters:
  183 |     | //
  184 |     | //  'logPriceLimit := (2 ** 59) * log(pLimit)'
  185 |     | //  'zeroForOne := 1'
  186 |     | //  'amountSpecified := +oo'
  187 |     | //  'crossThreshold := 0'
  188 |     | //
  189 |     | // where
  190 |     | //
  191 |     | //  'pLimit := exp(- 3 * qSpacing) * pCurrent'
  192 |     | //
  193 |     | // and
  194 |     | //
  195 |     | //  'qLimit := log(pLimit / pOffset)'.
  196 |     | //
  197 |     | // As explained later in this script, each of the above input parameters are
  198 |     | // loaded from calldata, transformed to appropriate formats and then stored in
  199 |     | // dedicated spaces in memory that are pointed to by the constant values
  200 |     | // '_logPriceLimit_', '_zeroForOne_', '_amountSpecified_', and
  201 |     | // '_crossThreshold_', respectively. Additionally, prior to the execution
  202 |     | // of the swap, 'qLimit' is calculated and stored in the memory space which
  203 |     | // is pointed to by '_logPriceLimitOffsetted_'.
  204 |     | //
  205 |     | // In this example, we have:
  206 |     | //
  207 |     | //  'qLower - 3 * qSpacing < qLimit < qUpper - 3 * qSpacing',
  208 |     | //
  209 |     | // which is illustrated as follows:
  210 |     | //
  211 |     | //             qLimit                                  qCurrent
  212 |     | //               |                                         |
  213 |     | //  ... <--+-------------+-------------+-------------+-------------+--> ...
  214 |     | //
  215 |     | // In the presence of liquidity, the further away 'qLimit' is from 'qCurrent'
  216 |     | // the larger the outgoing amount from the pool and the incoming amount to the
  217 |     | // pool are.
  218 |     | //
  219 |     | // In the above example, the swap is price decreasing which means that 'tag0'
  220 |     | // is incoming to the pool and 'tag1' is outgoing from the pool as a result of
  221 |     | // the swap.
  222 |     | //
  223 |     | // Observe that 'qLimit' is three intervals away from 'qCurrent'. Hence, in
  224 |     | // order to go from 'qCurrent' to 'qLimit' we need to transact in the following
  225 |     | // four intervals:
  226 |     | //
  227 |     | //  '[qLower - 0 * qSpacing, qUpper - 0 * qSpacing]',
  228 |     | //  '[qLower - 1 * qSpacing, qUpper - 1 * qSpacing]',
  229 |     | //  '[qLower - 2 * qSpacing, qUpper - 2 * qSpacing]',
  230 |     | //  '[qLower - 3 * qSpacing, qUpper - 3 * qSpacing]'.
  231 |     | //
  232 |     | // At each point throughout the execution of the swap, as we transition from
  233 |     | // each interval to the next one, the memory pointers '_back_' and '_next_' are
  234 |     | // used in order to keep track of the boundaries for the current active
  235 |     | // interval. Each of these pointers refer to a memory space in which the
  236 |     | // following two values are enclosed:
  237 |     | //
  238 |     | //  'qBack := log(pBack / pOffset)'
  239 |     | //  'qNext := log(pNext / pOffset)'
  240 |     | //
  241 |     | // (among other values) where 'pBack' is the boundary of the current active
  242 |     | // liquidity interval in the opposite direction of the swap and 'pNext' is the
  243 |     | // other boundary in the direction of the swap.
  244 |     | //
  245 |     | // For price increasing swaps, the initial values for 'qBack' and 'qNext' are
  246 |     | // as follows
  247 |     | //
  248 |     | //  'qBack := qLower'
  249 |     | //  'qNext := qUpper'.
  250 |     | //
  251 |     | // However, in the present example, since the swap is price decreasing, these
  252 |     | // initial values are:
  253 |     | //
  254 |     | //  'qBack := qUpper'
  255 |     | //  'qNext := qLower'.
  256 |     | //
  257 |     | // as illustrated here:
  258 |     | //
  259 |     | //             qLimit                                   qCurrent
  260 |     | //               |                                         |
  261 |     | //  ... <--+-------------+-------------+-------------+-------------+--> ...
  262 |     | //                                                   |             |
  263 |     | //                                                 qNext         qBack
  264 |     | //
  265 |     | // As the price transitions to a new liquidity interval, the content of the
  266 |     | // memory spaces that are pointed to by '_back_' and '_next_' are updated
  267 |     | // accordingly.
  268 |     | //
  269 |     | // Now, in order to perform this swap, we need to proceed as follows:
  270 |     | //
  271 |     | //  - The dynamic parameters of the pool are read from the protocol's storage
  272 |     | //    which include the followings:
  273 |     | //
  274 |     | //    - 'sharesTotal': This is the total number of shares that are deposited in
  275 |     | //      the current active liquidity interval '[qLower, qUpper]' across all
  276 |     | //      LPs. Consider an example where we have only two LP positions such that
  277 |     | //      
  278 |     | //      - The first position has 2 shares in every interval from 'qLower' to
  279 |     | //        'qUpper + 2 * qSpacing', i.e., 2 shares in each of the intervals
  280 |     | //        '[qLower, qUpper]', '[qLower + qSpacing, qUpper + qSpacing]', and
  281 |     | //        '[qSpacing + 2 * qSpacing, qUpper + 2 * qSpacing]'.
  282 |     | //      
  283 |     | //      - The second position has 5 shares in every interval from
  284 |     | //        'qLower - qSpacing' to 'qUpper + qSpacing', i.e., 5 shares in each of
  285 |     | //        the intervals '[qLower - qSpacing, qUpper - qSpacing]',
  286 |     | //        '[qLower, qUpper]', and '[qLower + qSpacing, qUpper + qSpacing]'.
  287 |     | //
  288 |     | //      In this case, both LP positions include the active liquidity interval
  289 |     | //      '[qLower, qUpper]' which means that 'sharesTotal == 2 + 5 == 7'.
  290 |     | //
  291 |     | //    - 'growth': The amount of liquidity which is allocated to a single LP
  292 |     | //      share in the active interval increases as a result of a swap or a
  293 |     | //      donation. We use this parameter to keep track of the amount of
  294 |     | //      liquidity for each share. 'growth' is stored in 'X111' format and we
  295 |     | //      always have 'growth >= oneX111'.
  296 |     | //
  297 |     | //    - 'qCurrent': This is equal to 'log(pCurrent / pOffset)' where 'pCurrent'
  298 |     | //      is the current price of the pool prior to the execution of the swap.
  299 |     | //
  300 |     | //    - 'staticParamsStoragePointer': Certain information about the pool that
  301 |     | //      never change (e.g., 'tag0' and 'tag1') or do not change frequently are
  302 |     | //      encoded in an external smart contract's bytecode. We refer to this
  303 |     | //      external smart contract as the storage smart contract of the pool. This
  304 |     | //      way, the encoded parameters can be accessed by reading the storage
  305 |     | //      smart contract's bytecode which is more gas efficient than accessing
  306 |     | //      protocol's storage via 'sload'. However, if we ever need to make any
  307 |     | //      modification, a new storage smart contract should be deployed with an
  308 |     | //      updated bytecode. Hence, the protocol needs to keep track of the
  309 |     | //      address for the storage smart contract associated with each pool.
  310 |     | //      Instead of storing a 20-byte address for each pool, we calculate it
  311 |     | //      from 'staticParamsStoragePointer' as further explained in
  312 |     | //      'Storage.sol'. Hence, 'staticParamsStoragePointer' is a 16-bit pointer
  313 |     | //      which is used to derive the address of the storage smart contract from
  314 |     | //      which additional information about the pool is read.
  315 |     | //
  316 |     | //  - The curve sequence is read from the protocol's storage. The 'curve' is a
  317 |     | //    sequence containing historical prices in 'X59' representation. It should
  318 |     | //    have at least two members. In other words, every  member of the curve
  319 |     | //    sequence represents a historical price 'pHistorical' which is stored in
  320 |     | //    the form:
  321 |     | //
  322 |     | //      '(2 ** 59) * (16 + qHistorical)'
  323 |     | //
  324 |     | //    where
  325 |     | //
  326 |     | //      'qHistorical := log(pHistorical / pOffset)'.
  327 |     | //
  328 |     | //    Hence, each member of the curve occupies exactly '64' bits as explained
  329 |     | //    in 'Curve.sol'. This is because 'pHistorical' satisfies
  330 |     | //
  331 |     | //      'pOffset * exp(- 16 + 1 / (2 ** 59)) <= pHistorical'
  332 |     | //
  333 |     | //    and
  334 |     | //
  335 |     | //      'pHistorical <= pOffset * exp(+ 16 - 1 / (2 ** 59))'.
  336 |     | //
  337 |     | //    which conclude that
  338 |     | //
  339 |     | //      '1 <= (2 ** 59) * (16 + qHistorical) <= 2 ** 64 - 1'.
  340 |     | //
  341 |     | //    The first and the second members of the curve sequence correspond to the
  342 |     | //    boundaries of the current active liquidity interval (i.e., 'qLower' and
  343 |     | //    'qUpper') with the order depending on the pool's history. The last member
  344 |     | //    of the curve represents the current price of the pool, i.e., 'qCurrent'.
  345 |     | //    
  346 |     | //    Let 'l' denote the number of members in the curve sequence. Since, we
  347 |     | //    already know 'qCurrent' from dynamic parameters, we can determine 'l'
  348 |     | //    without having to load an entire length slot! In other words, we keep
  349 |     | //    reading members of the curve sequence from protocol's storage (four
  350 |     | //    members per slot) until we encounter 'qCurrent' which is already known
  351 |     | //    from dynamic parameters. Then, 'l' can be determined based on the
  352 |     | //    position of 'qCurrent' in the curve sequence.
  353 |     | //
  354 |     | //    For every integer '0 <= i < l', denote the (i + 1)-th historical price
  355 |     | //    recorded by the curve sequence as 'p[i]'. Additionally, to simplify the
  356 |     | //    notations, the out-of-range price 'p[l]' is assigned the same value as
  357 |     | //    'p[l - 1]'. Now, for every integer '0 <= i <= l', define also 
  358 |     | //    
  359 |     | //      'q[i] := log(p[i] / pOffset)'.
  360 |     | //
  361 |     | //    The curve sequence is constructed in such a way that for every
  362 |     | //    '2 <= i < l', we have:
  363 |     | //
  364 |     | //      'min(q[i - 1], q[i - 2]) < q[i] < max(q[i - 1], q[i - 2])'.
  365 |     | //
  366 |     | //    This ordering rule is verified upon initialization of any pool and it is
  367 |     | //    preserved by every amendment to the curve sequence.
  368 |     | //    
  369 |     | //    In order to use the curve sequence, we need to define a number of
  370 |     | //    functions. For every '0 <= i <= l - 2', if 'q[i + 2] < q[i]' define
  371 |     | //
  372 |     | //      'w_i : [qLower, qUpper] -> [0, qSpacing]'
  373 |     | //
  374 |     | //    as
  375 |     | //
  376 |     | //                  /
  377 |     | //                 |  q - q[i + 1]  if q[i + 2] < q < q[i]
  378 |     | //      'w_i(q) := |                                       '
  379 |     | //                 |  0             otherwise
  380 |     | //                  \
  381 |     | //
  382 |     | //    and if 'q[i] < q[i + 2]' define
  383 |     | //
  384 |     | //      'w_i : [qLower, qUpper] -> [0, qSpacing]'
  385 |     | //
  386 |     | //    as
  387 |     | //
  388 |     | //                  /
  389 |     | //                 |  q[i + 1] - q  if q[i] < q < q[i + 2]
  390 |     | //      'w_i(q) := |                                        '
  391 |     | //                 |  0             otherwise
  392 |     | //                  \
  393 |     | //
  394 |     | //    Each of the above functions is regarded as a phase. Observe that the
  395 |     | //    diagram for each of the phase is a compactly supported (i.e., equal to
  396 |     | //    zero outside of a bounded interval) segment with either '45' or '135'
  397 |     | //    degrees angle. Define
  398 |     | //
  399 |     | //      'w : [qLower, qUpper] -> [0, qSpacing]'
  400 |     | //
  401 |     | //    as
  402 |     | //
  403 |     | //               l - 2
  404 |     | //               -----
  405 |     | //               \
  406 |     | //      'w(q) := /     w_i(q).
  407 |     | //               -----
  408 |     | //               i = 0
  409 |     | //
  410 |     | //    This function will be used to determine the distribution of liquidity
  411 |     | //    within the active interval '[qLower, qUpper]'. As we will discuss later
  412 |     | //    in this script, the distribution of liquidity is modified with every swap
  413 |     | //    via amendments to the curve sequence and this process ensures liquidity
  414 |     | //    growth for the LPs without the need to charge fees.
  415 |     | //
  416 |     | //    For example, let
  417 |     | //
  418 |     | //      'q[0] := qUpper'
  419 |     | //      'q[1] := qLower'
  420 |     | //      'q[2]'
  421 |     | //      'q[3] := qCurrent'
  422 |     | //
  423 |     | //    represent the curve sequence. Then,
  424 |     | //
  425 |     | //      'w(q) := w_0(q) + w_1(q) + w_2(q)'
  426 |     | //
  427 |     | //    can be plotted as follows:
  428 |     | //
  429 |     | //            w(q)
  430 |     | //              ^
  431 |     | //      spacing |                /
  432 |     | //              |               /
  433 |     | //              |              /
  434 |     | //              |             /
  435 |     | //              |            /
  436 |     | //              |           /
  437 |     | //              |          /
  438 |     | //              |\
  439 |     | //              | \
  440 |     | //              |  \
  441 |     | //              |   \
  442 |     | //              |        /
  443 |     | //              |       /
  444 |     | //              |      /
  445 |     | //              |     /
  446 |     | //            0 +----+----+-------+-> q
  447 |     | //           qLower  |    |       |
  448 |     | //                   |   q[2]   qUpper
  449 |     | //                   |
  450 |     | //               qCurrent
  451 |     | //    
  452 |     | //    To summarize, reading the curve sequence from the protocol's storage
  453 |     | //    gives us access to 'qLower', 'qUpper' and the function 'w'.
  454 |     | //
  455 |     | //    The curve sequence is defined for every inactive liquidity interval as
  456 |     | //    well, although we do not need to keep track of them. For every integer
  457 |     | //    'j > 0', the curve sequence associated with the interval:
  458 |     | //
  459 |     | //      '[qLower + j * qSpacing, qUpper + j * qSpacing]'
  460 |     | //
  461 |     | //    is composed of only two members:
  462 |     | //
  463 |     | //      'q[0] := qUpper + j * qSpacing' 
  464 |     | //      'q[1] := qLower + j * qSpacing'. 
  465 |     | //
  466 |     | //    Hence, the function
  467 |     | //
  468 |     | //      'w : [qLower + j * qSpacing, qUpper + j * qSpacing] -> [0, qSpacing]'
  469 |     | //
  470 |     | //    corresponding to that interval is defined as:
  471 |     | //
  472 |     | //      'w(q) := q - qLower - j * qSpacing'
  473 |     | //
  474 |     | //    which is consistent with the prior definition of 'w' for the active
  475 |     | //    interval. Additionally, for every integer 'j < 0', the curve sequence
  476 |     | //    associated with the interval:
  477 |     | //
  478 |     | //      '[qLower + j * qSpacing, qUpper + j * qSpacing]'
  479 |     | //
  480 |     | //    is composed of only two members:
  481 |     | //
  482 |     | //      'q[0] := qLower + j * qSpacing' 
  483 |     | //      'q[1] := qUpper + j * qSpacing'. 
  484 |     | //
  485 |     | //    Hence, the function
  486 |     | //
  487 |     | //      'w : [qLower + j * qSpacing, qUpper + j * qSpacing] -> [0, qSpacing]'
  488 |     | //
  489 |     | //    corresponding to that interval is defined as:
  490 |     | //
  491 |     | //      'w(q) := qUpper + j * qSpacing - q'
  492 |     | //    
  493 |     | //    which is also consistent with our prior definition.
  494 |     | //
  495 |     | //    After reading the curve sequence for the active interval, we store
  496 |     | //    'qBack' and 'qNext' in their dedicated memory spaces in order to keep
  497 |     | //    track of the boundaries of the active liquidity interval. In the present
  498 |     | //    example, since the swap is price decreasing, the initial values for
  499 |     | //    'qBack' and 'qNext' are as follows:
  500 |     | //
  501 |     | //      'qBack := qUpper',
  502 |     | //      'qNext := qLower'.
  503 |     | //
  504 |     | //    For price increasing swaps, these initial values are
  505 |     | //
  506 |     | //      'qBack := qLower',
  507 |     | //      'qNext := qUpper'.
  508 |     | //
  509 |     | //    As discussed before, 'qBack' and 'qNext' are continuously updated
  510 |     | //    throughout the execution of a swap as we transition to new liquidity
  511 |     | //    intervals.
  512 |     | //
  513 |     | //  - Next, the kernel function is read from the storage smart contract's
  514 |     | //    bytecode. To this end, the dynamic parameter 'staticParamsStoragePointer'
  515 |     | //    is used to calculate the address to the storage smart contract associated
  516 |     | //    with the pool whose bytecode contains the kernel function. The kernel,
  517 |     | //    denoted by
  518 |     | //
  519 |     | //      'k : [0, qSpacing] -> [0, 1]',
  520 |     | //
  521 |     | //    is a monotonically non-decreasing piecewise linear function which is
  522 |     | //    characterized via a list of breakpoints. Each breakpoint has a horizontal
  523 |     | //    coordinate as well as a vertical coordinate. Consider the following
  524 |     | //    examples:
  525 |     | //
  526 |     | //      - The sequence of breakpoints
  527 |     | //
  528 |     | //          '(0, 0), (qSpacing, 1)'
  529 |     | //
  530 |     | //        implies that the diagram of 'k' is a single segment connecting the
  531 |     | //        point '(0, 0)' to the point '(qSpacing, 1)'. This leads to the kernel
  532 |     | //        function:
  533 |     | //
  534 |     | //          'k(h) := h / qSpacing'.
  535 |     | //
  536 |     | //      - The sequence of breakpoints
  537 |     | //
  538 |     | //          '(0, 0), (qSpacing / 2, 1), (qSpacing, 1)'
  539 |     | //
  540 |     | //        implies that the diagram of 'k' is composed of two segments:
  541 |     | //
  542 |     | //          - The first segment connects the point '(0, 0)' to the point
  543 |     | //            '(qSpacing / 2, 1)'.
  544 |     | //
  545 |     | //          - The second segment connects the point '(qSpacing / 2, 1)' to the
  546 |     | //            point '(qSpacing, 1)'.
  547 |     | //
  548 |     | //        The combination of the two segments leads to the kernel function:
  549 |     | //
  550 |     | //                    /
  551 |     | //                   |  2 * h / qSpacing    if 0 < q < qSpacing / 2
  552 |     | //          'k(h) := |                                                      '.
  553 |     | //                   |  1                   if qSpacing / 2 < q < qSpacing
  554 |     | //                    \
  555 |     | //
  556 |     | //      - The sequence of breakpoints
  557 |     | //
  558 |     | //          '(0, 0), (qSpacing / 2, 0), (qSpacing / 2, 1 / 2), (qSpacing, 1)'
  559 |     | //
  560 |     | //        implies that the diagram of 'k' is composed of three segments:
  561 |     | //
  562 |     | //          - The first segment belongs to the horizontal axis connecting the
  563 |     | //            point '(0, 0)' to the point '(qSpacing / 2, 0)'.
  564 |     | //
  565 |     | //          - The second segment is vertical, connecting the point
  566 |     | //            '(qSpacing / 2, 0)' to the point '(qSpacing / 2, 1 / 2)'. A
  567 |     | //            vertical segment (i.e., two consecutive breakpoints with equal
  568 |     | //            horizontal coordinates) indicates that the kernel function is
  569 |     | //            discontinuous which is permitted by the protocol. In this case,
  570 |     | //            we have a discontinuity at point 'qSpacing / 2' because:
  571 |     | //            
  572 |     | //              '0 == k(qSpacing / 2 - epsilon) != 
  573 |     | //                    k(qSpacing / 2 + epsilon) == 1 / 2 + epsilon / qSpacing'
  574 |     | //            
  575 |     | //            where 'epsilon > 0' is an arbitrarily small value approaching 0.
  576 |     | //
  577 |     | //          - The third segment connects the point '(qSpacing / 2, 1 / 2)' to
  578 |     | //            the point '(qSpacing, 1)'.
  579 |     | //
  580 |     | //        The combination of the three segments leads to the kernel function:
  581 |     | //
  582 |     | //                    /
  583 |     | //                   |  0               if 0 < q < qSpacing / 2
  584 |     | //          'k(h) := |                                                  '.
  585 |     | //                   |  h / qSpacing    if qSpacing / 2 < q < qSpacing
  586 |     | //                    \
  587 |     | //    
  588 |     | //    Hence, reading the kernel breakpoints from the storage smart contract
  589 |     | //    gives us access to the function 'k'.
  590 |     | //    
  591 |     | //    Define
  592 |     | //
  593 |     | //      'k(w(.)) : [qLower, qUpper] -> [0, 1]'
  594 |     | //
  595 |     | //    as the liquidity distribution function. As we will demonstrate next, one
  596 |     | //    can determine the outgoing amount from the pool and the incoming amount
  597 |     | //    to the pool by integrating the liquidity distribution function. More
  598 |     | //    precisely, consider a swap that involves a movement of price from
  599 |     | //    'qCurrent' to
  600 |     | //
  601 |     | //      'qTarget := log(pTarget / pOffset)'
  602 |     | //
  603 |     | //    within the same active liquidity interval, i.e.,
  604 |     | //
  605 |     | //      'qLower <= qTarget <= qUpper'.
  606 |     | //
  607 |     | //    If 'qCurrent < qTarget, then the outgoing amount of 'tag0' as a result of
  608 |     | //    this movement is proportional to the following integration of the
  609 |     | //    liquidity distribution function:
  610 |     | //
  611 |     | //                               - 8     / qTarget
  612 |     | //        currentToTarget      e        |    - h / 2
  613 |     | //      '----------------- := ------- * |  e         k(w(h)) dh'.
  614 |     | //           2 ** 216            2      |
  615 |     | //                                     / qCurrent
  616 |     | //
  617 |     | //    In this case, the incoming amount of 'tag1' as a result of this movement
  618 |     | //    is proportional to the following integration of the liquidity
  619 |     | //    distribution function:
  620 |     | //
  621 |     | //                                       - 8     / qTarget
  622 |     | //        incomingCurrentToTarget      e        |    + h / 2
  623 |     | //      '------------------------- := ------- * |  e         k(w(h)) dh'.
  624 |     | //               2 ** 216                2      |
  625 |     | //                                             / qCurrent
  626 |     | //
  627 |     | //    On the other hand, if 'qTarget < qCurrent', then the outgoing amount of
  628 |     | //    'tag1' and the incoming amount of 'tag0', respectively, are proportional
  629 |     | //    to the following integrations of the liquidity distribution function:
  630 |     | //
  631 |     | //                               - 8     / qCurrent
  632 |     | //        currentToTarget      e        |    + h / 2
  633 |     | //      '----------------- := ------- * |  e         k(w(h)) dh',
  634 |     | //           2 ** 216            2      |
  635 |     | //                                     / qTarget
  636 |     | //
  637 |     | //                                       - 8     / qCurrent
  638 |     | //        incomingCurrentToTarget      e        |    - h / 2
  639 |     | //      '------------------------- := ------- * |  e         k(w(h)) dh'.
  640 |     | //                2 ** 216               2      |
  641 |     | //                                             / qTarget
  642 |     | //
  643 |     | //    Now, imagine a scenario where we want to move all the way from 'qCurrent'
  644 |     | //    to 'qUpper' which is a price increasing swap. Hence, in this case, the
  645 |     | //    outgoing amount of 'tag0' is proportional to:
  646 |     | //
  647 |     | //                         - 8     / qUpper
  648 |     | //        integral0      e        |    - h / 2
  649 |     | //      '----------- := ------- * |  e         k(w(h)) dh'.
  650 |     | //        2 ** 216         2      |
  651 |     | //                               / qCurrent
  652 |     | //
  653 |     | //    Observe that moving from 'qCurrent' to 'qUpper' depletes the entire
  654 |     | //    reserve of 'tag0', within the interval '[qLower, qUpper]' (because we
  655 |     | //    cannot go further than that without transitioning to a new interval).
  656 |     | //    Hence, the total reserve of 'tag0' within the interval '[qLower, qUpper]'
  657 |     | //    is proportional to 'integral0' which is given by the above formula.
  658 |     | //
  659 |     | //    Similarly, imagine a scenario where we want to move all the way from
  660 |     | //    'qCurrent' to 'qLower' which is a price decreasing swap. Hence, in this
  661 |     | //    case, the outgoing amount of 'tag1' is proportional to:
  662 |     | //
  663 |     | //                         - 8     / qCurrent
  664 |     | //        integral1      e        |    + h / 2
  665 |     | //      '----------- := ------- * |  e         k(w(h)) dh',
  666 |     | //        2 ** 216         2      |
  667 |     | //                               / qLower
  668 |     | //
  669 |     | //    Observe that moving from 'qCurrent' to 'qLower' depletes the entire
  670 |     | //    reserve of 'tag1', within the interval '[qLower, qUpper]' (because we
  671 |     | //    cannot go further than that without transitioning to a new interval).
  672 |     | //    Hence, the total reserve of 'tag1' within the interval '[qLower, qUpper]'
  673 |     | //    is proportional to 'integral1' which is given by the above formula.
  674 |     | //
  675 |     | //    The values 'integral0' and 'integral1' are stored among the dynamic
  676 |     | //    parameters. This is because storing and updating them with every swap is
  677 |     | //    more gas efficient than recalculating them.
  678 |     | //
  679 |     | //    To summarize, in order to execute a swap,
  680 |     | //
  681 |     | //      - the function 'w' is formed by reading the members of the curve
  682 |     | //        sequence from the protocol's storage,
  683 |     | //   
  684 |     | //      - the kernel function 'k' is formed by reading its breakpoints from the
  685 |     | //        pool's storage smart contract, and
  686 |     | //
  687 |     | //      - the outgoing amount from the pool and the incoming amount to the pool
  688 |     | //        are determined by integrating the liquidity distribution function
  689 |     | //        'k(w(.))'.
  690 |     | //
  691 |     | //    An alternative way to look at the notion of liquidity distribution is to
  692 |     | //    imagine a traditional automated market making (AMM) diagram as
  693 |     | //    illustrated below:
  694 |     | //
  695 |     | //                tag1   pUpper
  696 |     | //                  ^   /
  697 |     | //                  |  /
  698 |     | //                  | /
  699 |     | //                  *
  700 |     | //                  |.
  701 |     | //                  | .
  702 |     | //                  |  .    
  703 |     | //                  |   .           pCurrent
  704 |     | //                  |     .        /
  705 |     | //                  |       .     /
  706 |     | //                  |         .  /           pTarget
  707 |     | //        integral1 + - - - - - *           /
  708 |     | //                  |           |  .       /         pLower
  709 |     | //                  |           |     .   /         /
  710 |     | //                  |           |        *         /
  711 |     | //                  |           |            .    /
  712 |     | //                  +-----------+----------------*----> tag0
  713 |     | //                              |
  714 |     | //                          integral0 
  715 |     | //
  716 |     | //    where the horizontal and vertical coordinates, respectively, correspond
  717 |     | //    to the reserves of 'tag0' and 'tag1', in the active liquidity interval.
  718 |     | //
  719 |     | //    Remember that the current reserve of 'tag0' in '[qLower, qUpper]' is
  720 |     | //    proportional to 'integral0' and the current reserve of 'tag1' in the same
  721 |     | //    interval is proportional to 'integral1'. Because of this, the point
  722 |     | //    '(integral0, integral1)' in the above diagram is indicated as 'pCurrent'
  723 |     | //    which is the current price of the pool. As a result, '0 - pCurrent' is
  724 |     | //    equal to the slope of the diagram at the point '(integral0, integral1)'.
  725 |     | //    
  726 |     | //    A swapper is permitted to move to any point that belongs to the above
  727 |     | //    diagram by giving or taking appropriate amounts of 'tag0' and 'tag1'.
  728 |     | //    When a swapper moves on the above diagram we calculate the outgoing and
  729 |     | //    incoming amounts of 'tag0' and 'tag1' by computing the two integrals
  730 |     | //    'currentToTarget' and 'incomingCurrentToTarget'. In short, the shape of
  731 |     | //    the above diagram is determined by the liquidity distribution function
  732 |     | //    'k(w(.))'.
  733 |     | //
  734 |     | //    As we will discuss later in this script, after a movement to 'pTarget',
  735 |     | //    the curve sequence is amended in preparation for the next swap which
  736 |     | //    renders a different liquidity distribution function. Such amendment also
  737 |     | //    leads to a new AMM diagram with the following properties:
  738 |     | //
  739 |     | //    - The new diagram intersects with the old one at the point 'pTarget'.
  740 |     | //      This is due to the conservation of interval reserves.
  741 |     | //
  742 |     | //    - The new diagram is tangent to the old one at point 'pTarget'. This is
  743 |     | //      because our transition to a new AMM diagram should not change the price
  744 |     | //      of the pool, i.e., the slopes of the new diagrams should be the same as
  745 |     | //      the old diagrams at the intersection point which means that the two are
  746 |     | //      tangent.
  747 |     | //
  748 |     | //    The proposed structure for the kernel function enables the pool creators
  749 |     | //    to build custom AMM diagrams. Additionally, the proposed structure for
  750 |     | //    the curve sequence allows the protocol to keep track of AMM diagrams,
  751 |     | //    efficiently. In other words, the curve sequence and the kernel function
  752 |     | //    provide us with an efficient method to store the geometry of AMM diagrams
  753 |     | //    and to transform them into new ones.
  754 |     | //
  755 |     | //    Now, in order to derive the outgoing and incoming amounts from the
  756 |     | //    integral values 'currentToTarget' and 'incomingCurrentToTarget' we need
  757 |     | //    to access the static parameters that are explained next.
  758 |     | //
  759 |     | //  - The static parameters of the pool are read from the same storage smart 
  760 |     | //    contract whose address is calculated using the dynamic parameter
  761 |     | //    'staticParamsStoragePointer'. This includes the following parameters:
  762 |     | //
  763 |     | //    - 'sqrtOffset': This is the square root of 'pOffset' in 'X127'
  764 |     | //      representation, i.e.,
  765 |     | //
  766 |     | //        'sqrtOffset := (2 ** 127) * sqrt(pOffset)'.
  767 |     | //
  768 |     | //      This value is used frequently for calculating any amount of 'tag1'.
  769 |     | //      Because of this, we calculate it at the time of initialization and
  770 |     | //      store it among the static parameters.
  771 |     | //
  772 |     | //    - 'sqrtInverseOffset': This is the square root of '1 / pOffset' in 'X127'
  773 |     | //      representation, i.e.,
  774 |     | //
  775 |     | //        'sqrtInverseOffset := (2 ** 127) / sqrt(pOffset)'
  776 |     | //
  777 |     | //      This value is used frequently for calculating any amount of 'tag0'.
  778 |     | //      Because of this, we calculate it at the time of initialization and
  779 |     | //      store it among the static parameters.
  780 |     | //
  781 |     | //    - 'outgoingMax': This value is a kernel parameter in 'X216'
  782 |     | //      representation which is defined as follows:
  783 |     | //
  784 |     | //                             - 8     / qSpacing
  785 |     | //          outgoingMax      e        |    - h / 2
  786 |     | //        '------------- := ------- * |  e         k(h) dh'.
  787 |     | //           2 ** 216          2      |
  788 |     | //                                   / 0
  789 |     | //
  790 |     | //      'outgoingMax' is used frequently for calculating any amount of 'tag0'
  791 |     | //      and 'tag1'. Because of this, we calculate 'outgoingMax' and its modular
  792 |     | //      inverse at the time of initialization or anytime that the kernel
  793 |     | //      function is modified and then we store the resulting values among the
  794 |     | //      static parameters.
  795 |     | //
  796 |     | //      Now, we have all of the parameters that are needed to calculate the
  797 |     | //      outgoing amount from the pool and the incoming amount to the pool as
  798 |     | //      long as we remain within the current active liquidity interval.
  799 |     | //
  800 |     | //      For a price increasing swap we have:
  801 |     | //                                                               growth
  802 |     | //        'amount0Partial := sqrtInverseOffset * sharesTotal * ---------- * 
  803 |     | //                                                              2 ** 111
  804 |     | //                            currentToTarget
  805 |     | //                           -----------------',
  806 |     | //                              outgoingMax
  807 |     | //                                                        growth
  808 |     | //        'amount1Partial := sqrtOffset * sharesTotal * ---------- * 
  809 |     | //                                                       2 ** 111
  810 |     | //                            incomingCurrentToTarget
  811 |     | //                           -------------------------',
  812 |     | //                                  outgoingMax
  813 |     | //
  814 |     | //      where 'amount0Partial' denotes the amount of outgoing 'tag0' from the
  815 |     | //      pool and 'amount1Partial' denotes the amount of incoming 'tag1' to the
  816 |     | //      pool, as a result of swapping within the active liquidity interval,
  817 |     | //      where both of the amounts are in 'X127' representation.
  818 |     | //
  819 |     | //      Similarly, for a price decreasing swap we have:
  820 |     | //                                                               growth
  821 |     | //        'amount0Partial := sqrtInverseOffset * sharesTotal * ---------- * 
  822 |     | //                                                              2 ** 111
  823 |     | //                            incomingCurrentToTarget
  824 |     | //                           -------------------------',
  825 |     | //                                  outgoingMax
  826 |     | //                                                        growth
  827 |     | //        'amount1Partial := sqrtOffset * sharesTotal * ---------- * 
  828 |     | //                                                       2 ** 111
  829 |     | //                            currentToTarget
  830 |     | //                           -----------------',
  831 |     | //                              outgoingMax
  832 |     | //
  833 |     | //      where 'amount0Partial' denotes the amount of incoming 'tag0' to the
  834 |     | //      pool and 'amount1Partial' denotes the amount of outgoing 'tag1' from
  835 |     | //      the pool, as a result of swapping within the active liquidity interval,
  836 |     | //      where both of the amounts are in 'X127' representation.
  837 |     | //
  838 |     | //    - 'incomingMax': This value is a kernel parameter in 'X216'
  839 |     | //      representation which is defined as follows:
  840 |     | //
  841 |     | //                             - 8 - qSpacing / 2     / qSpacing
  842 |     | //          incomingMax      e                       |    + h / 2
  843 |     | //        '------------- := ---------------------- * |  e         k(h) dh'.
  844 |     | //           2 ** 216                  2             |
  845 |     | //                                                  / 0
  846 |     | //
  847 |     | //      Consider a scenario where the price of the pool is moved all the way
  848 |     | //      from the left interval boundary 'qLower', to the right interval
  849 |     | //      boundary 'qUpper', as part of a swap. In this case, let 
  850 |     | //      'amount0Partial' denote the amount of outgoing 'tag0' from the pool and
  851 |     | //      let 'amount1Partial' denote the amount of incoming 'tag1' to the pool,
  852 |     | //      as a result of swapping within the entire interval, '[qLower, qUpper]'
  853 |     | //      where both of the amounts are in 'X127' representation. Then, we have:
  854 |     | //
  855 |     | //        'amount0Partial ==
  856 |     | //                                             growth
  857 |     | //         sqrtInverseOffset * sharesTotal * ---------- *
  858 |     | //                                            2 ** 111
  859 |     | //
  860 |     | //                            - 8     / qUpper
  861 |     | //           2 ** 216       e        |                     - h / 2
  862 |     | //         ------------- * ------- * |   k(h - qLower) * e         dh ==
  863 |     | //          outgoingMax       2      |
  864 |     | //                                  / qLower
  865 |     | //
  866 |     | //                                             growth
  867 |     | //         sqrtInverseOffset * sharesTotal * ---------- *
  868 |     | //                                            2 ** 111
  869 |     | //
  870 |     | //                            - 8 - qLower / 2     / qSpacing
  871 |     | //           2 ** 216       e                     |            - h / 2
  872 |     | //         ------------- * -------------------- * |   k(h) * e         dh ==
  873 |     | //          outgoingMax              2            |
  874 |     | //                                               / 0
  875 |     | //
  876 |     | //                                             growth       - qLower / 2
  877 |     | //         sqrtInverseOffset * sharesTotal * ---------- * e              '
  878 |     | //                                            2 ** 111
  879 |     | //
  880 |     | //      and
  881 |     | //
  882 |     | //        'amount1Partial ==
  883 |     | //                                      growth
  884 |     | //         sqrtOffset * sharesTotal * ---------- *
  885 |     | //                                     2 ** 111
  886 |     | //
  887 |     | //                            - 8     / qUpper
  888 |     | //           2 ** 216       e        |                     + h / 2
  889 |     | //         ------------- * ------- * |   k(h - qLower) * e         dh ==
  890 |     | //          outgoingMax       2      |
  891 |     | //                                  / qLower
  892 |     | //
  893 |     | //                                      growth       2 ** 216
  894 |     | //         sqrtOffset * sharesTotal * ---------- * ------------- * 
  895 |     | //                                     2 ** 111     outgoingMax
  896 |     | //
  897 |     | //            - 8 + (qUpper - qSpacing) / 2     / qSpacing
  898 |     | //          e                                  |            + h / 2
  899 |     | //         --------------------------------- * |   k(h) * e         dh ==
  900 |     | //                         2                   |
  901 |     | //                                            / 0
  902 |     | //
  903 |     | //                                      growth
  904 |     | //         sqrtOffset * sharesTotal * ---------- * 
  905 |     | //                                     2 ** 111
  906 |     | //
  907 |     | //          incomingMax      + qUpper / 2
  908 |     | //         ------------- * e              '.
  909 |     | //          outgoingMax
  910 |     | //
  911 |     | //      Consider another scenario where the price of the pool is moved all the
  912 |     | //      way from the right interval boundary 'qUpper', to the left interval
  913 |     | //      boundary 'qLower', as part of a swap. In this case, let
  914 |     | //      'amount1Partial' denote the amount of outgoing 'tag1' from the pool and
  915 |     | //      let 'amount0Partial' denote the amount of incoming 'tag0' to the
  916 |     | //      pool, as a result of swapping within the the entire interval,
  917 |     | //      '[qLower, qUpper]' where both of the amounts are in 'X127'
  918 |     | //      representation. Then, we have:
  919 |     | //
  920 |     | //        'amount1Partial ==
  921 |     | //                                      growth
  922 |     | //         sqrtOffset * sharesTotal * ---------- *
  923 |     | //                                     2 ** 111
  924 |     | //
  925 |     | //                            - 8     / qUpper
  926 |     | //           2 ** 216       e        |                     + h / 2
  927 |     | //         ------------- * ------- * |   k(qUpper - h) * e         dh ==
  928 |     | //          outgoingMax       2      |
  929 |     | //                                  / qLower
  930 |     | //
  931 |     | //                                      growth
  932 |     | //         sqrtOffset * sharesTotal * ---------- *
  933 |     | //                                     2 ** 111
  934 |     | //
  935 |     | //                            - 8 + qUpper / 2     / qSpacing
  936 |     | //           2 ** 216       e                     |            - h / 2
  937 |     | //         ------------- * -------------------- * |   k(h) * e         dh ==
  938 |     | //          outgoingMax              2            |
  939 |     | //                                               / 0
  940 |     | //
  941 |     | //                                      growth       + qUpper / 2
  942 |     | //         sqrtOffset * sharesTotal * ---------- * e              '.
  943 |     | //                                     2 ** 111
  944 |     | //
  945 |     | //      and
  946 |     | //
  947 |     | //        'amount0Partial ==
  948 |     | //                                             growth
  949 |     | //         sqrtInverseOffset * sharesTotal * ---------- *
  950 |     | //                                            2 ** 111
  951 |     | //
  952 |     | //                            - 8     / qUpper
  953 |     | //           2 ** 216       e        |                     - h / 2
  954 |     | //         ------------- * ------- * |   k(qUpper - h) * e         dh ==
  955 |     | //          outgoingMax       2      |
  956 |     | //                                  / qLower
  957 |     | //
  958 |     | //                                             growth       2 ** 216
  959 |     | //         sqrtInverseOffset * sharesTotal * ---------- * ------------- * 
  960 |     | //                                            2 ** 111     outgoingMax
  961 |     | //
  962 |     | //            - 8 - (qLower + qSpacing) / 2     / qSpacing
  963 |     | //          e                                  |            + h / 2
  964 |     | //         --------------------------------- * |   k(h) * e         dh ==
  965 |     | //                          2                  |
  966 |     | //                                            / 0
  967 |     | //
  968 |     | //                                             growth
  969 |     | //         sqrtInverseOffset * sharesTotal * ---------- * 
  970 |     | //                                            2 ** 111
  971 |     | //
  972 |     | //          incomingMax      - qLower / 2
  973 |     | //         ------------- * e              '.
  974 |     | //          outgoingMax
  975 |     | //
  976 |     | //      Hence, in order to facilitate the calculation of 'amount0Partial' and
  977 |     | //      'amount1Partial' in such scenarios, we calculate 'incomingMax' at the
  978 |     | //      time of initialization or anytime that the kernel function is modified
  979 |     | //      and then we store the resulting value among the static parameters.
  980 |     | //
  981 |     | //      Lastly, we are going to prove the inequality
  982 |     | //
  983 |     | //        'incomingMax >= outgoingMax'
  984 |     | //
  985 |     | //      which will be used later in this script. According to the definitions
  986 |     | //      for 'outgoingMax' and 'incomingMax', we have:
  987 |     | //
  988 |     | //                             - 8 - qSpacing / 2     / qSpacing
  989 |     | //          incomingMax      e                       |    + h / 2
  990 |     | //        '------------- := ---------------------- * |  e         k(h) dh
  991 |     | //           2 ** 216                  2             |
  992 |     | //                                                  / 0
  993 |     | //
  994 |     | //                             - 8     / qSpacing
  995 |     | //                           e        |             - (qSpacing - h) / 2
  996 |     | //                       == ------- * |    k(h) * e                      dh
  997 |     | //                             2      |
  998 |     | //                                   / 0
  999 |     | //
 1000 |     | //                             - 8     / qSpacing
 1001 |     | //                           e        |           - h / 2        outgoingMax
 1002 |     | //                       >= ------- * |  k(h) * e         dh == -------------'.
 1003 |     | //                             2      |                           2 ** 216
 1004 |     | //                                   / 0
 1005 |     | //
 1006 |     | //      which is concluded from Hardy–Littlewood inequality and the fact that
 1007 |     | //      'exp(- (qSpacing - h) / 2)' is an increasing rearrangement of
 1008 |     | //      'exp(- h / 2)'.
 1009 |     | //  
 1010 |     | //  - In the previous steps we read the dynamic parameters, the curve sequence,
 1011 |     | //    the kernel function, and the static parameters. The next step is to move
 1012 |     | //    the price towards 'qNext' until any of the following conditions are met:
 1013 |     | //
 1014 |     | //    (a) 'amountSpecified' is fulfilled, after which the swap is halted.
 1015 |     | //
 1016 |     | //    (b) 'qLimit' is reached, after which the swap is halted.
 1017 |     | //
 1018 |     | //    (c) 'qNext' is reached, after which we transition to a new interval.
 1019 |     | //
 1020 |     | //    Before doing so, we need to verify the condition,
 1021 |     | //
 1022 |     | //      'sharesTotal >= crossThreshold'.
 1023 |     | //
 1024 |     | //    If true, we move the price within the current interval, if not we halt
 1025 |     | //    the swap.
 1026 |     | //
 1027 |     | //    As we move the price from 'qCurrent' towards 'qNext', the integrals
 1028 |     | //    'currentToTarget' and 'incomingCurrentToTarget' are continuously
 1029 |     | //    incremented as they are cumulatively calculated piece by piece. This
 1030 |     | //    process involves exploring the liquidity distribution function 'k(w(h))'
 1031 |     | //    within the active liquidity interval. Since 'k(w(.))' is a piecewise
 1032 |     | //    linear function, we proceed piece by piece and we increment both
 1033 |     | //    'currentToTarget' and 'incomingCurrentToTarget' as we move forward. The
 1034 |     | //    process of exploring 'k(w(.))' is explained later in this script and in
 1035 |     | //    'Interval.sol'.
 1036 |     | //
 1037 |     | //    In the present example, since 'zeroForOne == True' and
 1038 |     | //    'amountSpecified == +oo > 0', we have:
 1039 |     | //
 1040 |     | //      'zeroForOne == exactInput'
 1041 |     | //
 1042 |     | //    which indicates that 'amountSpecified' is with respect to 'tag0'.
 1043 |     | //
 1044 |     | //    Remember that for price decreasing swaps (as is the case in this
 1045 |     | //    example), as long as we remain within the current active liquidity
 1046 |     | //    interval, the amount of incoming 'tag0' is calculated as:
 1047 |     | //
 1048 |     | //                                                             growth
 1049 |     | //      'amount0Partial == sqrtInverseOffset * sharesTotal * ---------- * 
 1050 |     | //                                                            2 ** 111
 1051 |     | //                          incomingCurrentToTarget
 1052 |     | //                         -------------------------',
 1053 |     | //                                outgoingMax
 1054 |     | //
 1055 |     | //    which means that in order for us to meet the stopping criteria (a), we
 1056 |     | //    should have:
 1057 |     | //                                                                growth
 1058 |     | //      '|amountSpecified| == sqrtInverseOffset * sharesTotal * ---------- * 
 1059 |     | //                                                               2 ** 111
 1060 |     | //                             incomingCurrentToTarget
 1061 |     | //                            -------------------------',
 1062 |     | //                                   outgoingMax
 1063 |     | //    or equivalently,
 1064 |     | //
 1065 |     | //      'incomingCurrentToTarget == 
 1066 |     | //
 1067 |     | //                      |amountSpecified|          1          2 ** 111
 1068 |     | //       outgoingMax * ------------------- * ------------- * ----------'.
 1069 |     | //                      sqrtInverseOffset     sharesTotal      growth
 1070 |     | //
 1071 |     | //    As we increment 'currentToTarget' and 'incomingCurrentToTarget' by
 1072 |     | //    moving towards 'qNext', at every step (i.e., with each piece of the
 1073 |     | //    liquidity distribution function 'k(w(.))') we need to determine whether
 1074 |     | //    'amountSpecified' is fulfilled or not. To that end, before starting the
 1075 |     | //    exploration, the protocol calculates the right hand side of the above
 1076 |     | //    equation, i.e.,
 1077 |     | //
 1078 |     | //                      |amountSpecified|          1          2 ** 111
 1079 |     | //       outgoingMax * ------------------- * ------------- * ----------'.
 1080 |     | //                      sqrtInverseOffset     sharesTotal      growth
 1081 |     | //
 1082 |     | //    which is regarded as 'integralLimit', and stores its 'X216'
 1083 |     | //    representation in the memory space which is pointed to by
 1084 |     | //    '_integralLimit_'.
 1085 |     | //
 1086 |     | //    Consider a hypothetical swap for which 'exactInput == false'. Then, every
 1087 |     | //    time that we increment 'currentToTarget', we check whether it has
 1088 |     | //    exceeded 'integralLimit'. Once it has, we use the method
 1089 |     | //    'searchOutgoingTarget' in 'Interval.sol' to find the precise value
 1090 |     | //
 1091 |     | //      'qTarget := log(pTarget / pOffset)'
 1092 |     | //
 1093 |     | //    in order to have
 1094 |     | //
 1095 |     | //      'currentToTarget == integralLimit'
 1096 |     | //
 1097 |     | //    which guarantees that 'amountSpecified' is fulfilled.
 1098 |     | //
 1099 |     | //    If 'exactInput == true', as is the case in our current example, every
 1100 |     | //    time that we increment 'incomingCurrentToTarget', we check whether it has
 1101 |     | //    exceeded 'integralLimit'. Once it has, we use the method
 1102 |     | //    'searchIncomingTarget' in 'Interval.sol' to find the precise value
 1103 |     | //
 1104 |     | //      'qTarget := log(pTarget / pOffset)'
 1105 |     | //
 1106 |     | //    in order to have
 1107 |     | //
 1108 |     | //      'incomingCurrentToTarget == integralLimit'
 1109 |     | //
 1110 |     | //    which guarantees that 'amountSpecified' is fulfilled.
 1111 |     | //
 1112 |     | //    After either of the above searches, the price of the pool is moved to
 1113 |     | //    'qTarget' and the corresponding outgoing and incoming amounts are
 1114 |     | //    calculated.
 1115 |     | //
 1116 |     | //    Throughout the execution of the swap, whenever we enter a new liquidity
 1117 |     | //    interval, both 'amountSpecified' and 'integralLimit' are updated. This is
 1118 |     | //    further explained in the next step.
 1119 |     | //
 1120 |     | //    However, remember that in the present example, we have
 1121 |     | //    'amountSpecified == +oo' which means that:
 1122 |     | //
 1123 |     | //      'integralLimit := outgoingMax * 
 1124 |     | //
 1125 |     | //        |amountSpecified|          1          2 ** 111
 1126 |     | //       ------------------- * ------------- * ---------- == +oo'.
 1127 |     | //        sqrtInverseOffset     sharesTotal      growth
 1128 |     | //
 1129 |     | //    Hence, 'incomingCurrentToTarget' may never exceed 'integralLimit' and the
 1130 |     | //    stopping criteria (a) is not reachable. Put simply, since
 1131 |     | //    'amountSpecified' is equal to infinity, we may never reach it and we only
 1132 |     | //    need to worry about 'qLimit' and 'qNext'.
 1133 |     | //
 1134 |     | //    In order to keep track of (b) and (c) concurrently, the protocol
 1135 |     | //    calculates
 1136 |     | //
 1137 |     | //      'qLimitWithinInterval := min(max(qLower, qLimit), qUpper)'
 1138 |     | //
 1139 |     | //    and stores it in the memory space which is referred to by
 1140 |     | //    '_logPriceLimitOffsettedWithinInterval_'. As we move forward with pieces
 1141 |     | //    of the liquidity distribution function, we continuously check whether
 1142 |     | //    'qLimitWithinInterval' is reached. If so, we either need to halt the swap
 1143 |     | //    (stopping criteria (b)) or transition to a new interval (stopping
 1144 |     | //    criteria (c)).
 1145 |     | //
 1146 |     | //    In our example, it can be easily observed that
 1147 |     | //
 1148 |     | //      'qLimitWithinInterval == qNext'
 1149 |     | //
 1150 |     | //    as illustrated below:
 1151 |     | //
 1152 |     | //                                             qLimitWithinInterval
 1153 |     | //                                                      |
 1154 |     | //                  qLimit                              |  qCurrent
 1155 |     | //                     |                                |     |
 1156 |     | //     ... <--+-------------+-------------+-------------+-------------+--> ...
 1157 |     | //                                                      |             |
 1158 |     | //                                                    qNext         qBack
 1159 |     | //
 1160 |     | //    Hence, in the present active liquidity interval, we do not need to worry
 1161 |     | //    about 'qLimit' either and we can move forward until we reach 'qNext'.
 1162 |     | //    After that, we need to update a number of parameters, including:
 1163 |     | //
 1164 |     | //    - 'amount0': This is the total amount of 'tag0' which is traded as a
 1165 |     | //      result of this swap. In this example, since our swap is price
 1166 |     | //      decreasing, we should have 'amount0 > 0' which indicates that 'amount0'
 1167 |     | //      is incoming to the pool. Hence, according to the above formulas, with
 1168 |     | //      each interval that we transact in, 'amount0' should be incremented by:
 1169 |     | //
 1170 |     | //                                                               growth
 1171 |     | //        'amount0Partial := sqrtInverseOffset * sharesTotal * ---------- *
 1172 |     | //                                                              2 ** 111
 1173 |     | //                            incomingCurrentToTarget
 1174 |     | //                           -------------------------'
 1175 |     | //                                  outgoingMax
 1176 |     | //
 1177 |     | //    - 'amount1': This is the total amount of 'tag1' which is traded as a
 1178 |     | //      result of this swap. In this example, since our swap is price
 1179 |     | //      decreasing, we should have 'amount1 < 0' which indicates that 'amount1'
 1180 |     | //      is outgoing from the pool. Hence, according to the above formulas, with
 1181 |     | //      each interval that we transact in, 'amount1' should be decremented by:
 1182 |     | //
 1183 |     | //                                                        growth
 1184 |     | //        'amount1Partial := sqrtOffset * sharesTotal * ---------- *
 1185 |     | //                                                       2 ** 111
 1186 |     | //                            currentToTarget
 1187 |     | //                           -----------------'
 1188 |     | //                              outgoingMax
 1189 |     | //
 1190 |     | //    - 'amountSpecified': Since the swap is partially fulfilled, we should
 1191 |     | //      decrement 'amountSpecified' by 'amount0Partial' to reflect this:
 1192 |     | //
 1193 |     | //        'amountSpecified -= amount0Partial'.
 1194 |     | //
 1195 |     | //    - 'curve': As explained before, when we transact in a liquidity interval,
 1196 |     | //      as part of a swap, we then need to amend the curve sequence for that
 1197 |     | //      interval in preparation for the next swap. In this example, the
 1198 |     | //      amendment is straightforward. Since we are about to transition out of
 1199 |     | //      the interval '[qLower, qUpper]', it should turn into an inactive
 1200 |     | //      interval. Hence, the corresponding curve sequence for this interval
 1201 |     | //      should transform into a sequence of length two as is the case for every
 1202 |     | //      inactive liquidity interval. Following the pattern that was introduced
 1203 |     | //      earlier for inactive liquidity intervals, the amended curve sequence
 1204 |     | //      for '[qLower, qUpper]' should be:
 1205 |     | //
 1206 |     | //        'q[0] := qUpper',
 1207 |     | //        'q[1] := qLower'.
 1208 |     | //
 1209 |     | //      This amendment, transforms the function 'w' associated with
 1210 |     | //      '[qLower, qUpper]' from the following:
 1211 |     | //
 1212 |     | //            w(q)
 1213 |     | //              ^
 1214 |     | //      spacing |                /
 1215 |     | //              |               /
 1216 |     | //              |              /
 1217 |     | //              |             /
 1218 |     | //              |            /
 1219 |     | //              |           /
 1220 |     | //              |          /
 1221 |     | //              |\
 1222 |     | //              | \
 1223 |     | //              |  \
 1224 |     | //              |   \
 1225 |     | //              |        /
 1226 |     | //              |       /
 1227 |     | //              |      /
 1228 |     | //              |     /
 1229 |     | //            0 +----+----+-------+-> q
 1230 |     | //           qLower  |    |       |
 1231 |     | //                   |   q[2]  qUpper
 1232 |     | //                   |
 1233 |     | //               qCurrent
 1234 |     | //
 1235 |     | //      to a new function:
 1236 |     | //
 1237 |     | //        'wAmended(q) := q - qLower'
 1238 |     | //
 1239 |     | //      which can be plotted as follows:
 1240 |     | //
 1241 |     | //          wAmended(q)
 1242 |     | //              ^
 1243 |     | //      spacing |                /
 1244 |     | //              |               /
 1245 |     | //              |              /
 1246 |     | //              |             /
 1247 |     | //              |            /
 1248 |     | //              |           /
 1249 |     | //              |          /
 1250 |     | //              |         /
 1251 |     | //              |        /
 1252 |     | //              |       /
 1253 |     | //              |      /
 1254 |     | //              |     /
 1255 |     | //              |    /
 1256 |     | //              |   /
 1257 |     | //              |  /
 1258 |     | //              | /
 1259 |     | //              |/
 1260 |     | //            0 +-----------------+-> q
 1261 |     | //           qLower               |
 1262 |     | //                             qUpper
 1263 |     | //
 1264 |     | //      As we will demonstrate next, this procedure results in positive growth
 1265 |     | //      for liquidity providers.
 1266 |     | //
 1267 |     | //    - 'growth': As discussed earlier, before transitioning out of the
 1268 |     | //      interval '[qLower, qUpper]', the curve sequence for this interval is
 1269 |     | //      amended. This action, changes the function 'w' to 'wAmended' which in
 1270 |     | //      turn changes the liquidity distribution function from 'k(w(.))' to
 1271 |     | //      'k(wAmended(.))'. However, the amount of reserve for 'tag0' within
 1272 |     | //      '[qLower, qUpper]' should stay the same before and after the amendment
 1273 |     | //      of the curve sequence. This is because modifying the curve sequence is
 1274 |     | //      a change in our trading policy and it does not introduce or remove any
 1275 |     | //      amount of liquidity. Hence, in order to conserve the amount of 'tag0'
 1276 |     | //      within '[qLower, qUpper]' despite the transformation of 'w' to
 1277 |     | //      'wAmended', we need to make an adjustment to the 'growth' value and
 1278 |     | //      turn it into 'growthAmended'. In order to determine 'growthAmended',
 1279 |     | //      the following equation is solved:
 1280 |     | //
 1281 |     | //        'totalReserveOfTag0Before == totalReserveOfTag0After'
 1282 |     | //
 1283 |     | //      where 'totalReserveOfTag0Before' is the total amount of 'tag0' within
 1284 |     | //      '[qLower, qUpper]' which is calculated based on 'k(w(.))', whereas
 1285 |     | //      'totalReserveOfTag0After' is the same value calculated based on
 1286 |     | //      'k(wAmended(.))'. The two sides of the equation can be derived as:
 1287 |     | //
 1288 |     | //        'totalReserveOfTag0Before = sqrtInverseOffset * sharesTotal * 
 1289 |     | //
 1290 |     | //                                         - 8     / qUpper
 1291 |     | //           growth       2 ** 216       e        |    - h / 2
 1292 |     | //         ---------- * ------------- * ------- * |  e         k(w(h)) dh',
 1293 |     | //          2 ** 111     outgoingMax       2      |
 1294 |     | //                                               / qLower
 1295 |     | //
 1296 |     | //        'totalReserveOfTag0After = sqrtInverseOffset * sharesTotal * 
 1297 |     | //
 1298 |     | //          growthAmended       2 ** 216
 1299 |     | //         --------------- * ------------- *
 1300 |     | //             2 ** 111       outgoingMax
 1301 |     | //
 1302 |     | //            - 8     / qUpper
 1303 |     | //          e        |    - h / 2
 1304 |     | //         ------- * |  e         k(wAmended(h)) dh',
 1305 |     | //            2      |
 1306 |     | //                  / qLower
 1307 |     | //
 1308 |     | //      Hence, 'growthAmended' can be derived as:
 1309 |     | //
 1310 |     | //                                           / qUpper
 1311 |     | //                                          |    - h / 2
 1312 |     | //                                          |  e         k(w(h)) dh
 1313 |     | //                                          |
 1314 |     | //                                         / qLower
 1315 |     | //        'growthAmended == growth * ---------------------------------'.
 1316 |     | //                                       / qUpper
 1317 |     | //                                      |    - h / 2
 1318 |     | //                                      |  e         k(wAmended(h)) dh
 1319 |     | //                                      |
 1320 |     | //                                     / qLower
 1321 |     | //
 1322 |     | //      Observe that 'wAmended' is a monotonically non-decreasing rearrangement
 1323 |     | //      of 'w'. This is because pieces of 'wAmended' can be flipped and
 1324 |     | //      rearranged in order to transform its diagram to the diagram of 'w'. On
 1325 |     | //      the other hand, since 'k' is a monotonically non-decreasing function,
 1326 |     | //      we can conclude that 'k(wAmended(.))' is a monotonically non-decreasing
 1327 |     | //      rearrangement of 'k(w(.))'. Hence, according to the Hardy–Littlewood
 1328 |     | //      inequality, we have:
 1329 |     | //
 1330 |     | //            / qUpper                             / qUpper
 1331 |     | //           |    - h / 2                         |    - h / 2
 1332 |     | //        '  |  e         k(wAmended(h)) dh  <=   |  e         k(w(h)) dh '
 1333 |     | //           |                                    |
 1334 |     | //          / qLower                             / qLower
 1335 |     | //      
 1336 |     | //      which concludes that:
 1337 |     | //
 1338 |     | //        'growthAmended >= growth'.
 1339 |     | //
 1340 |     | //      This is exactly what we want!
 1341 |     | //
 1342 |     | //      To summarize, when we transact in a liquidity interval as part of a
 1343 |     | //      swap, we then need to amend the curve sequence for that interval. After
 1344 |     | //      that, in order to make up for the transformation of 'w' to 'wAmended',
 1345 |     | //      the 'growth' value should be incremented according to the above formula
 1346 |     | //      for 'growthAmended'.
 1347 |     | //
 1348 |     | //    - 'qCurrent': Lastly, as we move the price of the pool to 'qNext', the
 1349 |     | //      value for 'qCurrent' should be updated to reflect this change. which is
 1350 |     | //      illustrated as follows:
 1351 |     | //
 1352 |     | //                qLimit                              qCurrent
 1353 |     | //                   |                                   |
 1354 |     | //      ... <--+-------------+-------------+-------------+-------------+--> ...
 1355 |     | //                                                       |             |
 1356 |     | //                                                     qNext         qBack
 1357 |     | //    
 1358 |     | //    Now, we are ready to transition out of the interval '[qLower, qUpper]'
 1359 |     | //    which is explained next.
 1360 |     | //
 1361 |     | //  - In the previous step we moved the price of the pool to 'qNext' to
 1362 |     | //    partially fulfill the requested swap. In this step, we transition from
 1363 |     | //    the original liquidity interval '[qLower, qUpper]' to its adjacent
 1364 |     | //    interval '[qLower - qSpacing, qUpper - qSpacing]'. This transition
 1365 |     | //    involves updating the following parameters:
 1366 |     | //
 1367 |     | //    - 'sharesTotal': The current value of 'sharesTotal' reflects the total
 1368 |     | //      number of shares within '[qLower, qUpper]'. As we are transitioning to
 1369 |     | //      '[qLower - qSpacing, qUpper - qSpacing]', this value should be modified
 1370 |     | //      in order to reflect the total number of shares in the new active
 1371 |     | //      interval.
 1372 |     | //
 1373 |     | //      We keep track of the total share values in all of the liquidity
 1374 |     | //      intervals via the mapping 'sharesDelta' within protocol's storage. Let
 1375 |     | //      'qBoundary' denote an arbitrary boundary for a liquidity interval,
 1376 |     | //      i.e.,
 1377 |     | //
 1378 |     | //        'qBoundary == qLower + j * qSpacing'
 1379 |     | //
 1380 |     | //      for some integer 'j'. Let 'sharesTotalLeft' and 'sharesTotalRight'
 1381 |     | //      denote the total number of shares within the intervals
 1382 |     | //
 1383 |     | //        '[qBoundary - qSpacing, qBoundary]' and
 1384 |     | //        '[qBoundary, qBoundary + qSpacing]',
 1385 |     | //
 1386 |     | //      respectively. Define:
 1387 |     | //
 1388 |     | //        'sharesDelta[qBoundary] := sharesTotalRight - sharesTotalLeft'.
 1389 |     | //
 1390 |     | //      In other words, 'sharesDelta[qBoundary]' is defined as the difference
 1391 |     | //      between the total number of shares within the two liquidity intervals
 1392 |     | //      that contain 'qBoundary'.
 1393 |     | //
 1394 |     | //      Hence, for price increasing swaps, as we transition to a new interval,
 1395 |     | //      'sharesTotal' should be modified as follows:
 1396 |     | //
 1397 |     | //        'sharesTotal += sharesDelta[qNext]',
 1398 |     | //
 1399 |     | //      and for price decreasing swaps, as we transition to a new interval,
 1400 |     | //      'sharesTotal' should be modified as follows:
 1401 |     | //
 1402 |     | //        'sharesTotal -= sharesDelta[qNext]'.
 1403 |     | //
 1404 |     | //      This way of accounting for the total shares makes liquidity deposit or
 1405 |     | //      withdrawal by LPs more efficient. Imagine an example where an LP
 1406 |     | //      intends to deposit '100' shares in every interval within the range
 1407 |     | //      'qLower - i * qSpacing' to 'qUpper + j * qSpacing', where 'i' and 'j'
 1408 |     | //      are arbitrary non-negative integers. In this case, we need to add '100'
 1409 |     | //      shares to every one of the following intervals:
 1410 |     | //
 1411 |     | //        '[qLower - i * qSpacing, qUpper - i * qSpacing]',
 1412 |     | //          .
 1413 |     | //          .
 1414 |     | //          .
 1415 |     | //        '[qLower - 1 * qSpacing, qUpper - 1 * qSpacing]',
 1416 |     | //        '[qLower               , qUpper               ]',
 1417 |     | //        '[qLower + 1 * qSpacing, qUpper + 1 * qSpacing]',
 1418 |     | //          .
 1419 |     | //          .
 1420 |     | //          .
 1421 |     | //        '[qLower + j * qSpacing, qUpper + j * qSpacing]'.
 1422 |     | //
 1423 |     | //      However, it may not be efficient or even possible to enumerated every
 1424 |     | //      single one of the 'i + j + 1' intervals and thanks to 'sharesDelta', we
 1425 |     | //      do not need to do that! Alternatively, in order to account for the
 1426 |     | //      additional '100' shares, the protocol:
 1427 |     | //
 1428 |     | //      - increments 'sharesDelta[qLower - i * qSpacing]' by '100',
 1429 |     | //
 1430 |     | //      - increments 'sharesTotal' by '100',
 1431 |     | //
 1432 |     | //      - decrements 'sharesDelta[qUpper + j * qSpacing]' by '100',
 1433 |     | //
 1434 |     | //      which is sufficient to updated the total number of shares in every
 1435 |     | //      liquidity interval within the intended range.
 1436 |     | //
 1437 |     | //    - 'growth': In the prior step, we updated the content of the memory space
 1438 |     | //      which is pointed to by '_growth_', according to the following formula:
 1439 |     | //
 1440 |     | //                                          / qUpper
 1441 |     | //                                         |    - h / 2
 1442 |     | //                                         |  e         k(w(h)) dh
 1443 |     | //                                         |
 1444 |     | //                                        / qLower
 1445 |     | //        'growthAmended == growth * ----------------------------------'.
 1446 |     | //                                       / qUpper
 1447 |     | //                                      |    - h / 2
 1448 |     | //                                      |  e         k(wAmended(h)) dh
 1449 |     | //                                      |
 1450 |     | //                                     / qLower
 1451 |     | //
 1452 |     | //      Hence, the current value stored in this memory space reflects the
 1453 |     | //      updated liquidity growth within '[qLower, qUpper]' (as a result of the
 1454 |     | //      partial swap that moved the price to 'qNext').
 1455 |     | //
 1456 |     | //      Now, as we are transitioning out of '[qLower, qUpper]', 'growthAmended'
 1457 |     | //      which currently resides in the memory has to be written somewhere in
 1458 |     | //      the protocol's storage, and then the amount of liquidity growth within
 1459 |     | //
 1460 |     | //        '[qLower - qSpacing, qUpper - qSpacing]'
 1461 |     | //
 1462 |     | //      should be loaded in the memory so that we can transact within this new
 1463 |     | //      interval.
 1464 |     | //
 1465 |     | //      We keep track of these 'growth' values for all of the liquidity
 1466 |     | //      intervals, via the mapping 'growthMultiplier'. For every integer 'm',
 1467 |     | //      let 'growth(m)' denote the 'growth' value for the interval
 1468 |     | //
 1469 |     | //        '[qLower + m * qSpacing, qUpper + m * qSpacing]'.
 1470 |     | //
 1471 |     | //      Hence, 'growth(0)' corresponds to '[qLower, qUpper]' which is the
 1472 |     | //      current value stored in memory. 
 1473 |     | //
 1474 |     | //      Now, for every integer 'm >= 1' define:
 1475 |     | //
 1476 |     | //          growthMultiplier[qLower + m * qSpacing]
 1477 |     | //        '----------------------------------------- := 
 1478 |     | //                         2 ** 208
 1479 |     | //         ---- +oo
 1480 |     | //         \            growth(+j)      (- qLower - j * qSpacing) / 2
 1481 |     | //         /           ------------ * e                               '.
 1482 |     | //         ---- j = m    2 ** 111
 1483 |     | //
 1484 |     | //      According to the above definition, for every integer 'm >= 1',
 1485 |     | //
 1486 |     | //          sqrtInverseOffset     growthMultiplier[qLower + m * qSpacing]
 1487 |     | //        '------------------- * -----------------------------------------'
 1488 |     | //              2 ** 127                         2 ** 208
 1489 |     | //
 1490 |     | //      is equal to the total amount of 'tag0' corresponding to a single
 1491 |     | //      liquidity provider's share in every interval spanning from
 1492 |     | //      'qLower + m * qSpacing' to '+oo'.
 1493 |     | //
 1494 |     | //      Similarly, for every integer 'm >= 1' define:
 1495 |     | //
 1496 |     | //          growthMultiplier[qUpper - m * qSpacing]
 1497 |     | //        '----------------------------------------- := 
 1498 |     | //                         2 ** 208
 1499 |     | //         ---- +oo
 1500 |     | //         \            growth(-j)      (+ qUpper - j * qSpacing) / 2
 1501 |     | //         /           ------------ * e                               '.
 1502 |     | //         ---- j = m    2 ** 111
 1503 |     | //
 1504 |     | //      According to the above definition, for every integer 'm >= 1',
 1505 |     | //
 1506 |     | //          sqrtOffset     growthMultiplier[qUpper - m * qSpacing]
 1507 |     | //        '------------ * -----------------------------------------'
 1508 |     | //           2 ** 127                     2 ** 208
 1509 |     | //
 1510 |     | //      is equal to the total amount of 'tag1' corresponding to a single
 1511 |     | //      liquidity provider's share in every interval spanning from '-oo' to
 1512 |     | //      'qUpper - m * qSpacing'.
 1513 |     | //
 1514 |     | //      The following illustration further elaborates the notion of 
 1515 |     | //      'growthMultiplier':
 1516 |     | //
 1517 |     | //                                         growthMultiplier[qUpper + qSpacing]
 1518 |     | //                                                                    |-->
 1519 |     | //       growthMultiplier[qLower - qSpacing]                          |
 1520 |     | //           <--|                                                     |
 1521 |     | //              |                        growthMultiplier[qUpper]     |
 1522 |     | //              |                                   |-->              |
 1523 |     | //              |      growthMultiplier[qLower]     |                 |
 1524 |     | //              |              <--|                 |                 |
 1525 |     | //              |                 |     growth      |                 |
 1526 |     | //              |                 |       ==        |                 |
 1527 |     | //              |    growth(-1)   |    growth(0)    |    growth(+1)   |
 1528 |     | //       ... <--+-----------------+-----------------+-----------------+--> ...
 1529 |     | //                                |                 |
 1530 |     | //                              qLower           qUpper
 1531 |     | //
 1532 |     | //      In the above figure, 'growthMultiplier[qUpper]' and
 1533 |     | //      'growthMultiplier[qUpper + qSpacing]' point towards '+oo'. This is
 1534 |     | //      because these two values are proportional to the the amount of 'tag0'
 1535 |     | //      for a single share in every interval within '[qUpper, +oo]' and
 1536 |     | //      '[qUpper + qSpacing, +oo]', respectively. This is also the case for
 1537 |     | //      every 'growthMultiplier[qBoundary]' where 'qBoundary' is on the right
 1538 |     | //      side of the active liquidity interval as it is proportional to the
 1539 |     | //      amount of 'tag0' for a single share in every interval within
 1540 |     | //      '[qBoundary, +oo]'.
 1541 |     | //
 1542 |     | //      On the contrary, 'growthMultiplier[qLower]' and
 1543 |     | //      'growthMultiplier[qLower - qSpacing]' point towards '-oo'. This is
 1544 |     | //      because these two values are proportional to the the amount of 'tag1'
 1545 |     | //      for a single share in every interval within '[-oo, qLower]' and
 1546 |     | //      '[-oo, qLower - qSpacing]', respectively. This is also the case for
 1547 |     | //      every 'growthMultiplier[qBoundary]' where 'qBoundary' is on the left
 1548 |     | //      side of the active liquidity interval as it is proportional to the
 1549 |     | //      amount of 'tag1' for a single share in every interval whithin
 1550 |     | //      '[-oo, qBoundary]'.
 1551 |     | //
 1552 |     | //      Instead of storing the growth value for each inactive interval, the
 1553 |     | //      protocol stores the mapping 'growthMultiplier'.
 1554 |     | //
 1555 |     | //      This way of accounting for the growth values makes liquidity deposit or
 1556 |     | //      withdrawal by LPs more efficient. Imagine an example where an LP
 1557 |     | //      intends to deposit '100' shares in every interval within the range
 1558 |     | //      'qLower + i * qSpacing' to 'qUpper + j * qSpacing', where 'i' and 'j'
 1559 |     | //      are arbitrary positive integers. In this case, we need to calculate the
 1560 |     | //      amount of 'tag0' corresponding to '100' shares in every one of the
 1561 |     | //      following intervals:
 1562 |     | //
 1563 |     | //        '[qLower + i       * qSpacing, qUpper + i       * qSpacing]',
 1564 |     | //        '[qLower + (i + 1) * qSpacing, qUpper + (i + 1) * qSpacing]',
 1565 |     | //          .
 1566 |     | //          .
 1567 |     | //          .
 1568 |     | //        '[qLower + (j - 1) * qSpacing, qUpper + (j - 1) * qSpacing]',
 1569 |     | //        '[qLower + j       * qSpacing, qUpper + j       * qSpacing]'.
 1570 |     | //
 1571 |     | //      However, it may not be efficient or even possible to enumerated every
 1572 |     | //      single one of the 'j - i + 1' intervals and thanks to
 1573 |     | //      'growthMultiplier', we do not need to do that! Alternatively, the
 1574 |     | //      protocol calculates the amount of 'tag0' that needs to be deposited
 1575 |     | //      using the following formula:
 1576 |     | //
 1577 |     | //                sqrtInverseOffset
 1578 |     | //        '100 * ------------------- * (
 1579 |     | //                    2 ** 127
 1580 |     | //
 1581 |     | //                          growthMultiplier[qLower + i * qSpacing]
 1582 |     | //                         ----------------------------------------- - 
 1583 |     | //                                          2 ** 208
 1584 |     | //
 1585 |     | //                          growthMultiplier[qUpper + j * qSpacing]
 1586 |     | //                         -----------------------------------------
 1587 |     | //                                          2 ** 208
 1588 |     | //         )'.
 1589 |     | //
 1590 |     | //      The following figure visualizes the direction of the growth multipliers
 1591 |     | //      prior to the transition from '[qLower, qUpper]' to the new interval
 1592 |     | //      '[qLower - qSpacing, qUpper - qSpacing]':
 1593 |     | //
 1594 |     | //                           growthMultiplier[qCurrent - qSpacing]
 1595 |     | //                                      <--|
 1596 |     | //                                         |            growthMultiplier[qBack]
 1597 |     | //                                         |                           |-->
 1598 |     | //                                         | growthMultiplier[qCurrent]|
 1599 |     | //                                         |          <--|             |
 1600 |     | //                qLimit                   |             |             |
 1601 |     | //                   |                     |  growth(-1) |  growth(0)  |
 1602 |     | //      ... <--+-------------+-------------+-------------+-------------+--> ...
 1603 |     | //                                                       |             |
 1604 |     | //                                                     qNext         qBack
 1605 |     | //                                                       |
 1606 |     | //                                                    qCurrent
 1607 |     | //
 1608 |     | //      where 'growth(0) := growthAmended'. As shown in the above figure,
 1609 |     | //      'growthMultiplier[qBack]' points towards '+oo' because it is on the
 1610 |     | //      right side of the active liquidity interval whereas
 1611 |     | //      'growthMultiplier[qCurrent]' and 'growthMultiplier[qCurrent - qSpacing]'
 1612 |     | //      point towards '-oo' because they are on the left side of the active
 1613 |     | //      liquidity interval.
 1614 |     | //
 1615 |     | //      As part of this interval transition, we need to take the following
 1616 |     | //      steps:
 1617 |     | //      
 1618 |     | //      - 'growth(-1)' is the value which is supposed to replace
 1619 |     | //        'growthAmended' in the memory space which is pointed to by
 1620 |     | //        '_growth_'. However, since the protocol does not store growth values
 1621 |     | //        for inactive intervals, we do not have direct access to 'growth(-1)'.
 1622 |     | //        Because of this, we calculate it via the following formula:
 1623 |     | //
 1624 |     | //            growth(-1)       - qCurrent / 2
 1625 |     | //          '------------ == e                * ( 
 1626 |     | //             2 ** 111
 1627 |     | //
 1628 |     | //             growthMultiplier[qCurrent]
 1629 |     | //            ---------------------------- - 
 1630 |     | //                      2 ** 208
 1631 |     | //
 1632 |     | //             growthMultiplier[qCurrent - qSpacing]
 1633 |     | //            ---------------------------------------
 1634 |     | //                           2 ** 208
 1635 |     | //           )'
 1636 |     | //
 1637 |     | //      - Next, we need to recalculate 'growthMultiplier[qCurrent]' because it
 1638 |     | //        is currently pointing to '-oo' since 'qCurrent' is on the left side
 1639 |     | //        of '[qLower, qUpper]'. However, once we transition, 'qCurrent' would
 1640 |     | //        be on the right side of the active liquidity interval
 1641 |     | //
 1642 |     | //          '[qLower - qSpacing, qUpper - qSpacing]'
 1643 |     | //
 1644 |     | //        which means that it should point to '+oo'. Hence,
 1645 |     | //        'growthMultiplier[qCurrent]' is recalculated via the following
 1646 |     | //        formula:
 1647 |     | //
 1648 |     | //            growthMultiplier[qCurrent]      growthMultiplier[qBack]
 1649 |     | //          '---------------------------- := ------------------------- +
 1650 |     | //                    2 ** 208                       2 ** 208
 1651 |     | //
 1652 |     | //            growthAmended      - qCurrent / 2
 1653 |     | //           --------------- * e                '.
 1654 |     | //              2 ** 111
 1655 |     | //
 1656 |     | //        Observe that according to the above formula, 'growthAmended' is
 1657 |     | //        incorporated into 'growthMultiplier[qCurrent]' which is where it is
 1658 |     | //        kept track of.
 1659 |     | //
 1660 |     | //      The following figure illustrates the above modification of the
 1661 |     | //      'growthMultiplier' mapping:
 1662 |     | //
 1663 |     | //                           growthMultiplier[qCurrent - qSpacing]
 1664 |     | //                                      <--|
 1665 |     | //                                         |            growthMultiplier[qBack]
 1666 |     | //                                         |                           |-->
 1667 |     | //                                         | growthMultiplier[qCurrent]|
 1668 |     | //                                         |             |-->          |
 1669 |     | //                qLimit                   |             |             |
 1670 |     | //                   |                     |             |             |
 1671 |     | //      ... <--+-------------+-------------+-------------+-------------+--> ...
 1672 |     | //                                                       |             |
 1673 |     | //                                                     qNext         qBack
 1674 |     | //                                                       |
 1675 |     | //                                                    qCurrent
 1676 |     | //
 1677 |     | //    - 'qBack' and 'qNext': Since we are dealing with a price decreasing swap,
 1678 |     | //      the values 'qBack' and 'qNext' should be modified as follows in order
 1679 |     | //      to represent the new liquidity interval that we are transitioning to:
 1680 |     | //
 1681 |     | //        'qBack -= qSpacing',
 1682 |     | //        'qNext -= qSpacing'.
 1683 |     | //
 1684 |     | //      which is illustrated below:
 1685 |     | //
 1686 |     | //                qLimit                              qCurrent
 1687 |     | //                   |                                   |
 1688 |     | //      ... <--+-------------+-------------+-------------+-------------+--> ...
 1689 |     | //                                         |             |
 1690 |     | //                                       qNext         qBack
 1691 |     | //    
 1692 |     | //    - 'curve': As we discussed before, since
 1693 |     | //
 1694 |     | //          '[qLower - qSpacing, qUpper - qSpacing]'
 1695 |     | //
 1696 |     | //      is currently inactive, its corresponding curve sequence is composed of
 1697 |     | //      only two members:
 1698 |     | //
 1699 |     | //      'q[0] := qUpper - qSpacing',
 1700 |     | //      'q[1] := qLower - qSpacing'.
 1701 |     | //
 1702 |     | //      As part of the transition, we discard the previous curve sequence and
 1703 |     | //      initiate this above curve sequence in memory.
 1704 |     | //
 1705 |     | //    Now, the transition to '[qLower - qSpacing, qUpper - qSpacing]' is
 1706 |     | //    complete and throughout the remainder of this example, we refer to this
 1707 |     | //    interval as the active liquidity interval. Additionally, we redefine:
 1708 |     | //
 1709 |     | //      'qUpper := qUpper - qSpacing', 
 1710 |     | //      'qLower := qLower - qSpacing'
 1711 |     | //
 1712 |     | //    which allows us to continue using the notation '[qLower, qUpper]' in
 1713 |     | //    order to refer to the active liquidity interval.
 1714 |     | //
 1715 |     | //  - In this step, we need to determine whether we should explore the active
 1716 |     | //    interval '[qLower, qUpper]' or to cross it entirely, i.e., all the way
 1717 |     | //    from 'qBack' to 'qNext'. In the former case, we need to integrate the
 1718 |     | //    liquidity distribution function 'k(w(.))' piece by piece through which
 1719 |     | //    the 'incomingCurrentToTarget' and 'currentToTarget' are calculated. As we
 1720 |     | //    discussed before, the calculation of these integrals leads to
 1721 |     | //    'amount0Partial' and 'amount1Partial', respectively. However, the latter
 1722 |     | //    case is more efficient because if the active interval is crossed 
 1723 |     | //    entirely, then the precalculated integrals 'incomingMax' and
 1724 |     | //    'outgoingMax' can be used to determine 'amount0Partial' and
 1725 |     | //    'amount1Partial'. In order for the protocol to be able to cross the
 1726 |     | //    active interval entirely the following two criteria should be met:
 1727 |     | //
 1728 |     | //    (a) The cross must not violate 'qLimit'. In other words, for price
 1729 |     | //        increasing swaps we should have
 1730 |     | //
 1731 |     | //          'qNext <= qLimit'
 1732 |     | //
 1733 |     | //        and for price decreasing swaps, we should have
 1734 |     | //
 1735 |     | //          'qLimit <= qNext'.
 1736 |     | //
 1737 |     | //        which is the case in the present example.
 1738 |     | //
 1739 |     | //    (b) The cross must not violate 'amountSpecified'. In order words, if
 1740 |     | //        'exactInput == false', then the outgoing amount from the pool as a
 1741 |     | //        result of crossing all the way from 'qBack' to 'qNext' must not
 1742 |     | //        exceed the remaining absolute value '0 - amountSpecified'. Similarly,
 1743 |     | //        if 'exactInput == true', then the incoming amount to the pool as a
 1744 |     | //        result of crossing all the way from 'qBack' to 'qNext' must not
 1745 |     | //        exceed the remaining value 'amountSpecified'.
 1746 |     | //
 1747 |     | //        In order to verify this, we first need to recalculate 'integralLimit'
 1748 |     | //        based on the decremented value for '|amountSpecified|':
 1749 |     | //        
 1750 |     | //          'integralLimit :=
 1751 |     | //
 1752 |     | //                          |amountSpecified|          1          2 ** 111
 1753 |     | //           outgoingMax * ------------------- * ------------- * ----------
 1754 |     | //                          sqrtInverseOffset     sharesTotal      growth
 1755 |     | //
 1756 |     | //           == +oo'.
 1757 |     | //
 1758 |     | //        which remains equal to '+oo' for this example.
 1759 |     | //
 1760 |     | //        Next, we need to define the notion of 'integralLimitInterval' which
 1761 |     | //        is compared with 'integralLimit' in order to determine if
 1762 |     | //        'amountSpecified' is violated or not. Consider the following four
 1763 |     | //        scenarios:
 1764 |     | //
 1765 |     | //        - If the swap is price increasing and 'exactInput == false', define:
 1766 |     | //
 1767 |     | //                                         - 8     / qUpper
 1768 |     | //            integralLimitInterval      e        |    - h / 2
 1769 |     | //          '----------------------- := ------- * |  e         k(h - qLower) dh
 1770 |     | //                   2 ** 216              2      |
 1771 |     | //                                               / qLower
 1772 |     | //
 1773 |     | //                - qLower / 2    outgoingMax
 1774 |     | //           == e              * -------------'
 1775 |     | //                                 2 ** 216
 1776 |     | //
 1777 |     | //        - If the swap is price increasing and 'exactInput == true', define:
 1778 |     | //
 1779 |     | //                                         - 8     / qUpper
 1780 |     | //            integralLimitInterval      e        |    + h / 2
 1781 |     | //          '----------------------- := ------- * |  e         k(h - qLower) dh
 1782 |     | //                   2 ** 216              2      |
 1783 |     | //                                               / qLower
 1784 |     | //
 1785 |     | //                + qUpper / 2    incomingMax
 1786 |     | //           == e              * -------------'
 1787 |     | //                                 2 ** 216
 1788 |     | //
 1789 |     | //        - If the swap is price decreasing and 'exactInput == false', define:
 1790 |     | //
 1791 |     | //                                         - 8     / qUpper
 1792 |     | //            integralLimitInterval      e        |    + h / 2
 1793 |     | //          '----------------------- := ------- * |  e         k(qUpper - h) dh
 1794 |     | //                   2 ** 216              2      |
 1795 |     | //                                               / qLower
 1796 |     | //
 1797 |     | //                + qUpper / 2    outgoingMax
 1798 |     | //           == e              * -------------'
 1799 |     | //                                 2 ** 216
 1800 |     | //
 1801 |     | //        - If the swap is price decreasing and 'exactInput == true', define:
 1802 |     | //
 1803 |     | //                                         - 8     / qUpper
 1804 |     | //            integralLimitInterval      e        |    - h / 2
 1805 |     | //          '----------------------- := ------- * |  e         k(qUpper - h) dh
 1806 |     | //                   2 ** 216              2      |
 1807 |     | //                                               / qLower
 1808 |     | //
 1809 |     | //                - qLower / 2    incomingMax
 1810 |     | //           == e              * -------------'
 1811 |     | //                                 2 ** 216
 1812 |     | // 
 1813 |     | //        In the first and the fourth cases above, 'amountSpecified' is in
 1814 |     | //        'tag0'. By crossing the active interval entirely, the absolute value
 1815 |     | //        '|amountSpecified|' is decremented by:
 1816 |     | //
 1817 |     | //                                               growth
 1818 |     | //          'sqrtInverseOffset * sharesTotal * ---------- * 
 1819 |     | //                                              2 ** 111
 1820 |     | //            integralLimitInterval
 1821 |     | //           -----------------------',
 1822 |     | //                 outgoingMax
 1823 |     | // 
 1824 |     | //        In the second and the third cases above, 'amountSpecified' is in
 1825 |     | //        'tag1'. By crossing the active interval entirely, the absolute value
 1826 |     | //        '|amountSpecified|' is decremented by:
 1827 |     | //
 1828 |     | //                                        growth      integralLimitInterval
 1829 |     | //          'sqrtOffset * sharesTotal * ---------- * -----------------------',
 1830 |     | //                                       2 ** 111          outgoingMax
 1831 |     | //
 1832 |     | //        Hence, in both cases, by crossing the active interval, the limit
 1833 |     | //        imposed by 'amountSpecified' is not violated if and only if:
 1834 |     | //        
 1835 |     | //          'integralLimitInterval <= integralLimit'.
 1836 |     | //
 1837 |     | //    In the present example, since 'integralLimit == +oo' and
 1838 |     | //    'qLimit <= qNext' both (a) and (b) are satisfied which means that we can
 1839 |     | //    cross the active interval and move the price to 'qNext' directly, while
 1840 |     | //    determining the outgoing and incoming amounts based on the precalculated
 1841 |     | //    parameters of the pool.
 1842 |     | //
 1843 |     | //    Once again, before the execution of this cross, we need to verify the
 1844 |     | //    condition, 'sharesTotal >= crossThreshold'. If not met, the swap call is
 1845 |     | //    halted and the current values accumulated as 'amount0' and 'amount1' are
 1846 |     | //    exchanged.
 1847 |     | //
 1848 |     | //  - In order to move the price from 'qBack' to 'qNext', we need to update a
 1849 |     | //    number of parameters, including:
 1850 |     | //
 1851 |     | //    - 'amount0': According to the above formulas, as we move the price all
 1852 |     | //      the way from 'qBack' to 'qNext', 'amount0' should be incremented by:
 1853 |     | //
 1854 |     | //                                                               growth
 1855 |     | //        'amount0Partial == sqrtInverseOffset * sharesTotal * ---------- *
 1856 |     | //                                                              2 ** 111
 1857 |     | //          incomingMax      - qLower / 2
 1858 |     | //         ------------- * e              '.
 1859 |     | //          outgoingMax
 1860 |     | //
 1861 |     | //    - 'amount1': According to the above formulas, as we move the price all
 1862 |     | //      the way from 'qBack' to 'qNext', 'amount1' should be decremented by:
 1863 |     | //
 1864 |     | //                                                        growth
 1865 |     | //        'amount1Partial == sqrtOffset * sharesTotal * ---------- * 
 1866 |     | //                                                       2 ** 111
 1867 |     | //                             + qUpper / 2
 1868 |     | //                           e              '.
 1869 |     | //
 1870 |     | //    - 'amountSpecified': Since the swap is partially fulfilled, we should
 1871 |     | //      decrement 'amountSpecified' by 'amount0Partial' to reflect this:
 1872 |     | //
 1873 |     | //        'amountSpecified -= amount0Partial'.
 1874 |     | //
 1875 |     | //    - 'curve': Following the pattern that was introduced earlier, for
 1876 |     | //      inactive liquidity intervals, the amended curve sequence for
 1877 |     | //      '[qLower, qUpper]' should be:
 1878 |     | //
 1879 |     | //        'q[0] := qUpper',
 1880 |     | //        'q[1] := qLower'.
 1881 |     | //
 1882 |     | //      This amendment, transforms the function 'w' associated with
 1883 |     | //      '[qLower, qUpper]' from the following:
 1884 |     | //
 1885 |     | //            w(q)
 1886 |     | //              ^
 1887 |     | //      spacing |\
 1888 |     | //              | \
 1889 |     | //              |  \
 1890 |     | //              |   \
 1891 |     | //              |    \
 1892 |     | //              |     \
 1893 |     | //              |      \
 1894 |     | //              |       \
 1895 |     | //              |        \
 1896 |     | //              |         \
 1897 |     | //              |          \
 1898 |     | //              |           \
 1899 |     | //              |            \
 1900 |     | //              |             \
 1901 |     | //              |              \
 1902 |     | //              |               \
 1903 |     | //              |                \
 1904 |     | //            0 +-----------------+-> q
 1905 |     | //           qLower               |
 1906 |     | //                              qUpper
 1907 |     | //                                |
 1908 |     | //                            qCurrent
 1909 |     | //
 1910 |     | //      to a new function:
 1911 |     | //
 1912 |     | //        'wAmended(q) := q - qLower'
 1913 |     | //
 1914 |     | //      which can be plotted as follows:
 1915 |     | //
 1916 |     | //          wAmended(q)
 1917 |     | //              ^
 1918 |     | //      spacing |                /
 1919 |     | //              |               /
 1920 |     | //              |              /
 1921 |     | //              |             /
 1922 |     | //              |            /
 1923 |     | //              |           /
 1924 |     | //              |          /
 1925 |     | //              |         /
 1926 |     | //              |        /
 1927 |     | //              |       /
 1928 |     | //              |      /
 1929 |     | //              |     /
 1930 |     | //              |    /
 1931 |     | //              |   /
 1932 |     | //              |  /
 1933 |     | //              | /
 1934 |     | //              |/
 1935 |     | //            0 +-----------------+-> q
 1936 |     | //           qLower               |
 1937 |     | //                              qUpper
 1938 |     | //
 1939 |     | //      As we will demonstrate next, this procedure results in growth for
 1940 |     | //      liquidity providers.
 1941 |     | //
 1942 |     | //    - 'growth': As discussed earlier, since the liquidity distribution
 1943 |     | //      function 'k(w(.))' is modified to 'k(wAmended(.))', we need to make an
 1944 |     | //      adjustment to the 'growth' value and turn it into 'growthAmended'.
 1945 |     | //      In order to determine 'growthAmended', the following equation is
 1946 |     | //      solved:
 1947 |     | //
 1948 |     | //        'totalReserveOfTag0Before == totalReserveOfTag0After'
 1949 |     | //
 1950 |     | //      where 'totalReserveOfTag0Before' is the total amount of 'tag0' within
 1951 |     | //      '[qLower, qUpper]' which is calculated based on 'k(w(.))', whereas
 1952 |     | //      'totalReserveOfTag0After' is the same value calculated based on
 1953 |     | //      'k(wAmended(.))'. The two sides of the equation can be derived as:
 1954 |     | //
 1955 |     | //        'totalReserveOfTag0Before == sqrtInverseOffset * sharesTotal * 
 1956 |     | //
 1957 |     | //                                         - 8     / qUpper
 1958 |     | //           growth       2 ** 216       e        |    - h / 2
 1959 |     | //         ---------- * ------------- * ------- * |  e         k(w(h)) dh ==
 1960 |     | //          2 ** 111     outgoingMax       2      |
 1961 |     | //                                               / qLower
 1962 |     | //
 1963 |     | //                                             growth       2 ** 216
 1964 |     | //         sqrtInverseOffset * sharesTotal * ---------- * ------------- *
 1965 |     | //                                            2 ** 111     outgoingMax
 1966 |     | //
 1967 |     | //            - 8     / qUpper
 1968 |     | //          e        |    - h / 2
 1969 |     | //         ------- * |  e         k(qUpper - h) dh ==
 1970 |     | //            2      |
 1971 |     | //                  / qLower
 1972 |     | //
 1973 |     | //                                             growth
 1974 |     | //         sqrtInverseOffset * sharesTotal * ---------- * 
 1975 |     | //                                            2 ** 111
 1976 |     | //
 1977 |     | //          incomingMax      - qLower / 2
 1978 |     | //         ------------- * e              '.
 1979 |     | //          outgoingMax
 1980 |     | //
 1981 |     | //      and
 1982 |     | //
 1983 |     | //        'totalReserveOfTag0After ==
 1984 |     | //
 1985 |     | //                                            growthAmended
 1986 |     | //         sqrtInverseOffset * sharesTotal * --------------- * 
 1987 |     | //                                              2 ** 111
 1988 |     | //
 1989 |     | //                            - 8     / qUpper
 1990 |     | //            2 ** 216      e        |    - h / 2
 1991 |     | //         ------------- * ------- * |  e         k(h - qLower) dh' == 
 1992 |     | //          outgoingMax       2      |
 1993 |     | //                                  / qLower
 1994 |     | //
 1995 |     | //                                            growthAmended
 1996 |     | //         sqrtInverseOffset * sharesTotal * --------------- *
 1997 |     | //                                              2 ** 111
 1998 |     | //
 1999 |     | //           - qLower / 2
 2000 |     | //         e              '.
 2001 |     | //
 2002 |     | //
 2003 |     | //      Hence, 'growthAmended' is given by the following formula:
 2004 |     | //
 2005 |     | //                                    incomingMax
 2006 |     | //        'growthAmended == growth * -------------'.
 2007 |     | //                                    outgoingMax
 2008 |     | //
 2009 |     | //      As proven earlier, 'incomingMax' is always greater than or equal to
 2010 |     | //      'outgoingMax'. Hence, crossing the active interval results in growth.
 2011 |     | //
 2012 |     | //    - 'qCurrent': Lastly, as we move the price of the pool to 'qNext', the
 2013 |     | //      value for 'qCurrent' should be updated to reflect this change., which
 2014 |     | //      is illustrated as follows:
 2015 |     | //
 2016 |     | //                qLimit                qCurrent
 2017 |     | //                   |                     |
 2018 |     | //      ... <--+-------------+-------------+-------------+-------------+--> ...
 2019 |     | //                                         |             |
 2020 |     | //                                       qNext         qBack
 2021 |     | //
 2022 |     | //  - Similar to the prior steps, as we reach 'qNext', we transition from the
 2023 |     | //    original liquidity interval '[qLower, qUpper]' to its adjacent interval
 2024 |     | //    '[qLower - qSpacing, qUpper - qSpacing]'. This transition involves the
 2025 |     | //    adjustment of growth multipliers. In addition we need to update 'growth'
 2026 |     | //    'sharesTotal', 'qBack', 'qNext', as well as the curve sequence. The new
 2027 |     | //    status of the pool following this transition is illustrated as follows:
 2028 |     | //
 2029 |     | //                qLimit                qCurrent
 2030 |     | //                   |                     |
 2031 |     | //      ... <--+-------------+-------------+-------------+-------------+--> ...
 2032 |     | //                           |             |
 2033 |     | //                         qNext         qBack
 2034 |     | //
 2035 |     | //  - Similar to the prior steps, as we transition to a new liquidity interval,
 2036 |     | //    we determine whether we should cross this new active interval entirely or
 2037 |     | //    not. In the present example, since 'qLimit <= qNext' and 
 2038 |     | //    'amountSpecified == +oo', we need to cross one more time. This action
 2039 |     | //    will modify 'amount0', 'amount1', 'growth', as well as the curve
 2040 |     | //    sequence. Additionally, crossing the active interval moves 'qCurrent' to
 2041 |     | //    'qNext' which is illustrated below:
 2042 |     | //
 2043 |     | //                        qCurrent
 2044 |     | //                qLimit     |
 2045 |     | //                   |       |
 2046 |     | //      ... <--+-------------+-------------+-------------+-------------+--> ...
 2047 |     | //                           |             |
 2048 |     | //                         qNext         qBack
 2049 |     | //
 2050 |     | //  - Next, we need to perform another transition in order to enter the
 2051 |     | //    liquidity interval that contains 'qLimit'. The new status of the pool
 2052 |     | //    following this transition is illustrated as follows:
 2053 |     | //
 2054 |     | //                        qCurrent
 2055 |     | //                qLimit     |
 2056 |     | //                   |       |
 2057 |     | //      ... <--+-------------+-------------+-------------+-------------+--> ...
 2058 |     | //             |             |
 2059 |     | //           qNext         qBack
 2060 |     | //  
 2061 |     | //  - Once again, as we transition to a new liquidity interval, we determine
 2062 |     | //    whether we should cross this new active interval entirely or not. This,
 2063 |     | //    time, since 'qNext < qLimit', we should transact within the active
 2064 |     | //    interval as opposed to crossing it. To this end, we move the price
 2065 |     | //    towards 'qNext' until either of the following conditions are met:
 2066 |     | //
 2067 |     | //    (a) 'amountSpecified' is fulfilled.
 2068 |     | //
 2069 |     | //    (b) 'qLimit' is reached.
 2070 |     | //
 2071 |     | //    We move the price from 'qCurrent' towards 'qNext' by enumerating pieces
 2072 |     | //    of the present liquidity distribution function 'k(w(.))'. To this end,
 2073 |     | //    the memory pointers '_begin_' and '_target_' are used in order to keep
 2074 |     | //    track of the two endpoints for the current piece under exploration. Here,
 2075 |     | //    we refer to these endpoints as 'qBegin' and 'qTarget'.
 2076 |     | //
 2077 |     | //    We start with 'qBegin == qCurrent' and move forward by continuously
 2078 |     | //    updating 'qBegin' and 'qTarget'. In each step, the integrals
 2079 |     | //    'currentToTarget' and 'incomingCurrentToTarget' are incremented to
 2080 |     | //    account for the outgoing amount from the pool and the incoming amount to
 2081 |     | //    the pool.
 2082 |     | //
 2083 |     | //    While incrementing the two integrals, we need to continuously monitor
 2084 |     | //    condition (a). To that end, we once again calculate 'integralLimit'
 2085 |     | //
 2086 |     | //      'integralLimit := outgoingMax * 
 2087 |     | //
 2088 |     | //        |amountSpecified|          1          2 ** 111
 2089 |     | //       ------------------- * ------------- * ---------- == +oo'.
 2090 |     | //        sqrtInverseOffset     sharesTotal      growth
 2091 |     | //
 2092 |     | //    With each increment of 'incomingCurrentToTarget' we check whether it has
 2093 |     | //    exceeded 'integralLimit' in which case the swap is halted (alternatively,
 2094 |     | //    in the case where 'exactInput == false', we need to continuously check
 2095 |     | //    whether 'currentToTarget' has exceeded 'integralLimit' or not). However,
 2096 |     | //    this stopping criteria does not apply to this example because
 2097 |     | //    'integralLimit == +oo'.
 2098 |     | //
 2099 |     | //    Hence, we can move forward until the stopping criteria (b) is met, i.e.,
 2100 |     | //    until
 2101 |     | //
 2102 |     | //      'qTarget == qLimit'.
 2103 |     | //
 2104 |     | //    Once the above condition is met, we need to update a number of
 2105 |     | //    parameters, including:
 2106 |     | //
 2107 |     | //    - 'amount0': As discussed in the prior steps, the following increment
 2108 |     | //      should be applied to 'amount0':
 2109 |     | //                                                               growth
 2110 |     | //        'amount0Partial := sqrtInverseOffset * sharesTotal * ---------- *
 2111 |     | //                                                              2 ** 111
 2112 |     | //                            incomingCurrentToTarget
 2113 |     | //                           -------------------------'
 2114 |     | //                                  outgoingMax
 2115 |     | //
 2116 |     | //    - 'amount1': As discussed in the prior steps, the following decrement
 2117 |     | //      should be applied to 'amount1':
 2118 |     | //                                                        growth
 2119 |     | //        'amount1Partial := sqrtOffset * sharesTotal * ---------- *
 2120 |     | //                                                       2 ** 111
 2121 |     | //                            currentToTarget
 2122 |     | //                           -----------------'
 2123 |     | //                              outgoingMax
 2124 |     | //
 2125 |     | //    - 'amountSpecified': Since the swap is partially fulfilled, we should
 2126 |     | //      decrement 'amountSpecified' by 'amount0Partial' to reflect this:
 2127 |     | //
 2128 |     | //        'amountSpecified -= amount0Partial'.
 2129 |     | //
 2130 |     | //    - 'qCurrent': Since we moved the price of the pool to 'qLimit', the value
 2131 |     | //      for 'qCurrent' in memory (i.e., the content of the memory space which
 2132 |     | //      is pointed to by '_logPriceCurrent_') should be updated to
 2133 |     | //
 2134 |     | //        'qCurrent := qTarget'.
 2135 |     | //
 2136 |     | //      This is illustrated as follows:
 2137 |     | //
 2138 |     | //                qTarget
 2139 |     | //                   |
 2140 |     | //                qLimit
 2141 |     | //                   |
 2142 |     | //      ... <--+-------------+-------------+-------------+-------------+--> ...
 2143 |     | //             |     |       |
 2144 |     | //           qNext   |     qBack
 2145 |     | //                   |
 2146 |     | //               qCurrent
 2147 |     | //
 2148 |     | //    - 'curve' and 'growth': Now that the target price is determined as well
 2149 |     | //      as the outgoing and incoming amounts, we need to update the AMM curve 
 2150 |     | //      in preparation for the next swap. To this end, the curve sequence
 2151 |     | //      should be amended. In doing so, we need to respect certain
 2152 |     | //      requirements:
 2153 |     | //
 2154 |     | //      Firstly, remember that the last member of the curve sequence should
 2155 |     | //      always correspond to the current price of the pool, i.e., 'qCurrent'.
 2156 |     | //      Now that we have set 'qCurrent' to 'qTarget' the curve sequence should
 2157 |     | //      be amended with this new value in preparation for the next swap.
 2158 |     | //
 2159 |     | //      Secondly, we should be mindful of the fact that amending the curve
 2160 |     | //      sequence changes the liquidity distribution function from 'k(w(.))' to
 2161 |     | //      'k(wAmended(.))' and we need to make sure that this change does not
 2162 |     | //      affect our accounting of the total interval reserves with respect to
 2163 |     | //      both tags. More precisely, the curve sequence must be amended subject
 2164 |     | //      to the following constraints:
 2165 |     | //
 2166 |     | //        'totalReserveOfTag0Before == totalReserveOfTag0After'
 2167 |     | //
 2168 |     | //        'totalReserveOfTag1Before == totalReserveOfTag1After'
 2169 |     | //
 2170 |     | //      where 'totalReserveOfTag0Before' and 'totalReserveOfTag1Before',
 2171 |     | //      respectively, are the total reserves of 'tag0' and 'tag1' within
 2172 |     | //      '[qLower, qUpper]' that are calculated based on 'k(w(.))', whereas
 2173 |     | //      'totalReserveOfTag0After' and 'totalReserveOfTag1After' are the same
 2174 |     | //      amounts that are calculated based on 'k(wAmended(.))'.
 2175 |     | //
 2176 |     | //      The two sides of the first equation can be derived as:
 2177 |     | //
 2178 |     | //        'totalReserveOfTag0Before := sqrtInverseOffset * sharesTotal * 
 2179 |     | //
 2180 |     | //                                         - 8     / qUpper
 2181 |     | //           growth       2 ** 216       e        |    - h / 2
 2182 |     | //         ---------- * ------------- * ------- * |  e         k(w(h)) dh',
 2183 |     | //          2 ** 111     outgoingMax       2      |
 2184 |     | //                                               / qTarget
 2185 |     | //      and
 2186 |     | //
 2187 |     | //        'totalReserveOfTag0After := 
 2188 |     | //
 2189 |     | //                                            growthAmended
 2190 |     | //         sqrtInverseOffset * sharesTotal * --------------- *
 2191 |     | //                                               2 ** 111
 2192 |     | //
 2193 |     | //                            - 8     / qUpper
 2194 |     | //           2 ** 216       e        |    - h / 2
 2195 |     | //         ------------- * ------- * |  e         k(wAmended(h)) dh',
 2196 |     | //          outgoingMax       2      |
 2197 |     | //                                  / qTarget
 2198 |     | //
 2199 |     | //      which simplify the first equation to:
 2200 |     | //
 2201 |     | //                               / qUpper
 2202 |     | //                              |    - h / 2
 2203 |     | //                              |  e         k(wAmended(h)) dh
 2204 |     | //                              |
 2205 |     | //              growth         / qTarget
 2206 |     | //        '--------------- == ---------------------------------'.
 2207 |     | //          growthAmended           / qUpper
 2208 |     | //                                 |    - h / 2
 2209 |     | //                                 |  e         k(w(h)) dh
 2210 |     | //                                 |
 2211 |     | //                                / qTarget
 2212 |     | //
 2213 |     | //      The two sides of the second equation can be derived as:
 2214 |     | //
 2215 |     | //        'totalReserveOfTag1Before := sqrtOffset * sharesTotal * 
 2216 |     | //
 2217 |     | //                                         - 8     / qTarget
 2218 |     | //           growth       2 ** 216       e        |    + h / 2
 2219 |     | //         ---------- * ------------- * ------- * |  e         k(w(h)) dh',
 2220 |     | //          2 ** 111     outgoingMax       2      |
 2221 |     | //                                               / qLower
 2222 |     | //      and
 2223 |     | //
 2224 |     | //        'totalReserveOfTag1After := 
 2225 |     | //
 2226 |     | //                                     growthAmended      2 ** 216
 2227 |     | //         sqrtOffset * sharesTotal * --------------- * ------------- *
 2228 |     | //                                        2 ** 111       outgoingMax
 2229 |     | //
 2230 |     | //            - 8     / qTarget
 2231 |     | //          e        |    + h / 2
 2232 |     | //         ------- * |  e         k(wAmended(h)) dh',
 2233 |     | //            2      |
 2234 |     | //                  / qLower
 2235 |     | //
 2236 |     | //      which simplifies the second equation to:
 2237 |     | //
 2238 |     | //                               / qTarget
 2239 |     | //                              |    + h / 2
 2240 |     | //                              |  e         k(wAmended(h)) dh
 2241 |     | //                              |
 2242 |     | //            growth           / qLower
 2243 |     | //        '--------------- == ---------------------------------'.
 2244 |     | //          growthAmended           / qTarget
 2245 |     | //                                 |    + h / 2
 2246 |     | //                                 |  e         k(w(h)) dh
 2247 |     | //                                 |
 2248 |     | //                                / qLower
 2249 |     | //
 2250 |     | //      Based on the above equations, finding 'growthAmended' with respect to
 2251 |     | //      'k(w(.))' and 'k(wAmended(.))' is straightforward.
 2252 |     | //
 2253 |     | //      However, in order to satisfy both of the equations, we should have:
 2254 |     | //
 2255 |     | //            / qTarget                         / qUpper
 2256 |     | //           |   + h/2                         |   - h/2
 2257 |     | //           |  e      k(wAmended(h)) dh       |  e      k(wAmended(h)) dh
 2258 |     | //           |                                 |
 2259 |     | //          / qLower                          / qTarget
 2260 |     | //        '------------------------------ == ------------------------------'.
 2261 |     | //               / qTarget                         / qUpper
 2262 |     | //              |    + h/2                        |    - h/2
 2263 |     | //              |  e       k(w(h)) dh             |  e       k(w(h)) dh
 2264 |     | //              |                                 |
 2265 |     | //             / qLower                          / qTarget
 2266 |     | //
 2267 |     | //      Because of the above constraint, we need to take an additional step
 2268 |     | //      prior to amending the curve sequence with 'qTarget'.
 2269 |     | //
 2270 |     | //      Observe that the current curve sequence is last updated when we
 2271 |     | //      transitioned into '[qLower, qUpper]' and it is composed of the
 2272 |     | //      following two points:
 2273 |     | //
 2274 |     | //        'q[0] := qLower',
 2275 |     | //        'q[1] := qUpper'.
 2276 |     | //
 2277 |     | //      The corresponding diagram for the current curve sequence is illustrated
 2278 |     | //      as follows:
 2279 |     | //
 2280 |     | //            w(q)
 2281 |     | //              ^
 2282 |     | //      spacing |                /
 2283 |     | //              |               /
 2284 |     | //              |              /
 2285 |     | //              |             /
 2286 |     | //              |            /
 2287 |     | //              |           /
 2288 |     | //              |          /
 2289 |     | //              |\
 2290 |     | //              | \
 2291 |     | //              |  \
 2292 |     | //              |   \
 2293 |     | //              |        /
 2294 |     | //              |       /
 2295 |     | //              |      /
 2296 |     | //              |     /
 2297 |     | //            0 +----+----+-------+-> q
 2298 |     | //           qLower  |    |       |
 2299 |     | //                   |   q[2]  qUpper
 2300 |     | //                   |
 2301 |     | //               qCurrent
 2302 |     | //
 2303 |     | //            w(q)
 2304 |     | //              ^
 2305 |     | //      spacing |\
 2306 |     | //              | \
 2307 |     | //              |  \
 2308 |     | //              |   \
 2309 |     | //              |    \
 2310 |     | //              |     \
 2311 |     | //              |      \
 2312 |     | //              |       \
 2313 |     | //              |        \
 2314 |     | //              |         \
 2315 |     | //              |          \
 2316 |     | //              |           \
 2317 |     | //              |            \
 2318 |     | //              |             \
 2319 |     | //              |              \
 2320 |     | //            0 +-------+------+-> q
 2321 |     | //           qLower     |      |
 2322 |     | //                      |    qUpper
 2323 |     | //                      |
 2324 |     | //                   qTarget
 2325 |     | //
 2326 |     | //      Before amending the curve sequence with 'qTarget', we first determine a
 2327 |     | //      point between 'qTarget' and 'qNext == qLower' which is regarded as
 2328 |     | //      'qOvershoot':
 2329 |     | //
 2330 |     | //            w(q)
 2331 |     | //              ^
 2332 |     | //      spacing |\
 2333 |     | //              | \
 2334 |     | //              |  \
 2335 |     | //              |   \
 2336 |     | //              |    \
 2337 |     | //              |     \
 2338 |     | //              |      \
 2339 |     | //              |       \
 2340 |     | //              |        \
 2341 |     | //              |         \
 2342 |     | //              |          \
 2343 |     | //              |           \
 2344 |     | //              |            \
 2345 |     | //              |             \
 2346 |     | //              |              \
 2347 |     | //              |               \
 2348 |     | //              |                \
 2349 |     | //            0 +----+----+-------+-> q
 2350 |     | //           qLower  |    |       |
 2351 |     | //                   |    |     qUpper
 2352 |     | //                   |    |
 2353 |     | //                   | qTarget
 2354 |     | //                   |
 2355 |     | //               qOvershoot
 2356 |     | //
 2357 |     | //      Then, the curve sequence is amended with 'qOvershoot' which leads to
 2358 |     | //      the following sequence:
 2359 |     | //
 2360 |     | //        'q[0] := qUpper',
 2361 |     | //        'q[1] := qLower',
 2362 |     | //        'q[2] := qOvershoot'.
 2363 |     | //
 2364 |     | //      and the following diagram:
 2365 |     | //
 2366 |     | //              ^
 2367 |     | //      spacing |\
 2368 |     | //              | \
 2369 |     | //              |  \
 2370 |     | //              |                /
 2371 |     | //              |               /
 2372 |     | //              |              /
 2373 |     | //              |             /
 2374 |     | //              |            /
 2375 |     | //              |           /
 2376 |     | //              |          /
 2377 |     | //              |         /
 2378 |     | //              |        /
 2379 |     | //              |       /
 2380 |     | //              |      /
 2381 |     | //              |     /
 2382 |     | //            0 +----+----+-------+-> q
 2383 |     | //           qLower  |    |       |
 2384 |     | //                   |    |     qUpper
 2385 |     | //                   |    |
 2386 |     | //                   |  qTarget
 2387 |     | //                   |
 2388 |     | //               qOvershoot
 2389 |     | //
 2390 |     | //      In this case, amending the curve sequence has increased its length.
 2391 |     | //      However, this is not always the case. As explained in 'Curve.sol', this
 2392 |     | //      process may involve clearing a number of members from the end of the
 2393 |     | //      curve sequence and then inserting the new member.
 2394 |     | //
 2395 |     | //      After the amendment with 'qOvershoot', the resulting curve sequence is
 2396 |     | //      then amended with 'qTarget' which leads to the following sequence:
 2397 |     | //
 2398 |     | //        'q[0] := qUpper',
 2399 |     | //        'q[1] := qLower',
 2400 |     | //        'q[2] := qOvershoot',
 2401 |     | //        'q[3] := qTarget'.
 2402 |     | //
 2403 |     | //      and the following diagram:
 2404 |     | //
 2405 |     | //          wAmended(q)
 2406 |     | //              ^
 2407 |     | //      spacing |\
 2408 |     | //              | \
 2409 |     | //              |  \
 2410 |     | //              |   \
 2411 |     | //              |                /
 2412 |     | //              |               /
 2413 |     | //              |              /
 2414 |     | //              |             /
 2415 |     | //              |            /
 2416 |     | //              |           /
 2417 |     | //              |          /
 2418 |     | //              |     \
 2419 |     | //              |      \
 2420 |     | //              |       \
 2421 |     | //              |        \
 2422 |     | //            0 +----+----+-------+-> q
 2423 |     | //           qLower  |    |       |
 2424 |     | //                   |    |     qUpper
 2425 |     | //                   |    |
 2426 |     | //                   | qTarget
 2427 |     | //                   |
 2428 |     | //               qOvershoot
 2429 |     | //
 2430 |     | //      The purpose of first amending with 'qOvershoot' is to have an
 2431 |     | //      additional degree of freedom in order to satisfy the equation:
 2432 |     | //
 2433 |     | //        'f(qOvershoot) == 0'
 2434 |     | //
 2435 |     | //      where
 2436 |     | //
 2437 |     | //        'f(qOvershoot) :=
 2438 |     | //
 2439 |     | //            / qUpper                         / qTarget
 2440 |     | //           |   - h/2                        |   + h/2
 2441 |     | //           |  e      k(wAmended(h)) dh      |  e      k(wAmended(h)) dh
 2442 |     | //           |                                |
 2443 |     | //          / qTarget                        / qLower
 2444 |     | //         ------------------------------ - ------------------------------'.
 2445 |     | //               / qUpper                         / qTarget
 2446 |     | //              |    - h/2                       |    + h/2
 2447 |     | //              |  e       k(w(h)) dh            |  e       k(w(h)) dh
 2448 |     | //              |                                |
 2449 |     | //             / qTarget                        / qLower
 2450 |     | //
 2451 |     | //      By investigating the above equation, we can observe that:
 2452 |     | //
 2453 |     | //        - Both of the denominators are fixed. This is because at this stage,
 2454 |     | //          'qTarget' is fully determined either through 'qLimit' or
 2455 |     | //          'amountSpecified'. Additionally, the current curve sequence is
 2456 |     | //          fixed which dictates the shape of 'w(.)'.
 2457 |     | //
 2458 |     | //        - Both of the numerators are functions of 'qOvershoot'. This is
 2459 |     | //          because 'wAmended(.)' can be fully characterized by
 2460 |     | //
 2461 |     | //            - the current curve sequence which is fixed,
 2462 |     | //
 2463 |     | //            - 'qTarget' which is also fixed,
 2464 |     | //
 2465 |     | //            - and 'qOvershoot' which is the only unknown value that we are
 2466 |     | //              trying to determine.
 2467 |     | //
 2468 |     | //      Hence, in order to update the liquidity distribution function from
 2469 |     | //      'k(w(.))' to 'k(wAmended(.))', which updates the AMM diagram of the
 2470 |     | //      active interval, we need to solve the above equation with respect to
 2471 |     | //      'qOvershoot'. As proven in nofeeswap's yellowpaper, there always exist
 2472 |     | //      a root between 'qTarget' and 'qNext' that satisfies:
 2473 |     | //
 2474 |     | //        'growthAmended >= growth'.
 2475 |     | //
 2476 |     | //      This root is found via numerical search by running the methods
 2477 |     | //      'moveOvershoot' and 'searchOvershoot' from 'Interval.sol'.
 2478 |     | //
 2479 |     | //      Remember that 'k(w(.))' and 'k(wAmended(.))' are piecewise linear
 2480 |     | //      functions whose domains cover the entire active interval. The method
 2481 |     | //      'moveOvershoot' from 'Interval.sol' identifies a range within
 2482 |     | //      '[qLower, qUpper]':
 2483 |     | //
 2484 |     | //        - in which 'k(w(.))' is linear,
 2485 |     | //
 2486 |     | //        - in which 'k(wAmended(.))' is linear, and
 2487 |     | //
 2488 |     | //        - to which 'qOvershoot' belongs.
 2489 |     | //
 2490 |     | //      Since 'f(.)' is a continuous function, the membership of a root (i.e.,
 2491 |     | //      'qOvershoot') to a particular range can be verified by evaluating the
 2492 |     | //      sign of 'f(.)' at the two ends of the range. Hence, in light of the
 2493 |     | //      intermediate value theorem, if the signs at the two ends of the range
 2494 |     | //      are different, then there has to be a root somewhere within this
 2495 |     | //      range.
 2496 |     | //
 2497 |     | //      Next, the method 'searchOvershoot' from 'Interval.sol' performs a
 2498 |     | //      Newton search in order to pinpoint the precise value of 'qOvershoot'
 2499 |     | //      within the range that is identified by 'moveOvershoot'.
 2500 |     | //
 2501 |     | //      Once 'qOvershoot' is calculated, we proceed with the two amendments to
 2502 |     | //      the curve sequence via 'qOvershoot' and 'qTarget'.
 2503 |     | //
 2504 |     | //      After that, we derive 'growthAmended' based on the following formula:
 2505 |     | //
 2506 |     | //                                          / qTarget
 2507 |     | //                                         |    + h / 2
 2508 |     | //                                         |  e         k(w(h)) dh
 2509 |     | //                                         |
 2510 |     | //                                        / qLower
 2511 |     | //        'growthAmended == growth * ---------------------------------'.
 2512 |     | //                                      / qTarget
 2513 |     | //                                     |    + h / 2
 2514 |     | //                                     |  e         k(wAmended(h)) dh
 2515 |     | //                                     |
 2516 |     | //                                    / qLower
 2517 |     | //
 2518 |     | //      This concludes the update of our liquidity distribution function (or
 2519 |     | //      equivalently, the update of our AMM diagram) for the next swap.
 2520 |     | //
 2521 |     | //  - The last step involves writing the dynamic parameters of the pool as well
 2522 |     | //    as the amended curve sequence in the protocol's storage which concludes
 2523 |     | //    this example.
 2524 |     | 
 2525 |     | // Swap Inputs
 2526 |     | // ----------------------------------------------------------------------------
 2527 |     | // The following memory pointers correspond to the inputs of the method 'swap'
 2528 |     | // from 'Nofeeswap.sol'. Each parameter is read from calldata via the method
 2529 |     | // 'readSwapInput' from 'Calldata.sol'. Then, the parameters are transformed to
 2530 |     | // appropriate formats and stored in their dedicated memory locations as listed
 2531 |     | // below. Throughout the execution of the swap, the following memory pointers
 2532 |     | // as well as the corresponding getter functions can be used to access each
 2533 |     | // parameter. Moreover, when invoking an applicable hook these input parameters
 2534 |     | // are passed to the hook as calldata and they can be accessed via the
 2535 |     | // corresponding calldata pointers and getter functions that are listed in
 2536 |     | // 'HookCalldata.sol'.
 2537 |     | uint16 constant _swapInput_ = 248;
 2538 |     | 
 2539 |     | // 'crossThreshold' refers to a minimum limit on the total number of shares
 2540 |     | // that should be available in any interval for the 'swap' method to transact
 2541 |     | // in that interval.
 2542 |     | //
 2543 |     | // For example, if 'crossThreshold == 50', then there has to be a minimum of
 2544 |     | // 50 shares present in an interval so that the algorithm either enters that
 2545 |     | // interval or crosses it entirely. Once we encounter an interval with the
 2546 |     | // total number of shares less than 50, the 'swap' call is halted and the price
 2547 |     | // of the pool does not go beyond that point.
 2548 |     | //
 2549 |     | // However, if 'crossThreshold == 0', which is the default, no minimum number
 2550 |     | // of shares is imposed.
 2551 |     | //
 2552 |     | // The calldata layout of the method 'swap' in 'Nofeeswap.sol' does not have a
 2553 |     | // slot dedicated to 'crossThreshold'. Instead, the two inputs 'crossThreshold'
 2554 |     | // and 'zeroForOne' share the same slot in calldata as illustrated below:
 2555 |     | //
 2556 |     | //     +---------------------------+---------------------------+
 2557 |     | //     | crossThreshold (128 bits) |   zeroForOne (128 bits)   |
 2558 |     | //     +---------------------------+---------------------------+
 2559 |     | //
 2560 |     | // 'crossThreshold' occupies the most significant 128 bits and 'zeroForOne'
 2561 |     | // occupies the least significant 128 bits. Hence, 16 bytes are reserved for
 2562 |     | // 'crossThreshold' in memory.
 2563 |     | uint16 constant _crossThreshold_ = 248;
 2564 |     | 
 2565 |     | // The input 'amountSpecified' of the 'swap' method in 'Nofeeswap.sol' is a
 2566 |     | // signed integer. If positive ('exactInput == true'), this value represents
 2567 |     | // the requested incoming amount to be given to the pool as a result of the
 2568 |     | // swap call. If negative ('exactInput == false'), this value represents the
 2569 |     | // requested outgoing amount to be taken from the pool as a result of the swap
 2570 |     | // call. As an initial step of the swap algorithm, the method 'readSwapInput'
 2571 |     | // from 'Calldata.sol' performs the following actions:
 2572 |     | //
 2573 |     | //  - Reads the integer representation of 'amountSpecified' from the dedicated
 2574 |     | //    calldata slot.
 2575 |     | //
 2576 |     | //  - Caps it by '2 ** 127 - 1' from above and by '1 - 2 ** 127' from below.
 2577 |     | //
 2578 |     | //  - Transforms it to the 'X127' format.
 2579 |     | //
 2580 |     | //  - Stores the resulting value in the 32 byte memory space which is referred
 2581 |     | //    to by '_amountSpecified_'.
 2582 |     | //
 2583 |     | // Throughout the execution of the swap, 'amountSpecified' is partially
 2584 |     | // fulfilled with each interval that we visit and because of this, the content
 2585 |     | // of this memory space is continuously updated.
 2586 |     | //
 2587 |     | // Due to limited granularity of logarithmic price in 'X59' representation, a
 2588 |     | // requested amount may not be fulfilled. However,
 2589 |     | //
 2590 |     | //  - if 'amountSpecified > 0', the incoming amount to be given to the pool as
 2591 |     | //    a result of the swap call must not exceed 'amountSpecified'.
 2592 |     | //
 2593 |     | //  - if 'amountSpecified < 0', the outgoing amount to be taken from the pool
 2594 |     | //    as a result of the swap call must be greater than or equal to
 2595 |     | //    '0 - amountSpecified'.
 2596 |     | //
 2597 |     | // 32 bytes are reserved for the 'X127' representation of 'amountSpecified' in
 2598 |     | // memory.
 2599 |     | uint16 constant _amountSpecified_ = 264;
 2600 |     | 
 2601 |     | // The input 'logPriceLimit' of the 'swap' method in 'Nofeeswap.sol' is a
 2602 |     | // signed value in 'X59' format. Define
 2603 |     | //
 2604 |     | //  'pLimit := exp(logPriceLimit / (2 ** 59))'.
 2605 |     | //
 2606 |     | // The input 'logPriceLimit' imposes a limit on the price of the pool post
 2607 |     | // execution of the swap call.
 2608 |     | //
 2609 |     | //  - For price increasing swaps, 'logPriceLimit' serves as an upper bound, in
 2610 |     | //    which case the price of the pool must not exceed 'pLimit'.
 2611 |     | //
 2612 |     | //  - For price decreasing swaps, 'logPriceLimit' serves as a lower bound, in
 2613 |     | //    which case the price of the pool must not subceed 'pLimit'.
 2614 |     | //
 2615 |     | // In both cases, once the price of the pool reaches 'pLimit', the execution of
 2616 |     | // the swap is halted. Put simply, no amount of tags are traded with any price
 2617 |     | // worst than 'pLimit' for the swapper.
 2618 |     | //
 2619 |     | // 32 bytes are reserved for 'logPriceLimit' in memory.
 2620 |     | uint16 constant _logPriceLimit_ = 296;
 2621 |     | 
 2622 |     | // Let 'pLower' and 'pUpper', respectively, denote the minimum and maximum
 2623 |     | // price in the current active liquidity interval and define
 2624 |     | //
 2625 |     | //  'qLower := log(pLower / pOffset)'
 2626 |     | //  'qUpper := log(pUpper / pOffset)'
 2627 |     | //  'qSpacing := log(pUpper / pLower)',
 2628 |     | //  'qMost  := + 16 - 1 / (2 ** 59) - qSpacing'.
 2629 |     | //  'qLeast := - 16 + 1 / (2 ** 59) + qSpacing'.
 2630 |     | //
 2631 |     | // As previously argued, for every integer 'j', the interval
 2632 |     | //
 2633 |     | //  '[qLower + j * qSpacing, qUpper + j * qSpacing]'
 2634 |     | //
 2635 |     | // is a valid liquidity interval if and only if:
 2636 |     | //
 2637 |     | //  '- qMost <= qLower + j * qSpacing'
 2638 |     | //
 2639 |     | // and
 2640 |     | //
 2641 |     | //  'qUpper + j * qSpacing <= + qMost.
 2642 |     | //
 2643 |     | // This includes the current active liquidity interval '[qLower, qUpper]'
 2644 |     | // which corresponds to 'j == 0'.
 2645 |     | //
 2646 |     | // Because of this,
 2647 |     | //
 2648 |     | //  'qCurrent := log(pCurrent / pOffset)'
 2649 |     | //
 2650 |     | // always satisfies
 2651 |     | //
 2652 |     | //  'qCurrent >= qLeast + ((qLower - qLeast) % qSpacing)'
 2653 |     | //
 2654 |     | // and
 2655 |     | //
 2656 |     | //  'qCurrent <= qMost - ((qMost - qLower) % qSpacing)'
 2657 |     | //
 2658 |     | // where 'pCurrent' is the current price of the pool.
 2659 |     | //
 2660 |     | // In order to enforce the above inequalities, the following value is
 2661 |     | // calculated in the method 'setSwapParams' of 'swap.sol':
 2662 |     | //
 2663 |     | //  'qLimit := min(
 2664 |     | //     max(
 2665 |     | //       qLeast + ((qLower - qLeast) % qSpacing),
 2666 |     | //       log(pLimit / pOffset)
 2667 |     | //     ),
 2668 |     | //     qMost - ((qMost - qLower) % qSpacing)
 2669 |     | //   )'
 2670 |     | //
 2671 |     | // based on 'qLower', 'qUpper', and 'logPriceLimit'. Then, the offset binary
 2672 |     | // 'X59' representation of 'qLimit', i.e.,
 2673 |     | //
 2674 |     | //  'logPriceLimitOffsetted := (2 ** 59) * (16 + qLimit)'
 2675 |     | //
 2676 |     | // is stored in the memory space which is pointed to by
 2677 |     | // '_logPriceLimitOffsetted_'.
 2678 |     | //
 2679 |     | // Because
 2680 |     | // 
 2681 |     | //  '- 16 + 1 / (2 ** 59) <= qLimit <= + 16 - 1 / (2 ** 59)',
 2682 |     | //
 2683 |     | // we have
 2684 |     | //
 2685 |     | //  '1 <= logPriceLimitOffsetted <= (2 ** 64) - 1',
 2686 |     | //
 2687 |     | // which is why 8 bytes are reserved for 'logPriceLimitOffsetted' in memory.
 2688 |     | uint16 constant _logPriceLimitOffsetted_ = 328;
 2689 |     | 
 2690 |     | // Swap Parameters
 2691 |     | // ----------------------------------------------------------------------------
 2692 |     | // The following memory pointers correspond to a number of secondary parameters
 2693 |     | // that are derived and stored in memory in order to facilitate the execution
 2694 |     | // of each 'swap' call. The following memory pointers as well as the
 2695 |     | // corresponding getter functions can be used to access each parameter.
 2696 |     | // Moreover, when invoking either of the 'midSwap' and 'postSwap' hooks, if
 2697 |     | // applicable, these parameters are included in memory snapshot that is passed
 2698 |     | // to the hook as calldata. Hence they can be accessed via the corresponding
 2699 |     | // calldata pointers and getter functions that are listed in
 2700 |     | // 'HookCalldata.sol'.
 2701 |     | uint16 constant _swapParams_ = 336;
 2702 |     | 
 2703 |     | // As discussed before, the calldata layout of the method 'swap' in
 2704 |     | // 'Nofeeswap.sol' does not have a slot dedicated to 'crossThreshold' or
 2705 |     | // 'zeroForOne'. Instead, the two inputs 'crossThreshold' and 'zeroForOne'
 2706 |     | // share the same slot in calldata as illustrated below:
 2707 |     | //
 2708 |     | //     +---------------------------+---------------------------+
 2709 |     | //     | crossThreshold (128 bits) |   zeroForOne (128 bits)   |
 2710 |     | //     +---------------------------+---------------------------+
 2711 |     | //
 2712 |     | // 'crossThreshold' occupies the most significant 128 bits and 'zeroForOne'
 2713 |     | // occupies the least significant 128 bits.
 2714 |     | //
 2715 |     | //  - If the given 'zeroForOne' input is equal to '0', then the swap is price
 2716 |     | //    increasing in which case 'tag0' is outgoing from the pool and 'tag1' is
 2717 |     | //    incoming to the pool.
 2718 |     | //
 2719 |     | //  - If the given 'zeroForOne' input is equal to '1', then the swap is price
 2720 |     | //    decreasing in which case 'tag0' is incoming to the pool and 'tag1' is
 2721 |     | //    outgoing from the pool.
 2722 |     | //
 2723 |     | //  - If the given 'zeroForOne' input is equal to any other value, then the
 2724 |     | //    movement of the price is towards 'logPriceLimit', i.e., the swap is price
 2725 |     | //    increasing if
 2726 |     | //
 2727 |     | //      'pCurrent < pLimit'
 2728 |     | //
 2729 |     | //    and the swap is price decreasing if
 2730 |     | //
 2731 |     | //      'pLimit < pCurrent'
 2732 |     | //
 2733 |     | //    where
 2734 |     | //
 2735 |     | //      'pLimit := exp(logPriceLimit / (2 ** 59))'.
 2736 |     | //
 2737 |     | //    and 'pCurrent' represents the current price of the pool.
 2738 |     | //
 2739 |     | // A single byte is reserved for this memory space. After the investigation of
 2740 |     | // calldata and comparing 'pCurrent' with 'pLimit',
 2741 |     | //
 2742 |     | //   - If the swap is deemed to be price increasing, then the byte which is
 2743 |     | //     pointed to by '_zeroForOne_' is left as '0x00'.
 2744 |     | //
 2745 |     | //   - If the swap is price decreasing, then this byte is populated with
 2746 |     | //     '0xFF'.
 2747 |     | //
 2748 |     | // The getter function 'getZeroForOne' in this script and the getter function
 2749 |     | // 'getZeroForOneFromCalldata' in 'HookCalldata.sol' give access to the content
 2750 |     | // of this memory space (or calldata in the context of the hook contract) as a
 2751 |     | // boolean with 'false' and 'true' representing price increasing and price
 2752 |     | // decreasing swaps, respectively.
 2753 |     | uint16 constant _zeroForOne_ = 336;
 2754 |     | 
 2755 |     | // The input 'amountSpecified' of the 'swap' method in 'Nofeeswap.sol' is a
 2756 |     | // signed integer. The following memory spaces contains the sign of
 2757 |     | // 'amountSpecified' which can be accessed as a boolean. To this end, a single
 2758 |     | // byte is reserved in memory which is pointed to by '_exactInput_'.
 2759 |     | //
 2760 |     | //   - If 'amountSpecified > 0', then 'amountSpecified' represents the
 2761 |     | //     requested incoming amount to be given to the pool as a result of the
 2762 |     | //     swap call. In this case the byte which is pointed to by '_exactInput_'
 2763 |     | //     is left as '0x00'.
 2764 |     | //
 2765 |     | //   - If 'amountSpecified < 0', then '0 - amountSpecified' represents the
 2766 |     | //     requested outgoing amount to be taken from the pool as a result of the
 2767 |     | //     swap call. In this case the byte which is pointed to by '_exactInput_'
 2768 |     | //     is populated with '0xFF'.
 2769 |     | //
 2770 |     | // The getter function 'getExactInput' in this script and the getter function
 2771 |     | // 'getExactInputFromCalldata' in 'HookCalldata.sol' give access to the content
 2772 |     | // of this memory space (or calldata in the context of the hook contract) as a
 2773 |     | // boolean with 'false' and 'true' representing exact output and exact input 
 2774 |     | // swaps, respectively.
 2775 |     | uint16 constant _exactInput_ = 337;
 2776 |     | 
 2777 |     | // The execution of a swap call may involve transacting in a single liquidity
 2778 |     | // interval, or it may require visits to multiple intervals.
 2779 |     | //
 2780 |     | // If 'crossThreshold' and 'logPriceLimitOffsetted' are not binding, and in the
 2781 |     | // presence of sufficient liquidity, the protocol should be able to fulfill
 2782 |     | // 'amountSpecified' in the current active interval. This process involves a
 2783 |     | // movement of price from
 2784 |     | //
 2785 |     | //  'qCurrent := log(pCurrent / pOffset)'
 2786 |     | //
 2787 |     | // to
 2788 |     | //
 2789 |     | //  'qTarget := log(pTarget / pOffset)'
 2790 |     | //
 2791 |     | // within the same active liquidity interval, i.e.,
 2792 |     | //
 2793 |     | //   'qLower <= qTarget <= qUpper'.
 2794 |     | //
 2795 |     | // In order to accomplish this, we need to solve the equation:
 2796 |     | //
 2797 |     | //  '|amountSpecified| == 
 2798 |     | //
 2799 |     | //      (getZeroForOne() != getExactInput() ? sqrtOffset : sqrtInverseOffset) * 
 2800 |     | //
 2801 |     | //                      growth
 2802 |     | //      sharesTotal * ---------- * 
 2803 |     | //                     2 ** 111
 2804 |     | //
 2805 |     | //       getExactInput() ? incomingCurrentToTarget : currentToTarget
 2806 |     | //      -------------------------------------------------------------',
 2807 |     | //                                outgoingMax
 2808 |     | //
 2809 |     | // where '|amountSpecified|', 'sqrtOffset', 'sqrtInverseOffset', 'outgoingMax',
 2810 |     | // 'sharesTotal', and 'growth' remain fixed as long as we are in the same
 2811 |     | // interval.
 2812 |     | //
 2813 |     | // Hence, as an initial step of a swap call's execution and with each visit to
 2814 |     | // a new interval, the following value is calculated in 'X216' format:
 2815 |     | //
 2816 |     | //  'integralLimit := min(
 2817 |     | //
 2818 |     | //      oneX216 - epsilonX216,
 2819 |     | //
 2820 |     | //                           1          2 ** 111
 2821 |     | //      outgoingMax *  ------------- * ---------- *
 2822 |     | //                      sharesTotal      growth
 2823 |     | //
 2824 |     | //                                |amountSpecified|
 2825 |     | //      -----------------------------------------------------------------------
 2826 |     | //       (getZeroForOne() != getExactInput()) ? sqrtOffset : sqrtInverseOffset
 2827 |     | //
 2828 |     | //   )'.
 2829 |     | //
 2830 |     | // Based on the above equations, it is straightforward to verify that
 2831 |     | // 'amountSpecified' is fulfilled if and only if:
 2832 |     | //
 2833 |     | //   'getExactInput() ? incomingCurrentToTarget : currentToTarget
 2834 |     | //     == 
 2835 |     | //    integralLimit'.
 2836 |     | //
 2837 |     | // Since the left-hand side is a function of 'qTarget', the above equation is
 2838 |     | // solved by methods 'searchOutgoingTarget' and 'searchIncomingTarget' in
 2839 |     | // 'Interval.sol' in order to calculate the precise value of 'qTarget' that
 2840 |     | // fulfills 'amountSpecified'. These two methods work with 'integralLimit'.
 2841 |     | //
 2842 |     | // 'integralLimit' is less than 'oneX216' and does not exceed 216 bits. Hence,
 2843 |     | // 27 bytes are reserved for the memory space that stores 'integralLimit'.
 2844 |     | uint16 constant _integralLimit_ = 338;
 2845 |     | 
 2846 |     | // Let 'pLower' and 'pUpper', respectively, denote the minimum and maximum
 2847 |     | // price in the current active liquidity interval and define
 2848 |     | //
 2849 |     | //  'qLower := log(pLower / pOffset)',
 2850 |     | //  'qUpper := log(pUpper / pOffset)'.
 2851 |     | //
 2852 |     | // By crossing the active interval entirely from one end to the other end, the
 2853 |     | // absolute value '|amountSpecified|' is decremented by
 2854 |     | //
 2855 |     | //  '(getZeroForOne() != getExactInput() ? sqrtOffset : sqrtInverseOffset) * 
 2856 |     | //
 2857 |     | //                   growth      integralLimitInterval
 2858 |     | //   sharesTotal * ---------- * -----------------------',
 2859 |     | //                  2 ** 111          outgoingMax
 2860 |     | //
 2861 |     | // where 'integralLimitInterval' for the present interval is defined as
 2862 |     | //
 2863 |     | //  'integralLimitInterval := (getExactInput() ? incomingMax : outgoingMax)
 2864 |     | //
 2865 |     | //           (getZeroForOne() != getExactInput() ? - qLower : + qUpper) / 2
 2866 |     | //       * e                                                               '.
 2867 |     | //
 2868 |     | // By crossing the active interval, the limit imposed by 'amountSpecified' is
 2869 |     | // not violated if and only if:
 2870 |     | //        
 2871 |     | //  'integralLimitInterval <= integralLimit'.
 2872 |     | //
 2873 |     | // Hence, 'integralLimitInterval' can be used to determined whether we should
 2874 |     | // cross a new active interval entirely or not.
 2875 |     | //
 2876 |     | // 'integralLimitInterval' is calculated with each visit to a new interval and
 2877 |     | // stored in the 27 bytes memory space which is pointed to by
 2878 |     | // '_integralLimitInterval_'.
 2879 |     | uint16 constant _integralLimitInterval_ = 365;
 2880 |     | 
 2881 |     | // Throughout the execution of a swap, this 32 bytes memory space hosts the
 2882 |     | // 'X127' representation of 'amount0' which is the total amount of 'tag0' that
 2883 |     | // is traded so far. Concluding the visit to each interval involves
 2884 |     | // incrementing the absolute value '|amount0|' with
 2885 |     | //                                                         growth
 2886 |     | //  'amount0Partial := sqrtInverseOffset * sharesTotal * ---------- *
 2887 |     | //                                                        2 ** 111
 2888 |     | //
 2889 |     | //   (getZeroForOne() ? incomingCurrentToTarget : currentToTarget)'.
 2890 |     | //
 2891 |     | // If positive, 'amount0' is incoming to the pool and if negative it is
 2892 |     | // outgoing from the pool.
 2893 |     | uint16 constant _amount0_ = 392;
 2894 |     | 
 2895 |     | // Throughout the execution of a swap, this 32 bytes memory space hosts the
 2896 |     | // 'X127' representation of 'amount1' which is the total amount of 'tag1' that
 2897 |     | // is traded so far. Concluding the visit to each interval involves
 2898 |     | // incrementing the absolute value '|amount1|' with
 2899 |     | //                                                  growth
 2900 |     | //  'amount1Partial := sqrtOffset * sharesTotal * ---------- *
 2901 |     | //                                                 2 ** 111
 2902 |     | //
 2903 |     | //   (getZeroForOne() ? currentToTarget : incomingCurrentToTarget)'.
 2904 |     | //
 2905 |     | // If positive, 'amount1' is incoming to the pool and if negative it is
 2906 |     | // outgoing from the pool.
 2907 |     | uint16 constant _amount1_ = 424;
 2908 |     | 
 2909 |     | // At each point throughout the execution of a swap, as we transition from
 2910 |     | // each interval to the next one, the memory pointer '_back_' is used in order
 2911 |     | // to keep track of the active interval boundary in the opposite direction of
 2912 |     | // the swap.
 2913 |     | //
 2914 |     | // Let 'pLower' and 'pUpper', respectively, denote the minimum and maximum
 2915 |     | // price in the current active liquidity interval and define
 2916 |     | //
 2917 |     | //  'qBack := log((getZeroForOne() ? pUpper : pLower) / pOffset)'.
 2918 |     | //
 2919 |     | // The 62 bytes memory space which is pointed to by '_back_' hosts the
 2920 |     | // following values:
 2921 |     | //
 2922 |     | //  '_back_.log() := (2 ** 59) * (16 + qBack)',
 2923 |     | //  '_back_.sqrt(false) := (2 ** 216) * exp(- 8 - qBack / 2)',
 2924 |     | //  '_back_.sqrt(true) := (2 ** 216) * exp(- 8 + qBack / 2)'.
 2925 |     | //
 2926 |     | // which can be accessed via 'PriceLibrary'. The logarithmic price
 2927 |     | // '_back_.log()' occupies 64 bits, whereas '_back_.sqrt(false)' and
 2928 |     | // '_back_.sqrt(true)' occupy 216 bits each.
 2929 |     | uint16 constant _back_ = 456;
 2930 |     | 
 2931 |     | // At each point throughout the execution of a swap, as we transition from
 2932 |     | // each interval to the next one, the memory pointer '_next_' is used in order
 2933 |     | // to keep track of the active interval boundary in the direction of the swap.
 2934 |     | //
 2935 |     | // Let 'pLower' and 'pUpper', respectively, denote the minimum and maximum
 2936 |     | // price in the current active liquidity interval and define
 2937 |     | //
 2938 |     | //  'qNext := log((getZeroForOne() ? pLower : pUpper) / pOffset)'.
 2939 |     | //
 2940 |     | // The 62 bytes memory space which is pointed to by '_next_' hosts the
 2941 |     | // following values:
 2942 |     | //
 2943 |     | //  '_next_.log() := (2 ** 59) * (16 + qNext)',
 2944 |     | //  '_next_.sqrt(false) := (2 ** 216) * exp(- 8 - qNext / 2)',
 2945 |     | //  '_next_.sqrt(true) := (2 ** 216) * exp(- 8 + qNext / 2)'.
 2946 |     | //
 2947 |     | // which can be accessed via 'PriceLibrary'. The logarithmic price
 2948 |     | // '_next_.log()' occupies 64 bits, whereas '_next_.sqrt(false)' and
 2949 |     | // '_next_.sqrt(true)' occupy 216 bits each.
 2950 |     | uint16 constant _next_ = 518;
 2951 |     | 
 2952 |     | // An LP may choose any consecutive range of liquidity intervals to deposit
 2953 |     | // their liquidity. By doing so, the LP acquires a number of shares in every
 2954 |     | // liquidity interval that belongs to the given range.
 2955 |     | //
 2956 |     | // Let 'pLower' and 'pUpper', respectively, denote the minimum and maximum
 2957 |     | // price in the current active liquidity interval and define
 2958 |     | //
 2959 |     | //  'qLower := log(pLower / pOffset)',
 2960 |     | //  'qUpper := log(pUpper / pOffset)'.
 2961 |     | //
 2962 |     | // Additionally, let
 2963 |     | // 
 2964 |     | //    sqrtInverseOffset     growthMultiplier[qUpper]
 2965 |     | //  '------------------- * --------------------------'
 2966 |     | //         2 ** 127                 2 ** 208
 2967 |     | //
 2968 |     | // represent the total amount of 'tag0' corresponding to a single liquidity
 2969 |     | // provider's share from 'qUpper' to '+oo' and
 2970 |     | //
 2971 |     | //    sqrtOffset     growthMultiplier[qLower]
 2972 |     | //  '------------ * --------------------------'
 2973 |     | //     2 ** 127             2 ** 208
 2974 |     | //
 2975 |     | // represent the total amount of 'tag1' corresponding to a single liquidity
 2976 |     | // provider's share from '-oo' to 'qLower'.
 2977 |     | //
 2978 |     | // The 32 bytes memory space which is pointed to by '_backGrowthMultiplier_'
 2979 |     | // hosts the 'X208' representation of
 2980 |     | // 'growthMultiplier[getZeroForOne() ? qUpper : qLower]'.
 2981 |     | //
 2982 |     | // The 32 bytes memory space which is pointed to by '_nextGrowthMultiplier_'
 2983 |     | // hosts the 'X208' representation of
 2984 |     | // 'growthMultiplier[getZeroForOne() ? qLower : qUpper]'.
 2985 |     | uint16 constant _backGrowthMultiplier_ = 580;
 2986 |     | uint16 constant _nextGrowthMultiplier_ = 612;
 2987 |     | 
 2988 |     | // Interval Parameters
 2989 |     | // ----------------------------------------------------------------------------
 2990 |     | // The following memory pointers correspond to the main variables that are used
 2991 |     | // to calculate swaps within the active liquidity interval.
 2992 |     | //
 2993 |     | // Let 'pCurrent' denote the current price of the pool and let 'pLower' and
 2994 |     | // 'pUpper', respectively, denote the minimum and maximum price in the current
 2995 |     | // active liquidity interval. Define:
 2996 |     | //
 2997 |     | //  'qLower := log(pLower / pOffset)',
 2998 |     | //  'qUpper := log(pUpper / pOffset)',
 2999 |     | //  'qSpacing := log(pUpper / pLower)',
 3000 |     | //  'qCurrent := log(pCurrent / pOffset)'.
 3001 |     | //
 3002 |     | // Then we have:
 3003 |     | //
 3004 |     | //  'qLower <= qCurrent <= qUpper',
 3005 |     | //
 3006 |     | // Consider a swap that involves a movement of price from 'qCurrent' to
 3007 |     | //
 3008 |     | //  'qTarget := log(pTarget / pOffset)'
 3009 |     | //
 3010 |     | // within the same active liquidity interval, i.e.,
 3011 |     | //
 3012 |     | //  'qLower <= qTarget <= qUpper'.
 3013 |     | //
 3014 |     | // Notice that 'qTarget' is an unknown value which will be determined based on
 3015 |     | // one of the followings:
 3016 |     | //
 3017 |     | //  - 'qLimitWithinInterval', which is calculated based on the input
 3018 |     | //    'logPriceLimit' as well as 'qLower' and 'qUpper'. It is stored in the
 3019 |     | //    memory space which is pointed to by
 3020 |     | //    '_logPriceLimitOffsettedWithinInterval_'.
 3021 |     | //
 3022 |     | //  - 'integralLimit', which is calculated based on the input 'amountSpecified'
 3023 |     | //    and is stored in the memory space which is pointed to by
 3024 |     | //    '_integralLimit_'.
 3025 |     | //
 3026 |     | // After determination of 'qTarget', the amounts of 'tag0' and 'tag1' to be
 3027 |     | // exchanged as a result of the movement within '[qLower, qUpper]' are equal
 3028 |     | // to:
 3029 |     | //
 3030 |     | //                                                         growth
 3031 |     | //  'amount0Partial := sqrtInverseOffset * sharesTotal * ---------- *
 3032 |     | //                                                        2 ** 111
 3033 |     | //
 3034 |     | //    getZeroForOne() ? incomingCurrentToTarget : currentToTarget
 3035 |     | //   -------------------------------------------------------------',
 3036 |     | //                            outgoingMax
 3037 |     | // and
 3038 |     | //                                                  growth
 3039 |     | //  'amount1Partial := sqrtOffset * sharesTotal * ---------- *
 3040 |     | //                                                 2 ** 111
 3041 |     | //
 3042 |     | //    getZeroForOne() ? currentToTarget : incomingCurrentToTarget
 3043 |     | //   -------------------------------------------------------------',
 3044 |     | //                            outgoingMax
 3045 |     | //
 3046 |     | // where the parameters 'sqrtInverseOffset', 'sqrtOffset', 'sharesTotal',
 3047 |     | // 'growth', and 'outgoingMax' remain fixed throughout the movement from
 3048 |     | // 'qCurrent' to 'qTarget'.
 3049 |     | //
 3050 |     | // While searching for 'qTarget', the two integrals 'currentToTarget' and
 3051 |     | // 'incomingCurrentToTarget' are calculated. These two integrals are defined as
 3052 |     | // follows:
 3053 |     | //
 3054 |     | //                           - 8
 3055 |     | //    currentToTarget      e
 3056 |     | //  '----------------- := ------- * (
 3057 |     | //       2 ** 216            2
 3058 |     | //
 3059 |     | //                         / qCurrent                 / qTarget
 3060 |     | //                        |    + h / 2               |    - h / 2
 3061 |     | //     getZeroForOne() ?  |  e         k(w(h)) dh :  |  e         k(w(h)) dh
 3062 |     | //                        |                          |
 3063 |     | //                       / qTarget                  / qCurrent
 3064 |     | //
 3065 |     | //   )'
 3066 |     | //
 3067 |     | // and
 3068 |     | //                                   - 8
 3069 |     | //    incomingCurrentToTarget      e
 3070 |     | //  '------------------------- := ------- * (
 3071 |     | //           2 ** 216                2
 3072 |     | //
 3073 |     | //                         / qCurrent                 / qTarget
 3074 |     | //                        |    - h / 2               |    + h / 2
 3075 |     | //     getZeroForOne() ?  |  e         k(w(h)) dh :  |  e         k(w(h)) dh
 3076 |     | //                        |                          |
 3077 |     | //                       / qTarget                  / qCurrent
 3078 |     | //
 3079 |     | //   )'.
 3080 |     | //
 3081 |     | // To further clarify the above definitions, we first need to define the
 3082 |     | // function 'w(.)' which is constructed based on the curve sequence.
 3083 |     | //
 3084 |     | // The curve sequence comprises 64 bit logarithmic prices in the form of
 3085 |     | //
 3086 |     | //  '(2 ** 59) * (16 + qHistorical)'
 3087 |     | //
 3088 |     | // where every 'qHistorical' satisfies:
 3089 |     | //
 3090 |     | //  'qLower <= qHistorical <= qUpper'.
 3091 |     | //
 3092 |     | // Hence, each slot of the curve sequence consists of up to four members. The
 3093 |     | // curve sequence should have at least two members. The first and the second
 3094 |     | // members are 'qLower' and 'qUpper' with the order depending on the pool's
 3095 |     | // history. The last member is always 'qCurrent'. Consider the following curve
 3096 |     | // sequence:
 3097 |     | // 
 3098 |     | //  'q[0], q[1], q[2], ..., q[l - 1]'
 3099 |     | //
 3100 |     | // where 'l' is the number of members. Additionally, to simplify the notations,
 3101 |     | // the out-of-range member 'q[l]' is assigned the same value as 'q[l - 1]'. In
 3102 |     | // order for the above sequence to be considered valid, we should have:
 3103 |     | //
 3104 |     | //  'min(q[i - 1], q[i - 2]) < q[i] < max(q[i - 1], q[i - 2])'.
 3105 |     | //
 3106 |     | // for every '2 <= i < l'. Define
 3107 |     | // 
 3108 |     | //  'w : [qLower, qUpper] -> [0, qSpacing]'
 3109 |     | //
 3110 |     | // as
 3111 |     | //           l - 2
 3112 |     | //           -----
 3113 |     | //           \
 3114 |     | //  'w(q) := /     w_i(q)'.
 3115 |     | //           -----
 3116 |     | //           i = 0
 3117 |     | //
 3118 |     | // where for every '0 <= i <= l - 2', the function
 3119 |     | //
 3120 |     | //  'w_i : [qLower, qUpper] -> [0, qSpacing]'
 3121 |     | //
 3122 |     | // is regarded as a phase which is defined as
 3123 |     | //
 3124 |     | //  'w_i(q) :=
 3125 |     | //
 3126 |     | //    /
 3127 |     | //   |  |q - q[i + 1]|  if  min(q[i], q[i + 2]) < q < max(q[i], q[i + 2])
 3128 |     | //   |                                                                    '.
 3129 |     | //   |  0               otherwise
 3130 |     | //    \
 3131 |     | //
 3132 |     | // Observe that for each '0 <= i <= l - 2', the phase 'w_i' can be
 3133 |     | // characterized via the following three consecutive members of the curve
 3134 |     | // sequence:
 3135 |     | //
 3136 |     | //  'q[i], q[i + 1], q[i + 2]'
 3137 |     | //
 3138 |     | // Next, we need to define the function 'k(.)' which is constructed from the
 3139 |     | // kernel. The kernel is composed of breakpoints. Let 'm + 1' denote the number
 3140 |     | // of these breakpoints. For every integer '0 <= i <= m' the i-th breakpoint of
 3141 |     | // the kernel represents the pair '(b[i], c[i])' where
 3142 |     | //
 3143 |     | //  '0 == b[0] <  b[1] <= b[2] <= ... <= b[m - 1] <  b[m] == qSpacing',
 3144 |     | //  '0 == c[0] <= c[1] <= c[2] <= ... <= c[m - 1] <= c[m] == 1'.
 3145 |     | // 
 3146 |     | // Each breakpoint occupies 64 bytes, in which:
 3147 |     | //
 3148 |     | //  - the 'X15' representation of '(2 ** 15) * c[i]' occupies 2 bytes,
 3149 |     | //
 3150 |     | //  - the 'X59' representation of '(2 ** 59) * b[i]' occupies 8 bytes,
 3151 |     | //
 3152 |     | //  - the 'X216' representation of '(2 ** 216) * exp(- b[i] / 2)' occupies 27
 3153 |     | //    bytes,
 3154 |     | //
 3155 |     | //  - the 'X216' representation of '(2 ** 216) * exp(- 16 + b[i] / 2)' occupies
 3156 |     | //    27 bytes.
 3157 |     | //
 3158 |     | // The above-mentioned layout is illustrated as follows:
 3159 |     | //
 3160 |     | //                      A 512 bit kernel breakpoint
 3161 |     | //  +--+--------+---------------------------+---------------------------+
 3162 |     | //  |  | 8 byte |          27 byte          |          27 byte          |
 3163 |     | //  +--+--------+---------------------------+---------------------------+
 3164 |     | //  |  |        |                           |
 3165 |     | //  |  |        |                            \
 3166 |     | //  |  |        |                             (2 ** 216) * exp(- 16 + b[i] / 2)
 3167 |     | //  |  |         \
 3168 |     | //  |  |          (2 ** 216) * exp(- b[i] / 2)
 3169 |     | //  |   \
 3170 |     | //  |    (2 ** 59) * b[i]
 3171 |     | //   \
 3172 |     | //    (2 ** 15) * c[i]
 3173 |     | //
 3174 |     | // Consider the following list of kernel breakpoints:
 3175 |     | //
 3176 |     | //  '(b[0], c[0]), (b[1], c[1]), (b[2], c[2]), ..., (b[m], c[m])'
 3177 |     | //
 3178 |     | // and for every integer '0 < i <= m', define
 3179 |     | //
 3180 |     | //  'k_i : [0, qSpacing] -> [0, 1]'
 3181 |     | //
 3182 |     | // as
 3183 |     | //
 3184 |     | //  'k_i(q) :=
 3185 |     | //
 3186 |     | //    /            c[i] - c[i - 1]
 3187 |     | //   | c[i - 1] + ----------------- * (q - b[i - 1])  if  b[i - 1] < q < b[i]
 3188 |     | //   |             b[i] - b[i - 1]                                           ',
 3189 |     | //   | 0                                              otherwise
 3190 |     | //    \
 3191 |     | //
 3192 |     | // which means that if 'b[i - 1] == b[i]', then 'k_i(q) := 0'. Now, the kernel
 3193 |     | // function
 3194 |     | // 
 3195 |     | //  'k : [0, qSpacing] -> [0, 1]'
 3196 |     | //
 3197 |     | // is defined as
 3198 |     | //
 3199 |     | //             m
 3200 |     | //           -----
 3201 |     | //           \
 3202 |     | //  'k(q) := /     k_i(q)'.
 3203 |     | //           -----
 3204 |     | //           i = 1
 3205 |     | //
 3206 |     | // Define the liquidity distribution function
 3207 |     | //
 3208 |     | //  'k(w(.)) : [qLower, qUpper] -> [0, 1]'
 3209 |     | //
 3210 |     | // for the active interval as the composition of 'k(.)' with 'w(.)'.
 3211 |     | //
 3212 |     | // As argued above, while searching for 'qTarget', the integrals
 3213 |     | // 'currentToTarget' and 'incomingCurrentToTarget' are calculated based on
 3214 |     | // 'k(w(.))' which enables the protocol to determine 'amount0Partial' and
 3215 |     | // 'amount1Partial' when moving the price from 'qCurrent' to 'qTarget'. In
 3216 |     | // addition, we need to calculate two other integrals that are referred to as
 3217 |     | // 'currentToOrigin' and 'originToOvershoot' which will be defined later in
 3218 |     | // this script. Next, we explain how this search is conducted.
 3219 |     | //
 3220 |     | // Remember that both 'w(.)' and 'k(.)' are piecewise linear functions. As a
 3221 |     | // result, 'k(w(.))' is also piecewise linear. In search for 'qTarget', we
 3222 |     | // enumerate the pieces of 'k(w(.))', one by one, until we discover the piece
 3223 |     | // to which 'qTarget' belongs. To this end, the two indices 'indexCurve' and
 3224 |     | // 'indexKernelTotal' are employed:
 3225 |     | //
 3226 |     | //  - 'indexCurve' keeps track of the current phase under exploration (i.e.,
 3227 |     | //    the piece of 'w(.)'). Remember, that 'w_indexCurve' can be characterized
 3228 |     | //    via the following three consecutive members of the curve sequence:
 3229 |     | //
 3230 |     | //      'q[indexCurve], q[indexCurve + 1], q[indexCurve + 2]'.
 3231 |     | //
 3232 |     | //    Here, we refer to 'q[indexCurve + 1]' and 'q[indexCurve]' as 'qOrigin'
 3233 |     | //    and 'qEnd', respectively. Throughout the search, 'qOrigin' and 'qEnd'
 3234 |     | //    are stored, respectively, in the memory spaces which are pointed to by
 3235 |     | //    '_origin_' and '_end_', and they are updated with each transition to a
 3236 |     | //    new phase.
 3237 |     | //
 3238 |     | //    Additionally, the memory space which is pointed to by '_direction_' keeps
 3239 |     | //    track of the boolean:
 3240 |     | //
 3241 |     | //      'qEnd < q[indexCurve + 2]'.
 3242 |     | //
 3243 |     | //    Hence, 'getDirection() == false' means that we are currently searching
 3244 |     | //    within the range
 3245 |     | //    
 3246 |     | //      'q[indexCurve + 2] < q < qEnd'
 3247 |     | //
 3248 |     | //    in which
 3249 |     | //
 3250 |     | //      'w(q) == w_indexCurve(q) == q - qOrigin'.
 3251 |     | //
 3252 |     | //    Whereas, 'getDirection() == true' means that we are currently searching
 3253 |     | //    within the range
 3254 |     | //    
 3255 |     | //      'qEnd < q < q[indexCurve + 2]'
 3256 |     | //
 3257 |     | //    in which
 3258 |     | //
 3259 |     | //      'w(q) == w_indexCurve(q) == qOrigin - q'.
 3260 |     | //
 3261 |     | //    In order to determine whether 'qTarget' belongs to the current range
 3262 |     | //    under exploration, i.e., the range between
 3263 |     | //
 3264 |     | //      'min(qEnd, q[indexCurve + 2])'
 3265 |     | //
 3266 |     | //    and
 3267 |     | //
 3268 |     | //      'max(qEnd, q[indexCurve + 2])'
 3269 |     | //
 3270 |     | //    we start from the price 'q[indexCurve + 2]' and proceed towards the price
 3271 |     | //    'qEnd' by enumerating the pieces of
 3272 |     | //
 3273 |     | //      'k(w(q)) == getDirection() ? k(qOrigin - q) : k(q - qOrigin)'
 3274 |     | //
 3275 |     | //    one by one. The fact that 'w(.)' is a linear function throughout the
 3276 |     | //    above range, means that we only need to worry about the pieces of either
 3277 |     | //    'k(qOrigin - q)' or 'k(q - qOrigin)', depending on the direction.
 3278 |     | //
 3279 |     | //    The process of enumerating phases starts with the following initial
 3280 |     | //    state:
 3281 |     | //
 3282 |     | //      - 'indexCurve := l - 2',
 3283 |     | //
 3284 |     | //      - 'qOrigin := q[indexCurve + 1] == q[l - 1] == qCurrent',
 3285 |     | //
 3286 |     | //      - 'qEnd := q[indexCurve] == q[l - 2]'.
 3287 |     | //
 3288 |     | //    Once we reach 'qEnd', we transition to a new phase by
 3289 |     | //
 3290 |     | //      - decrementing 'indexCurve' by one,
 3291 |     | //
 3292 |     | //      - updating 'qOrigin' and 'qEnd',
 3293 |     | //
 3294 |     | //      - updating the direction flag,
 3295 |     | //
 3296 |     | //    and the cycle continues until we reach the phase to which 'qTarget'
 3297 |     | //    belongs.
 3298 |     | //
 3299 |     | //  - 'indexKernelTotal' keeps track of the pieces of the kernel function that
 3300 |     | //    we enumerate as we explore the current phase. As defined earlier, let:
 3301 |     | //
 3302 |     | //      - 'qOrigin := q[indexCurve + 1]'
 3303 |     | //
 3304 |     | //      - 'qEnd := q[indexCurve]'
 3305 |     | //
 3306 |     | //      - 'getDirection() := qEnd < q[indexCurve + 2]'
 3307 |     | //
 3308 |     | //    correspond to the current phase under exploration which leads to the
 3309 |     | //    following simplification of the liquidity distribution function:
 3310 |     | //
 3311 |     | //      'k(w(q)) == getDirection() ? k(qOrigin - q) : k(q - qOrigin)'
 3312 |     | //
 3313 |     | //    within the range
 3314 |     | //
 3315 |     | //      'min(q[indexCurve + 2], qEnd) < q < max(q[indexCurve + 2], qEnd)'.
 3316 |     | //
 3317 |     | //    Hence, as we move from 'q[indexCurve + 2]' to 'qEnd', each piece of
 3318 |     | //    'k(w(.))' can be characterized via the following four vertical and
 3319 |     | //    horizontal coordinates:
 3320 |     | //
 3321 |     | //      'cTotal0 := c[indexKernelTotal - 1]',
 3322 |     | //
 3323 |     | //      'qTotal0 := getDirection() ? 
 3324 |     | //                  qOrigin - b[indexKernelTotal - 1] : 
 3325 |     | //                  qOrigin + b[indexKernelTotal - 1]',
 3326 |     | //
 3327 |     | //      'cTotal1 := c[indexKernelTotal]',
 3328 |     | //
 3329 |     | //      'qTotal1 := getDirection() ? 
 3330 |     | //                  qOrigin - b[indexKernelTotal] : 
 3331 |     | //                  qOrigin + b[indexKernelTotal]'.
 3332 |     | //
 3333 |     | //    The pair '(cTotal0, qTotal0)' is stored in the memory space which is
 3334 |     | //    pointed to by '_total0_' and similarly, the pair '(cTotal1, qTotal1)' is
 3335 |     | //    stored in the memory space which is pointed to by '_total1_'.
 3336 |     | //
 3337 |     | //    Hence, the function 'k(w(.))' is linear within the intersection of the
 3338 |     | //    two ranges:
 3339 |     | //
 3340 |     | //      'min(q[indexCurve + 2], qEnd) < q < max(q[indexCurve + 2], qEnd)',
 3341 |     | //
 3342 |     | //    and
 3343 |     | //
 3344 |     | //      'min(qTotal0, qTotal1) < q < max(qTotal0, qTotal1)'.
 3345 |     | //
 3346 |     | //    As long as 'k(w(.))' is linear, we have closed-forms for all of the
 3347 |     | //    integrals that we intend to calculate. Hence, it is important to keep
 3348 |     | //    track of the domain in which 'k(w(.))' is linear and to update it as we
 3349 |     | //    move forward in our search. Moreover, we need to make sure that 'qTarget'
 3350 |     | //    does not go beyond 'qLimitWithinInterval'. Hence, with each transition to
 3351 |     | //    a new phase or a new piece of the kernel function, we make the following
 3352 |     | //    two updates:
 3353 |     | //
 3354 |     | //      'qBegin := getDirection() ? 
 3355 |     | //                 min(q[indexCurve + 2], qTotal0) : 
 3356 |     | //                 max(q[indexCurve + 2], qTotal0)',
 3357 |     | //
 3358 |     | //      'qTarget := (
 3359 |     | //                    getDirection() == getZeroForOne()
 3360 |     | //                  ) ? (
 3361 |     | //                    getDirection() ? 
 3362 |     | //                    max(max(qEnd, qTotal1), qLimitWithinInterval) : 
 3363 |     | //                    min(min(qEnd, qTotal1), qLimitWithinInterval)
 3364 |     | //                  ) : (
 3365 |     | //                    getDirection() ? 
 3366 |     | //                    max(qEnd, qTotal1) : 
 3367 |     | //                    min(qEnd, qTotal1)
 3368 |     | //                  )',
 3369 |     | //
 3370 |     | //    where 'qBegin' and 'qTarget' are stored, respectively, in the memory
 3371 |     | //    spaces that are pointed to by '_begin_' and '_target_'. Both values are
 3372 |     | //    updated with each transition to a new phase or a new piece of 'k(w(.))'.
 3373 |     | //
 3374 |     | //    The process of enumerating the pieces of the kernel function starts with
 3375 |     | //    the initial state 'indexKernelTotal := 1'.
 3376 |     | //
 3377 |     | // While searching for 'qTarget', we need to calculate the following two
 3378 |     | // integrals, in addition to 'currentToTarget' and 'incomingCurrentToTarget':
 3379 |     | //
 3380 |     | //                           - 8
 3381 |     | //    currentToOrigin      e
 3382 |     | //  '----------------- := ------- * (
 3383 |     | //       2 ** 216            2
 3384 |     | //
 3385 |     | //                         / qOrigin                  / qCurrent
 3386 |     | //                        |    - h / 2               |    + h / 2
 3387 |     | //     getZeroForOne() ?  |  e         k(w(h)) dh :  |  e         k(w(h)) dh
 3388 |     | //                        |                          |
 3389 |     | //                       / qCurrent                 / qOrigin
 3390 |     | //
 3391 |     | //   )'
 3392 |     | //
 3393 |     | // and
 3394 |     | //                             - 8
 3395 |     | //    originToOvershoot      e
 3396 |     | //  '------------------- := ------- * (
 3397 |     | //        2 ** 216             2
 3398 |     | //
 3399 |     | //     getZeroForOne() ? 
 3400 |     | //
 3401 |     | //       / qOrigin
 3402 |     | //      |    + h / 2
 3403 |     | //      |  e         k(qOrigin - h) dh :
 3404 |     | //      |
 3405 |     | //     / qTarget
 3406 |     | //
 3407 |     | //       / qTarget
 3408 |     | //      |    - h / 2
 3409 |     | //      |  e         k(h - qOrigin) dh
 3410 |     | //      |
 3411 |     | //     / qOrigin
 3412 |     | //
 3413 |     | //   )'.
 3414 |     | //
 3415 |     | // To summarize, the four integrals:
 3416 |     | //
 3417 |     | //  - 'currentToTarget',
 3418 |     | //
 3419 |     | //  - 'incomingCurrentToTarget',
 3420 |     | //
 3421 |     | //  - 'currentToOrigin', and
 3422 |     | //
 3423 |     | //  - 'originToOvershoot',
 3424 |     | //
 3425 |     | // are incremented with each decrement of 'indexCurve' or increment of
 3426 |     | // 'indexKernelTotal'.
 3427 |     | //
 3428 |     | // The following figure illustrates the ranges covered by the above integrals
 3429 |     | // in the case of 'getZeroForOne() == false', i.e., 'qCurrent < qTarget':
 3430 |     | //
 3431 |     | //                                                currentToTarget
 3432 |     | //                                                exp(- h / 2) * k(w(h))
 3433 |     | //           currentToOrigin                    / 
 3434 |     | //    exp(+ h / 2) * k(w(h))                   /\ 
 3435 |     | //                          \                 /   incomingCurrentToTarget
 3436 |     | //                           \               /    exp(+ h / 2) * k(w(h))
 3437 |     | //                            \             /
 3438 |     | //                     |<------------>|<-------->|
 3439 |     | //                     |              |          |
 3440 |     | //      +--------------+--------------+----------+------------------+
 3441 |     | //      |              |              |          |                  |
 3442 |     | //    qLower           |          qCurrent       |                qUpper
 3443 |     | //                     |                         |
 3444 |     | //                     |<----------------------->|
 3445 |     | //                     |            \            |
 3446 |     | //                  qOrigin          \        qTarget == qOvershoot
 3447 |     | //                                    \
 3448 |     | //                             originToOvershoot
 3449 |     | //                             exp(- h / 2) * k(h - qOrigin)
 3450 |     | //
 3451 |     | // The search for 'qTarget' is conducted by calling the method 'moveTarget()'
 3452 |     | // from 'Interval.sol' in a loop until either of the following condition are
 3453 |     | // met:
 3454 |     | //
 3455 |     | //  - 'qLimitWithinInterval == qTarget', or
 3456 |     | //
 3457 |     | //  - 'integralLimit == (
 3458 |     | //       getExactInput() ? incomingCurrentToTarget : currentToTarget
 3459 |     | //     )'.
 3460 |     | //
 3461 |     | // Define:
 3462 |     | //
 3463 |     | //                                - 8     / qUpper
 3464 |     | //    integral0Incremented      e        |    - h / 2
 3465 |     | //  '---------------------- := ------- * |  e         k(w(h)) dh',
 3466 |     | //          2 ** 216              2      |
 3467 |     | //                                      / qTarget
 3468 |     | //
 3469 |     | //                                - 8     / qTarget
 3470 |     | //    integral1Incremented      e        |    + h / 2
 3471 |     | //  '---------------------- := ------- * |  e         k(w(h)) dh'.
 3472 |     | //          2 ** 216              2      |
 3473 |     | //                                      / qLower
 3474 |     | //
 3475 |     | // Now, the total reserves of 'tag0' and 'tag1' within '[qLower, qUpper]' after
 3476 |     | // the movement of price from 'qCurrent' to 'qTarget' (i.e., after the exchange
 3477 |     | // of 'amount0Partial' and 'amount1Partial') are equal to 
 3478 |     | //
 3479 |     | //                                       growth      integral0Incremented
 3480 |     | //  'sqrtInverseOffset * sharesTotal * ---------- * ----------------------'
 3481 |     | //                                      2 ** 111         outgoingMax
 3482 |     | //
 3483 |     | // and
 3484 |     | //
 3485 |     | //                                growth      integral1Incremented
 3486 |     | //  'sqrtOffset * sharesTotal * ---------- * ----------------------',
 3487 |     | //                               2 ** 111         outgoingMax
 3488 |     | //
 3489 |     | // respectively. The ranges covered by 'integral0Incremented' and
 3490 |     | // 'integral1Incremented' are illustrated as follows:
 3491 |     | //
 3492 |     | //                                                    integral0Incremented
 3493 |     | //                                                    exp(- h / 2) * k(w(h))
 3494 |     | //                integral1Incremented               /
 3495 |     | //                exp(+ h / 2) * k(w(h))            /
 3496 |     | //      |<-------------------------------------->|<---------------->|
 3497 |     | //      |                                        |                  |
 3498 |     | //      +----------------------------------------+------------------+
 3499 |     | //      |                                        |                  |
 3500 |     | //    qLower                                  qTarget             qUpper
 3501 |     | //
 3502 |     | // After the search for 'qTarget' is concluded, and 'amount0Partial' and
 3503 |     | // 'amount1Partial' are calculated, we need to determine 'qOvershoot'. If
 3504 |     | // 'getZeroForOne() == false', we have
 3505 |     | //
 3506 |     | //  'qTarget <= qOvershoot <= qUpper'
 3507 |     | //
 3508 |     | // and if 'getZeroForOne() == true', we have
 3509 |     | //
 3510 |     | //  'qLower <= qOvershoot <= qTarget'.
 3511 |     | //
 3512 |     | // The curve sequence is first amended with 'qOvershoot' and then 'qTarget', in
 3513 |     | // preparation for the next swap.
 3514 |     | //
 3515 |     | // To this end, define:
 3516 |     | //                              - 8
 3517 |     | //    currentToOvershoot      e
 3518 |     | //  '-------------------- := ------- * (
 3519 |     | //         2 ** 216             2
 3520 |     | //
 3521 |     | //                         / qCurrent                 / qOvershoot
 3522 |     | //                        |    + h / 2               |    - h / 2
 3523 |     | //     getZeroForOne() ?  |  e         k(w(h)) dh :  |  e         k(w(h)) dh
 3524 |     | //                        |                          |
 3525 |     | //                       / qOvershoot               / qCurrent
 3526 |     | //
 3527 |     | //   )'
 3528 |     | //
 3529 |     | // and
 3530 |     | //                             - 8
 3531 |     | //    targetToOvershoot      e
 3532 |     | //  '------------------- := ------- * (
 3533 |     | //         2 ** 216            2
 3534 |     | //
 3535 |     | //     getZeroForOne()
 3536 |     | //
 3537 |     | //         / qTarget
 3538 |     | //        |    + h / 2
 3539 |     | //     ?  |  e         k(qTarget - h) dh
 3540 |     | //        |
 3541 |     | //       / qOvershoot
 3542 |     | //
 3543 |     | //         / qOvershoot
 3544 |     | //        |    - h / 2
 3545 |     | //     :  |  e         k(h - qTarget) dh
 3546 |     | //        |
 3547 |     | //       / qTarget
 3548 |     | //
 3549 |     | //   )'
 3550 |     | //
 3551 |     | // While searching for 'qOvershoot', the four integrals:
 3552 |     | //
 3553 |     | //  - 'currentToOvershoot',
 3554 |     | //
 3555 |     | //  - 'targetToOvershoot',
 3556 |     | //
 3557 |     | //  - 'originToOvershoot', and
 3558 |     | //
 3559 |     | //  - 'currentToOrigin',
 3560 |     | //
 3561 |     | // are kept track of. The following figure illustrates the ranges covered by
 3562 |     | // the above integrals in the case of 'getZeroForOne() == false', i.e.,
 3563 |     | // 'qCurrent < qTarget':
 3564 |     | //
 3565 |     | //           currentToOrigin                      currentToOvershoot
 3566 |     | //    exp(+ h / 2) * k(w(h))                      exp(- h / 2) * k(w(h))
 3567 |     | //                          \                    /
 3568 |     | //                           \                  /
 3569 |     | //                            \                /
 3570 |     | //              |<------------------->|<--------------->|
 3571 |     | //              |                     |                 |
 3572 |     | //              |                     |    qTarget      |
 3573 |     | //              |                     |       |         |
 3574 |     | //      +-------+---------------------+-------+---------+-----------+
 3575 |     | //      |       |                     |       |         |           |
 3576 |     | //    qLower    |                 qCurrent    |<------->|         qUpper
 3577 |     | //              |                                  /    |
 3578 |     | //              |                                 /     |
 3579 |     | //              |                targetToOvershoot      |
 3580 |     | //              |    exp(- h / 2) * k(h - qTarget)      |
 3581 |     | //              |                                       |
 3582 |     | //              |                                       |
 3583 |     | //              |<------------------------------------->|
 3584 |     | //              |                     /                 |
 3585 |     | //           qOrigin                 /              qOvershoot
 3586 |     | //                                  /
 3587 |     | //                                 /
 3588 |     | //                originToOvershoot
 3589 |     | //    exp(- h / 2) * k(h - qOrigin)
 3590 |     | //
 3591 |     | // Now, in order to find 'qOvershoot', we need to solve the equation:
 3592 |     | //
 3593 |     | //   'f(qOvershoot) == 0'
 3594 |     | //
 3595 |     | // where
 3596 |     | //
 3597 |     | //   'f(qOvershoot) := getZeroForOne() ? 
 3598 |     | //                     s0(qOvershoot) - s1(qOvershoot) : 
 3599 |     | //                     s1(qOvershoot) - s0(qOvershoot)',
 3600 |     | //
 3601 |     | // and the two functions 's0' and 's1' are defined as:
 3602 |     | //
 3603 |     | //                          - 8      / qTarget
 3604 |     | //                        e         |   + h / 2
 3605 |     | //                       ------- *  |  e        k(wAmended(h)) dh
 3606 |     | //                          2       |
 3607 |     | //                                 / qLower
 3608 |     | //   's1(qOvershoot) := ------------------------------------------',
 3609 |     | //                                integral1Incremented
 3610 |     | //
 3611 |     | //                          - 8      / qUpper
 3612 |     | //                        e         |   - h / 2
 3613 |     | //                       ------- *  |  e        k(wAmended(h)) dh
 3614 |     | //                          2       |
 3615 |     | //                                 / qTarget
 3616 |     | //   's0(qOvershoot) := ------------------------------------------'.
 3617 |     | //                                integral0Incremented
 3618 |     | //
 3619 |     | // Now, according to the amendement procedure which is described in
 3620 |     | // 'Curve.sol', if 'getZeroForOne() == false', we have:
 3621 |     | //
 3622 |     | //                       / k(w(h))            if  qOvershoot < h < qUpper
 3623 |     | //   'k(wAmended(h)) == |  k(h - qTarget)     if  qTarget < h < qOvershoot '
 3624 |     | //                      |  k(qOvershoot - h)  if  qOrigin < h < qTarget
 3625 |     | //                       \ k(w(h))            if  qLower < h < qOrigin
 3626 |     | //
 3627 |     | // and if 'getZeroForOne() == true', we have:
 3628 |     | //
 3629 |     | //                       / k(w(h))            if  qLower < h < qOvershoot
 3630 |     | //   'k(wAmended(h)) == |  k(qTarget - h)     if  qOvershoot < h < qTarget '.
 3631 |     | //                      |  k(h - qOvershoot)  if  qTarget < h < qOrigin
 3632 |     | //                       \ k(w(h))            if  qOrigin < h < qUpper
 3633 |     | //
 3634 |     | // For the case 'getZeroForOne() == false', the above formulas conclude that:
 3635 |     | //
 3636 |     | //  - the numerator of 's1' is equal to:
 3637 |     | //
 3638 |     | //        - 8     / qTarget
 3639 |     | //      e        |    + h / 2
 3640 |     | //    '------- * |  e         k(wAmended(h)) dh == 
 3641 |     | //        2      |
 3642 |     | //              / qLower
 3643 |     | //
 3644 |     | //        - 8     / qOrigin
 3645 |     | //      e        |    + h / 2
 3646 |     | //     ------- * |  e         k(wAmended(h)) dh +
 3647 |     | //        2      |
 3648 |     | //              / qLower
 3649 |     | //
 3650 |     | //                                - 8     / qTarget
 3651 |     | //                              e        |    + h / 2
 3652 |     | //                             ------- * |  e         k(wAmended(h)) dh ==
 3653 |     | //                                2      |
 3654 |     | //                                      / qOrigin
 3655 |     | //
 3656 |     | //        - 8     / qOrigin
 3657 |     | //      e        |    + h / 2
 3658 |     | //     ------- * |  e         k(w(h)) dh +
 3659 |     | //        2      |
 3660 |     | //              / qLower
 3661 |     | //
 3662 |     | //                                - 8     / qTarget
 3663 |     | //                              e        |    + h / 2
 3664 |     | //                             ------- * |  e         k(qOvershoot - h) dh ==
 3665 |     | //                                2      |
 3666 |     | //                                      / qOrigin
 3667 |     | //
 3668 |     | //        - 8     / qOrigin
 3669 |     | //      e        |    + h / 2
 3670 |     | //     ------- * |  e         k(w(h)) dh +
 3671 |     | //        2      |
 3672 |     | //              / qLower
 3673 |     | //
 3674 |     | //                                - 8     / qOvershoot
 3675 |     | //                              e        |    + h / 2
 3676 |     | //                             ------- * |  e         k(qOvershoot - h) dh -
 3677 |     | //                                2      |
 3678 |     | //                                      / qOrigin
 3679 |     | //
 3680 |     | //                                - 8     / qOvershoot
 3681 |     | //                              e        |    + h / 2
 3682 |     | //                             ------- * |  e         k(qOvershoot - h) dh ==
 3683 |     | //                                2      |
 3684 |     | //                                      / qTarget
 3685 |     | //
 3686 |     | //        - 8     / qTarget
 3687 |     | //      e        |    + h / 2
 3688 |     | //     ------- * |  e         k(w(h)) dh - 
 3689 |     | //        2      |
 3690 |     | //              / qLower
 3691 |     | //
 3692 |     | //        - 8     / qTarget                   - 8     / qCurrent
 3693 |     | //      e        |    + h / 2               e        |    + h / 2
 3694 |     | //     ------- * |  e         k(w(h)) dh - ------- * |  e         k(w(h)) dh +
 3695 |     | //        2      |                            2      |
 3696 |     | //              / qCurrent                          / qOrigin
 3697 |     | //
 3698 |     | //        - 8 + (qOrigin + qOvershoot) / 2     / qOvershoot
 3699 |     | //      e                                     |    - h / 2
 3700 |     | //     ------------------------------------ * |  e         k(h - qOrigin) dh -
 3701 |     | //                        2                   |
 3702 |     | //                                           / qOrigin
 3703 |     | //
 3704 |     | //        - 8 + (qTarget + qOvershoot) / 2     / qOvershoot
 3705 |     | //      e                                     |    - h / 2
 3706 |     | //     ------------------------------------ * |  e         k(h - qTarget) dh ==
 3707 |     | //                        2                   |
 3708 |     | //                                           / qTarget
 3709 |     | //
 3710 |     | //      integral1Incremented - incomingCurrentToTarget - currentToOrigin
 3711 |     | //     ------------------------------------------------------------------ + 
 3712 |     | //                                  2 ** 216
 3713 |     | //
 3714 |     | //      exp((qOrigin + qOvershoot) / 2) * originToOvershoot
 3715 |     | //     ----------------------------------------------------- - 
 3716 |     | //                            2 ** 216
 3717 |     | //
 3718 |     | //      exp((qTarget + qOvershoot) / 2) * targetToOvershoot
 3719 |     | //     -----------------------------------------------------'.
 3720 |     | //                            2 ** 216
 3721 |     | //
 3722 |     | //  - the numerator of 's0' is equal to:
 3723 |     | //
 3724 |     | //        - 8     / qUpper
 3725 |     | //      e        |    - h / 2
 3726 |     | //    '------- * |  e         k(wAmended(h)) dh == 
 3727 |     | //        2      |
 3728 |     | //              / qTarget
 3729 |     | //
 3730 |     | //        - 8     / qOvershoot
 3731 |     | //      e        |    - h / 2
 3732 |     | //     ------- * |  e         k(wAmended(h)) dh +
 3733 |     | //        2      |
 3734 |     | //              / qTarget
 3735 |     | //
 3736 |     | //                                - 8     / qUpper
 3737 |     | //                              e        |    - h / 2
 3738 |     | //                             ------- * |  e         k(wAmended(h)) dh == 
 3739 |     | //                                2      |
 3740 |     | //                                      / qOvershoot
 3741 |     | //
 3742 |     | //        - 8     / qOvershoot
 3743 |     | //      e        |    - h / 2
 3744 |     | //     ------- * |  e         k(h - qTarget) dh +
 3745 |     | //        2      |
 3746 |     | //              / qTarget
 3747 |     | //
 3748 |     | //                                - 8     / qUpper
 3749 |     | //                              e        |    - h / 2
 3750 |     | //                             ------- * |  e         k(w(h)) dh == 
 3751 |     | //                                2      |
 3752 |     | //                                      / qOvershoot
 3753 |     | //
 3754 |     | //        - 8     / qOvershoot
 3755 |     | //      e        |    - h / 2
 3756 |     | //     ------- * |  e         k(h - qTarget) dh +
 3757 |     | //        2      |
 3758 |     | //              / qTarget
 3759 |     | //
 3760 |     | //        - 8     / qTarget                   - 8     / qUpper
 3761 |     | //      e        |    - h / 2               e        |    - h / 2
 3762 |     | //     ------- * |  e         k(w(h)) dh + ------- * |  e         k(w(h)) dh -
 3763 |     | //        2      |                            2      |
 3764 |     | //              / qCurrent                          / qTarget
 3765 |     | //
 3766 |     | //        - 8     / qOvershoot
 3767 |     | //      e        |
 3768 |     | //     ------- * |  e         k(w(h)) dh == 
 3769 |     | //        2      |
 3770 |     | //              / qCurrent
 3771 |     | //
 3772 |     | //      targetToOvershoot + currentToTarget
 3773 |     | //     ------------------------------------- + 
 3774 |     | //                    2 ** 216
 3775 |     | //
 3776 |     | //      integral0Incremented - currentToOvershoot
 3777 |     | //     -------------------------------------------'.
 3778 |     | //                       2 ** 216
 3779 |     | //
 3780 |     | // Similar arguments can be made for the case 'getZeroForOne() == true' and for
 3781 |     | // both cases, we have:
 3782 |     | //
 3783 |     | //   'f(qOvershoot) := getZeroForOne() ? (
 3784 |     | //
 3785 |     | //      (
 3786 |     | //
 3787 |     | //        exp(- (qOrigin + qOvershoot) / 2) * originToOvershoot -
 3788 |     | //
 3789 |     | //        exp(- (qTarget + qOvershoot) / 2) * targetToOvershoot - 
 3790 |     | //
 3791 |     | //        incomingCurrentToTarget - currentToOrigin
 3792 |     | //
 3793 |     | //      ) / integral0Incremented - (
 3794 |     | //
 3795 |     | //        targetToOvershoot + currentToTarget - currentToOvershoot
 3796 |     | //      
 3797 |     | //      ) / integral1Incremented
 3798 |     | //
 3799 |     | //    ) : (
 3800 |     | //
 3801 |     | //      (
 3802 |     | //
 3803 |     | //        exp(+ (qOrigin + qOvershoot) / 2) * originToOvershoot -
 3804 |     | //
 3805 |     | //        exp(+ (qTarget + qOvershoot) / 2) * targetToOvershoot - 
 3806 |     | //
 3807 |     | //        incomingCurrentToTarget - currentToOrigin
 3808 |     | //
 3809 |     | //      ) / integral1Incremented - (
 3810 |     | //
 3811 |     | //        targetToOvershoot + currentToTarget - currentToOvershoot
 3812 |     | //      
 3813 |     | //      ) / integral0Incremented
 3814 |     | //
 3815 |     | //    )'.
 3816 |     | //
 3817 |     | // We use Newton's method in order to pinpoint the precise value for
 3818 |     | // 'qOvershoot' which satisfies:
 3819 |     | //
 3820 |     | //   'f(qOvershoot) == 0'.
 3821 |     | //
 3822 |     | // To this end, we need access to a simple and closed-form expression for all
 3823 |     | // of the above integrals. Hence, we first need to restrict our search to a
 3824 |     | // domain in which both 'k(w(.))' and 'k(|h - qTarget|)' are linear.
 3825 |     | //
 3826 |     | // Hence, prior to the above-mentioned numerical search, we first need to move
 3827 |     | // 'qOvershoot' from 'qTarget' towards 'qNext' until we determine the
 3828 |     | // followings:
 3829 |     | //
 3830 |     | //   - The piece of 'k(w(.))' to which 'qOvershoot' belongs.
 3831 |     | //
 3832 |     | //   - The piece of 'k(|h - qTarget|)' to which 'qOvershoot' belongs.
 3833 |     | //
 3834 |     | // The former is accomplished via a similar procedure as we delineated before
 3835 |     | // in search for 'qTarget'. Put simply, we start with
 3836 |     | //
 3837 |     | //   'qOvershoot := qTarget'
 3838 |     | //
 3839 |     | // because
 3840 |     | //
 3841 |     | //   'f(qTarget) < 0',
 3842 |     | //
 3843 |     | // and we keep moving 'qOvershoot' forward until we encounter a point that
 3844 |     | // satisfies:
 3845 |     | //
 3846 |     | //   'f(qOvershoot) > 0'.
 3847 |     | //
 3848 |     | // Throughout the movement from 'qTarget' towards 'qNext', we keep track of the
 3849 |     | // current phase under exploration using the variables:
 3850 |     | //
 3851 |     | //   - 'indexCurve', 'qOrigin', 'qEnd', 'direction',
 3852 |     | //
 3853 |     | // and we keep track of the current piece of the kernel function using the
 3854 |     | // variables:
 3855 |     | //
 3856 |     | //   - 'indexKernelTotal', 'cTotal0', 'cTotal1', 'qTotal0', 'qTotal1'
 3857 |     | //
 3858 |     | // Throughout the search for 'qOvershoot', the piece of 'k(|h - qTarget|)' to
 3859 |     | // which 'qOvershoot' belongs is determined using an additional index:
 3860 |     | //
 3861 |     | //  - 'indexKernelForward' keeps track of the pieces of the function
 3862 |     | //    'k(|h - qTarget|)' that we enumerate as we move from 'qTarget' to
 3863 |     | //    'qOvershoot'. Each piece of 'k(|h - qTarget|)' can be characterized via
 3864 |     | //    the following four vertical and horizontal coordinates:
 3865 |     | //
 3866 |     | //      'cForward0 := c[indexKernelForward - 1]',
 3867 |     | //
 3868 |     | //      'qForward0 := getZeroForOne() ? 
 3869 |     | //                    qTarget - b[indexKernelForward - 1] : 
 3870 |     | //                    qTarget + b[indexKernelForward - 1]',
 3871 |     | //
 3872 |     | //      'cForward1 := c[indexKernelForward]',
 3873 |     | //
 3874 |     | //      'qForward1 := getZeroForOne() ? 
 3875 |     | //                    qTarget - b[indexKernelForward] : 
 3876 |     | //                    qTarget + b[indexKernelForward]'.
 3877 |     | //
 3878 |     | //    The pair '(cForward0, qForward0)' is stored in the memory space which is
 3879 |     | //    pointed to by '_forward0_' and similarly, the pair
 3880 |     | //    '(cForward1, qForward1)' is stored in the memory space which is pointed
 3881 |     | //    to by '_forward1_'.
 3882 |     | //
 3883 |     | //    Hence, the function 'k(|. - qTarget|)' is linear within the range:
 3884 |     | //
 3885 |     | //      'min(qForward0, qForward1) < q < max(qForward0, qForward1)'.
 3886 |     | //
 3887 |     | //    and the function 'k(w(.))' is linear within the intersection of the two
 3888 |     | //    ranges:
 3889 |     | //
 3890 |     | //      'min(q[indexCurve + 2], qEnd) < q < max(q[indexCurve + 2], qEnd)',
 3891 |     | //
 3892 |     | //    and
 3893 |     | //
 3894 |     | //      'min(qTotal0, qTotal1) < q < max(qTotal0, qTotal1)'.
 3895 |     | //
 3896 |     | //    Now, in order to have closed-forms for all of the integrals that the
 3897 |     | //    formula for 'f(qOvershoot)' comprises, at each step, we keep track of the
 3898 |     | //    domain in which both 'k(w(.))' and 'k(|. - qTarget|)' are linear and we
 3899 |     | //    update this domain as we move forward in our search. Hence, with every
 3900 |     | //    update of 'indexCurve', 'indexKernelTotal', and 'indexKernelForward', we
 3901 |     | //    make the following two updates:
 3902 |     | //
 3903 |     | //      'qBegin := (
 3904 |     | //                   direction == getZeroForOne()
 3905 |     | //                 ) ? (
 3906 |     | //                   direction ? 
 3907 |     | //                   max(max(q[indexCurve + 2], qTotal0), qForward0) : 
 3908 |     | //                   min(min(q[indexCurve + 2], qTotal0), qForward0)
 3909 |     | //                 ) : (
 3910 |     | //                   direction ? 
 3911 |     | //                   max(q[indexCurve + 2], qTotal0) : 
 3912 |     | //                   min(q[indexCurve + 2], qTotal0)
 3913 |     | //                 )',
 3914 |     | //
 3915 |     | //      'qOvershoot := (
 3916 |     | //                       direction == getZeroForOne()
 3917 |     | //                     ) ? (
 3918 |     | //                       direction ? 
 3919 |     | //                       max(max(qEnd, qTotal1), qForward1) : 
 3920 |     | //                       min(min(qEnd, qTotal1), qForward1)
 3921 |     | //                     ) : (
 3922 |     | //                       direction ? 
 3923 |     | //                       max(qEnd, qTotal1) : 
 3924 |     | //                       min(qEnd, qTotal1)
 3925 |     | //                     )',
 3926 |     | //
 3927 |     | //    where 'qBegin' and 'qOvershoot' are stored, respectively, in the memory
 3928 |     | //    spaces that are pointed to by '_begin_' and '_overshoot_'. Both values
 3929 |     | //    are updated with each transition to a new phase, a new piece of
 3930 |     | //    'k(w(.))', or a new piece of 'k(|. - qTarget|)'.
 3931 |     | //
 3932 |     | //    The process of enumerating the pieces of 'k(|. - qTarget|)' starts with
 3933 |     | //    the initial state 'indexKernelForward := 1'.
 3934 |     | //
 3935 |     | // Determining the search domain to which 'qOvershoot' belongs and in which
 3936 |     | // both 'k(w(.))' and 'k(|. - qTarget|)' are linear, is conducted by calling
 3937 |     | // the method 'moveOvershoot' from 'Interval.sol' in a loop until the following
 3938 |     | // condition is met:
 3939 |     | //
 3940 |     | //   'f(qBegin) <= 0' and 'f(qOvershoot) >  0'.
 3941 |     | //
 3942 |     | // Then, according to the intermediate value theorem, there exists a solution
 3943 |     | // in this search domain which satisfies:
 3944 |     | //
 3945 |     | //   'f(qOvershoot) == 0'.
 3946 |     | //
 3947 |     | // Then, this solution is found by calling the method 'searchOvershoot' from
 3948 |     | // 'Interval.sol'.
 3949 |     | //
 3950 |     | // In order to calculate the Newton step at each stage, we need to find the
 3951 |     | // derivative of 'f(.)'. If 'getZeroForOne() == false', then we have:
 3952 |     | //
 3953 |     | //          d f
 3954 |     | //   '-------------- ==
 3955 |     | //     d qOvershoot
 3956 |     | //
 3957 |     | //    (
 3958 |     | //
 3959 |     | //        + (qOrigin + qOvershoot) / 2    originToOvershoot
 3960 |     | //      e                              * ------------------- -
 3961 |     | //                                              2
 3962 |     | //
 3963 |     | //        + (qTarget + qOvershoot) / 2    targetToOvershoot
 3964 |     | //      e                              * ------------------- +
 3965 |     | //                                              2
 3966 |     | //         - 8 + qOrigin / 2
 3967 |     | //       e
 3968 |     | //      --------------------- * k(qOvershoot - qOrigin) -
 3969 |     | //                2
 3970 |     | //
 3971 |     | //         - 8 + qTarget / 2
 3972 |     | //       e
 3973 |     | //      --------------------- * k(qOvershoot - qTarget)
 3974 |     | //                2
 3975 |     | //
 3976 |     | //    ) / integral1Incremented - (
 3977 |     | //
 3978 |     | //         - 8 - qOvershoot / 2
 3979 |     | //       e
 3980 |     | //      ------------------------ * k(qOvershoot - qTarget) - 
 3981 |     | //                  2
 3982 |     | //
 3983 |     | //         - 8 - qOvershoot / 2
 3984 |     | //       e
 3985 |     | //      ------------------------ * k(qOvershoot - qOrigin) 
 3986 |     | //                  2
 3987 |     | //
 3988 |     | //    ) / integral0Incremented'.
 3989 |     | //
 3990 |     | // If 'getZeroForOne() == true', then we have:
 3991 |     | //
 3992 |     | //          d f
 3993 |     | //   '-------------- ==
 3994 |     | //     d qOvershoot
 3995 |     | //
 3996 |     | //    (
 3997 |     | //
 3998 |     | //         - 8 + qOvershoot / 2
 3999 |     | //       e
 4000 |     | //      ------------------------ * k(qTarget - qOvershoot) - 
 4001 |     | //                  2
 4002 |     | //
 4003 |     | //         - 8 + qOvershoot / 2
 4004 |     | //       e
 4005 |     | //      ------------------------ * k(qOrigin - qOvershoot) 
 4006 |     | //                  2
 4007 |     | //
 4008 |     | //    ) / integral1Incremented - (
 4009 |     | //
 4010 |     | //        - (qOrigin + qOvershoot) / 2    originToOvershoot
 4011 |     | //      e                              * ------------------- -
 4012 |     | //                                              2
 4013 |     | //
 4014 |     | //        - (qTarget + qOvershoot) / 2    targetToOvershoot
 4015 |     | //      e                              * ------------------- +
 4016 |     | //                                              2
 4017 |     | //         - 8 - qOrigin / 2
 4018 |     | //       e
 4019 |     | //      --------------------- * k(qOrigin - qOvershoot) - 
 4020 |     | //                2
 4021 |     | //
 4022 |     | //         - 8 - qTarget / 2
 4023 |     | //       e
 4024 |     | //      --------------------- * k(qTarget - qOvershoot)
 4025 |     | //                2
 4026 |     | //
 4027 |     | //    ) / integral0Incremented'.
 4028 |     | //
 4029 |     | // After the calulation of 'qOvershoot', the amended values 'growthAmended', 
 4030 |     | // 'integral0Amended' and 'integral1Amended' are determined as follows:
 4031 |     | //
 4032 |     | //                         growth              growth
 4033 |     | //  'growthAmended == ---------------- == ----------------',
 4034 |     | //                     s0(qOvershoot)      s1(qOvershoot)
 4035 |     | //
 4036 |     | //                            - 8     / qUpper
 4037 |     | //    integral0Amended      e        |    - h / 2
 4038 |     | //  '------------------ := ------- * |  e         k(wAmended(h)) dh == 
 4039 |     | //        2 ** 216            2      |
 4040 |     | //                                  / qTarget
 4041 |     | //
 4042 |     | //                              growth        integral0Incremented
 4043 |     | //                         --------------- * ----------------------',
 4044 |     | //                          growthAmended           2 ** 216
 4045 |     | //
 4046 |     | //                            - 8     / qTarget
 4047 |     | //    integral1Amended      e        |    + h / 2
 4048 |     | //  '------------------ := ------- * |  e         k(wAmended(h)) dh == 
 4049 |     | //        2 ** 216            2      |
 4050 |     | //                                  / qLower
 4051 |     | //
 4052 |     | //                              growth        integral0Incremented
 4053 |     | //                         --------------- * ----------------------',
 4054 |     | //                          growthAmended           2 ** 216
 4055 |     | //
 4056 |     | // where the ranges covered by 'integral0Amended' and 'integral1Amended' are
 4057 |     | // illustrated as follows:
 4058 |     | //
 4059 |     | //                         integral0Amended
 4060 |     | //                         exp(- h / 2) * k(wAmended(h))
 4061 |     | //                                                      \
 4062 |     | //             integral1Amended                          \
 4063 |     | //             exp(+ h / 2) * k(wAmended(h))              \
 4064 |     | //      |<-------------------------------------->|<---------------->|
 4065 |     | //      |                                        |                  |
 4066 |     | //      +----------------------------------------+------------------+
 4067 |     | //      |                                        |                  |
 4068 |     | //    qLower                                  qTarget             qUpper
 4069 |     | //
 4070 |     | // In the following section, the memory pointers that are used for the purpose
 4071 |     | // of the above calculations are introduced.
 4072 |     | uint16 constant _interval_ = 644;
 4073 |     | 
 4074 |     | // The direction of the current 'phase' under exploration. Everytime that we
 4075 |     | // move from one 'phase' to the next, by decrementing 'indexCurve' this binary
 4076 |     | // value is flipped. 'direction' should not be confused with 'zeroForOne' which
 4077 |     | // does not change throughout a swap. Define:
 4078 |     | //
 4079 |     | //  'qEnd := q[indexCurve]'.
 4080 |     | //
 4081 |     | // 'direction = 0x00' if 'q[indexCurve + 2] < qEnd', i.e., when we are moving
 4082 |     | // towards '+oo', in search for 'qTarget' or 'qOvershoot'. In this case, for
 4083 |     | // every 'q[indexCurve + 2] < h < qEnd', we have:
 4084 |     | //
 4085 |     | //  'w(h) := h - qOrigin'.
 4086 |     | //
 4087 |     | // 'direction = 0xFF' if 'qEnd < q[indexCurve + 2]', i.e., when we are moving
 4088 |     | // towards '-oo', in search for 'qTarget' or 'qOvershoot'. In this case, for
 4089 |     | // every 'qEnd < h < q[indexCurve + 2]', we have:
 4090 |     | //
 4091 |     | //  'w(h) := qOrigin - h'.
 4092 |     | //
 4093 |     | uint16 constant _direction_ = 644;
 4094 |     | 
 4095 |     | // The index of 'qEnd' among the members of the 'curve', i.e.,
 4096 |     | //
 4097 |     | //  'qEnd == q[indexCurve]'.
 4098 |     | //
 4099 |     | // While searching for 'qTarget' and 'qOvershoot', the value of 'indexCurve'
 4100 |     | // starts from 'curveLength - twoIndex' and is decremented by 'oneIndex' with
 4101 |     | // each run of the function 'movePhase()' in 'Interval.sol'.
 4102 |     | uint16 constant _indexCurve_ = 645;
 4103 |     | 
 4104 |     | // The index of 'qTotal1' and 'cTotal1' among the breakpoints of the 'kernel',
 4105 |     | // i.e.,
 4106 |     | //
 4107 |     | //  'cTotal0 := c[indexKernelTotal - 1]',
 4108 |     | //
 4109 |     | //  'qTotal0 := direction ? 
 4110 |     | //              qOrigin - b[indexKernelTotal - 1] : 
 4111 |     | //              qOrigin + b[indexKernelTotal - 1]',
 4112 |     | //
 4113 |     | //  'cTotal1 == c[indexKernelTotal]',
 4114 |     | //
 4115 |     | //  'qTotal1 == direction ? 
 4116 |     | //              qOrigin - b[indexKernelTotal] : 
 4117 |     | //              qOrigin + b[indexKernelTotal]'.
 4118 |     | //
 4119 |     | // While searching for 'qTarget' and 'qOvershoot', the value of
 4120 |     | // 'indexKernelTotal' starts from 'oneIndex' and is incremented by 'oneIndex'
 4121 |     | // with each transition to a new piece of kernel as we explore 'k(w(h))'.
 4122 |     | //
 4123 |     | // If 'getDirection() == false', then we have:
 4124 |     | //
 4125 |     | //  'k(w(h)) == k(h - qOrigin) == k_indexKernelTotal(h - qOrigin) :=
 4126 |     | //
 4127 |     | //                         cTotal1 - cTotal0
 4128 |     | //              cTotal0 + ------------------- * (h - qTotal0)'.
 4129 |     | //                         qTotal1 - qTotal0
 4130 |     | //
 4131 |     | // for every 'qBegin < h < qTarget'.
 4132 |     | //
 4133 |     | // If 'getDirection() == true', then we have:
 4134 |     | //
 4135 |     | //  'k(w(h)) == k(qOrigin - h) == k_indexKernelTotal(qOrigin - h) :=
 4136 |     | //
 4137 |     | //                         cTotal1 - cTotal0
 4138 |     | //              cTotal0 + ------------------- * (qTotal0 - h)'.
 4139 |     | //                         qTotal0 - qTotal1
 4140 |     | //
 4141 |     | // for every 'qTarget < h < qBegin'.
 4142 |     | uint16 constant _indexKernelTotal_ = 647;
 4143 |     | 
 4144 |     | // The index of 'qForward1' and 'cForward1' among the breakpoints of the
 4145 |     | // 'kernel', i.e.,
 4146 |     | //
 4147 |     | //  'cForward0 := c[indexKernelForward - 1]',
 4148 |     | //
 4149 |     | //  'qForward0 := getZeroForOne() ? 
 4150 |     | //                qTarget - b[indexKernelForward - 1] : 
 4151 |     | //                qTarget + b[indexKernelForward - 1]',
 4152 |     | //
 4153 |     | //  'cForward1 := c[indexKernelForward]',
 4154 |     | //
 4155 |     | //  'qForward1 := getZeroForOne() ? 
 4156 |     | //                qTarget - b[indexKernelForward] : 
 4157 |     | //                qTarget + b[indexKernelForward]'.
 4158 |     | //
 4159 |     | // While searching for 'qOvershoot', the value of 'indexKernelForward' starts
 4160 |     | // from 'oneIndex' and is incremented by 'oneIndex' with each transition to a
 4161 |     | // new piece of kernel.
 4162 |     | //
 4163 |     | // If 'getZeroForOne() == false', then we have:
 4164 |     | //
 4165 |     | //  'k(h - qTarget) == k_indexKernelForward(h - qTarget) :=
 4166 |     | //
 4167 |     | //                                  cForward1 - cForward0
 4168 |     | //                     cForward0 + ----------------------- * (h - qForward0)'.
 4169 |     | //                                  qForward1 - qForward0
 4170 |     | //
 4171 |     | // for every 'qBegin < h < qOvershoot'.
 4172 |     | //
 4173 |     | // If 'getZeroForOne() == true', then we have:
 4174 |     | //
 4175 |     | //  'k(qTarget - h) == k_indexKernelForward(qTarget - h) :=
 4176 |     | //
 4177 |     | //                                  cForward1 - cForward0
 4178 |     | //                     cForward0 + ----------------------- * (qForward0 - h)'.
 4179 |     | //                                  qForward0 - qForward1
 4180 |     | //
 4181 |     | // for every 'qOvershoot < h < qBegin'.
 4182 |     | uint16 constant _indexKernelForward_ = 649;
 4183 |     | 
 4184 |     | // Let 'pLower' and 'pUpper' be the minimum and maximum price in the active
 4185 |     | // liquidity interval and define
 4186 |     | //
 4187 |     | //  'qLower := log(pLower / pOffset)',
 4188 |     | //  'qUpper := log(pUpper / pOffset)'.
 4189 |     | //  'qLimitWithinInterval := min(max(qLower, qLimit), qUpper)'
 4190 |     | //
 4191 |     | // The value set as 'logPriceLimitOffsetted' may be outside of the current
 4192 |     | // active liquidity interval. In such cases, we first need to perform a swap
 4193 |     | // towards the current interval boundary and then we transition to a new
 4194 |     | // interval. In order to perform the former step, 'qLimitWithinInterval' is
 4195 |     | // calculated and its offset binary 'X59' representation, i.e.,
 4196 |     | //
 4197 |     | //  '_origin_.log() := (2 ** 59) * (16 + qOrigin)'
 4198 |     | //
 4199 |     | // is stored in the memory space which pointed to by
 4200 |     | // '_logPriceLimitOffsettedWithinInterval_'.
 4201 |     | uint16 constant _logPriceLimitOffsettedWithinInterval_ = 651;
 4202 |     | 
 4203 |     | // Let 'pCurrent' represent the current price within the active liquidity
 4204 |     | // interval (prior to the movement to 'qTarget' or 'qNext'). This value
 4205 |     | // corresponds to the last member of the curve. Define:
 4206 |     | //
 4207 |     | //  'qCurrent := log(pCurrent / pOffset)',
 4208 |     | //
 4209 |     | // The 62 bytes memory space which is pointed to by '_current_' hosts the
 4210 |     | // following values:
 4211 |     | //
 4212 |     | //  '_current_.log() := (2 ** 59) * (16 + qCurrent)',
 4213 |     | //  '_current_.sqrt(false) := (2 ** 216) * exp(- 8 - qCurrent / 2)',
 4214 |     | //  '_current_.sqrt(true) := (2 ** 216) * exp(- 8 + qCurrent / 2)'.
 4215 |     | //
 4216 |     | // which can be accessed via 'PriceLibrary'. The logarithmic price
 4217 |     | // '_current_.log()' occupies 64 bits, whereas '_current_.sqrt(false)' and
 4218 |     | // '_current_.sqrt(true)' occupy 216 bits each.
 4219 |     | uint16 constant _current_ = 659;
 4220 |     | 
 4221 |     | // Let 'indexCurve' represent the index of the current phase under exploration.
 4222 |     | // Define:
 4223 |     | //
 4224 |     | //  'qOrigin := q[indexCurve + 1]',
 4225 |     | //
 4226 |     | //  'qEnd := q[indexCurve]'.
 4227 |     | //
 4228 |     | // If 'getDirection() == false', for every 'q[indexCurve + 2] < h < qEnd', we
 4229 |     | // have:
 4230 |     | //
 4231 |     | //  'w(h) := h - qOrigin'.
 4232 |     | //
 4233 |     | // If 'getDirection() == true', for every 'qEnd < h < q[indexCurve + 2]', we
 4234 |     | // have:
 4235 |     | //
 4236 |     | //  'w(h) := qOrigin - h'.
 4237 |     | //
 4238 |     | // The 62 bytes memory space which is pointed to by '_origin_' hosts the
 4239 |     | // following values:
 4240 |     | //
 4241 |     | //  '_origin_.log() := (2 ** 59) * (16 + qOrigin)',
 4242 |     | //  '_origin_.sqrt(false) := (2 ** 216) * exp(- 8 - qOrigin / 2)',
 4243 |     | //  '_origin_.sqrt(true) := (2 ** 216) * exp(- 8 + qOrigin / 2)'.
 4244 |     | //
 4245 |     | // which can be accessed via 'PriceLibrary'. The logarithmic price
 4246 |     | // '_origin_.log()' occupies 64 bits, whereas '_origin_.sqrt(false)' and
 4247 |     | // '_origin_.sqrt(true)' occupy 216 bits each.
 4248 |     | uint16 constant _origin_ = 721;
 4249 |     | 
 4250 |     | // At every step of searching for 'qTarget', the range
 4251 |     | //
 4252 |     | //  'min(qBegin, qTarget) < h < max(qBegin, qTarget)'
 4253 |     | //
 4254 |     | // represents a piece of the liquidity distribution function 'k(w(.))' in which
 4255 |     | // 'k(w(.))' is linear. More precisely, if 'getDirection() == false', we have:
 4256 |     | //
 4257 |     | //  'k(w(h)) == k(h - qOrigin) == k_indexKernelTotal(h - qOrigin) :=
 4258 |     | //
 4259 |     | //                         cTotal1 - cTotal0
 4260 |     | //              cTotal0 + ------------------- * (h - qTotal0)'.
 4261 |     | //                         qTotal1 - qTotal0
 4262 |     | //
 4263 |     | // for every 'qBegin < h < qTarget' and if 'getDirection() == true', we have:
 4264 |     | //
 4265 |     | //  'k(w(h)) == k(qOrigin - h) == k_indexKernelTotal(qOrigin - h) :=
 4266 |     | //
 4267 |     | //                         cTotal1 - cTotal0
 4268 |     | //              cTotal0 + ------------------- * (qTotal0 - h)'.
 4269 |     | //                         qTotal0 - qTotal1
 4270 |     | //
 4271 |     | // for every 'qTarget < h < qBegin'.
 4272 |     | //
 4273 |     | // At the stage where we search for 'qTarget', we have
 4274 |     | //
 4275 |     | //  'qBegin := direction ? 
 4276 |     | //             min(q[indexCurve + 2], qTotal0) : 
 4277 |     | //             max(q[indexCurve + 2], qTotal0)'.
 4278 |     | //
 4279 |     | // At every step of searching for 'qOvershoot', the following inequality
 4280 |     | //
 4281 |     | //  'min(qBegin, qOvershoot) < h < max(qBegin, qOvershoot)'
 4282 |     | //
 4283 |     | // represents a range in which both 'k(w(.))' and 'k(|. - qTarget|)' are
 4284 |     | // linear. More precisely, if 'getZeroForOne() == false', we have:
 4285 |     | //
 4286 |     | //  'k(h - qTarget) == k_indexKernelForward(h - qTarget) :=
 4287 |     | //
 4288 |     | //                                  cForward1 - cForward0
 4289 |     | //                     cForward0 + ----------------------- * (h - qForward0)'.
 4290 |     | //                                  qForward1 - qForward0
 4291 |     | //
 4292 |     | // for every 'qBegin < h < qOvershoot' and if 'getZeroForOne() == true', we
 4293 |     | // have:
 4294 |     | //
 4295 |     | //  'k(qTarget - h) == k_indexKernelForward(qTarget - h) :=
 4296 |     | //
 4297 |     | //                                  cForward1 - cForward0
 4298 |     | //                     cForward0 + ----------------------- * (qForward0 - h)'.
 4299 |     | //                                  qForward0 - qForward1
 4300 |     | //
 4301 |     | // for every 'qOvershoot < h < qBegin'.
 4302 |     | //
 4303 |     | // At the stage where we search for 'qOvershoot', we have
 4304 |     | //
 4305 |     | //  'qBegin := (
 4306 |     | //               direction == getZeroForOne()
 4307 |     | //             ) ? (
 4308 |     | //               direction ? 
 4309 |     | //               max(max(q[indexCurve + 2], qTotal0), qForward0) : 
 4310 |     | //               min(min(q[indexCurve + 2], qTotal0), qForward0)
 4311 |     | //             ) : (
 4312 |     | //               direction ? 
 4313 |     | //               max(q[indexCurve + 2], qTotal0) : 
 4314 |     | //               min(q[indexCurve + 2], qTotal0)
 4315 |     | //             )',
 4316 |     | //
 4317 |     | // The 62 bytes memory space which is pointed to by '_begin_' hosts the
 4318 |     | // following values:
 4319 |     | //
 4320 |     | //  '_begin_.log() := (2 ** 59) * (16 + qBegin)',
 4321 |     | //  '_begin_.sqrt(false) := (2 ** 216) * exp(- 8 - qBegin / 2)',
 4322 |     | //  '_begin_.sqrt(true) := (2 ** 216) * exp(- 8 + qBegin / 2)'.
 4323 |     | //
 4324 |     | // which can be accessed via 'PriceLibrary'. The logarithmic price
 4325 |     | // '_begin_.log()' occupies 64 bits, whereas '_begin_.sqrt(false)' and
 4326 |     | // '_begin_.sqrt(true)' occupy 216 bits each.
 4327 |     | uint16 constant _begin_ = 783;
 4328 |     | 
 4329 |     | // Let 'indexCurve' represent the index of the current phase under exploration.
 4330 |     | // Define:
 4331 |     | //
 4332 |     | //  'qOrigin := q[indexCurve + 1]',
 4333 |     | //
 4334 |     | //  'qEnd := q[indexCurve]'.
 4335 |     | //
 4336 |     | // If 'getDirection() == false', for every 'q[indexCurve + 2] < h < qEnd', we
 4337 |     | // have:
 4338 |     | //
 4339 |     | //  'w(h) := h - qOrigin'.
 4340 |     | //
 4341 |     | // If 'getDirection() == true', for every 'qEnd < h < q[indexCurve + 2]', we
 4342 |     | // have:
 4343 |     | //
 4344 |     | //  'w(h) := qOrigin - h'.
 4345 |     | //
 4346 |     | // The 62 bytes memory space which is pointed to by '_end_' hosts the following
 4347 |     | // values:
 4348 |     | //
 4349 |     | //  '_end_.log() := (2 ** 59) * (16 + qEnd)',
 4350 |     | //  '_end_.sqrt(false) := (2 ** 216) * exp(- 8 - qEnd / 2)',
 4351 |     | //  '_end_.sqrt(true) := (2 ** 216) * exp(- 8 + qEnd / 2)'.
 4352 |     | //
 4353 |     | // which can be accessed via 'PriceLibrary'. The logarithmic price
 4354 |     | // '_end_.log()' occupies 64 bits, whereas '_end_.sqrt(false)' and
 4355 |     | // '_end_.sqrt(true)' occupy 216 bits each.
 4356 |     | uint16 constant _end_ = 845;
 4357 |     | 
 4358 |     | // Every visit to a liquidity interval as part of a swap involves the movement
 4359 |     | // of price from 'pCurrent' to 'pTarget'. Define:
 4360 |     | //
 4361 |     | //  'qCurrent := log(pCurrent / pOffset)',
 4362 |     | //  'qTarget := log(pTarget / pOffset)',
 4363 |     | //
 4364 |     | // and assume that
 4365 |     | //
 4366 |     | //  'qLower <= qCurrent <= qUpper',
 4367 |     | //  'qLower <= qTarget <= qUpper',
 4368 |     | //
 4369 |     | // where '[qLower, qUpper]' represents the current active liquidity interval.
 4370 |     | //
 4371 |     | // At first 'qTarget' is an unknown value which will be determined based on one
 4372 |     | // of the followings:
 4373 |     | //
 4374 |     | //  - 'qLimitWithinInterval', which is calculated based on the input
 4375 |     | //    'logPriceLimit' as well as 'qLower' and 'qUpper'. It is stored in the
 4376 |     | //    memory space which is pointed to by
 4377 |     | //    '_logPriceLimitOffsettedWithinInterval_'.
 4378 |     | //
 4379 |     | //  - 'integralLimit', which is calculated based on the input 'amountSpecified'
 4380 |     | //    and is stored in the memory space which is pointed to by
 4381 |     | //    '_integralLimit_'.
 4382 |     | //
 4383 |     | // After determination of 'qTarget', the amounts of 'tag0' and 'tag1' to be
 4384 |     | // exchanged as a result of the movement within '[qLower, qUpper]' are equal
 4385 |     | // to:
 4386 |     | //
 4387 |     | //                                                         growth
 4388 |     | //  'amount0Partial := sqrtInverseOffset * sharesTotal * ---------- *
 4389 |     | //                                                        2 ** 111
 4390 |     | //
 4391 |     | //                      - 8     / max(qCurrent, qTarget)
 4392 |     | //         1          e        |                         - h / 2
 4393 |     | //   ------------- * ------- * |                       e         k(w(h)) dh',
 4394 |     | //    outgoingMax       2      |
 4395 |     | //                            / min(qCurrent, qTarget)
 4396 |     | //
 4397 |     | // and
 4398 |     | //                                                  growth
 4399 |     | //  'amount1Partial := sqrtOffset * sharesTotal * ---------- *
 4400 |     | //                                                 2 ** 111
 4401 |     | //
 4402 |     | //                      - 8     / max(qCurrent, qTarget)
 4403 |     | //         1          e        |                         + h / 2
 4404 |     | //   ------------- * ------- * |                       e         k(w(h)) dh',
 4405 |     | //    outgoingMax       2      |
 4406 |     | //                            / min(qCurrent, qTarget)
 4407 |     | //
 4408 |     | // where the parameters 'sqrtInverseOffset', 'sqrtOffset', 'sharesTotal',
 4409 |     | // 'growth', and 'outgoingMax' remain fixed throughout the movement from
 4410 |     | // 'qCurrent' to 'qTarget'.
 4411 |     | //
 4412 |     | // In search for 'qTarget', we first need to enumerate the pieces of 'k(w(.))',
 4413 |     | // one by one, until we discover the piece to which 'qTarget' belongs. While 
 4414 |     | // enumerating the pieces of 'k(w(.))', one end of the current piece under
 4415 |     | // exploration is 'qBegin' and the other end is temporarily referred to as:
 4416 |     | //
 4417 |     | //  'qTarget := (
 4418 |     | //                direction == getZeroForOne()
 4419 |     | //              ) ? (
 4420 |     | //                direction ? 
 4421 |     | //                max(max(qEnd, qTotal1), qLimitWithinInterval) : 
 4422 |     | //                min(min(qEnd, qTotal1), qLimitWithinInterval)
 4423 |     | //              ) : (
 4424 |     | //                direction ? 
 4425 |     | //                max(qEnd, qTotal1) : 
 4426 |     | //                min(qEnd, qTotal1)
 4427 |     | //              )'.
 4428 |     | //
 4429 |     | // After the correct piece is determined, we perform a numerical search via
 4430 |     | // either of the methods 'searchOutgoingTarget' or 'searchIncomingTarget' in
 4431 |     | // 'Interval.sol' in order to pinpoint the precise value of 'qTarget'.
 4432 |     | //
 4433 |     | // At every step of searching for the piece to which 'qTarget' belongs, if 
 4434 |     | // 'getDirection() == false', we have:
 4435 |     | //
 4436 |     | //  'k(w(h)) == k(h - qOrigin) == k_indexKernelTotal(h - qOrigin) :=
 4437 |     | //
 4438 |     | //                         cTotal1 - cTotal0
 4439 |     | //              cTotal0 + ------------------- * (h - qTotal0)'.
 4440 |     | //                         qTotal1 - qTotal0
 4441 |     | //
 4442 |     | // for every 'qBegin < h < qTarget' and if 'getDirection() == true', we have:
 4443 |     | //
 4444 |     | //  'k(w(h)) == k(qOrigin - h) == k_indexKernelTotal(qOrigin - h) :=
 4445 |     | //
 4446 |     | //                         cTotal1 - cTotal0
 4447 |     | //              cTotal0 + ------------------- * (qTotal0 - h)'.
 4448 |     | //                         qTotal0 - qTotal1
 4449 |     | //
 4450 |     | // for every 'qTarget < h < qBegin'.
 4451 |     | //
 4452 |     | // The 62 bytes memory space which is pointed to by '_target_' hosts the
 4453 |     | // following values:
 4454 |     | //
 4455 |     | //  '_target_.log() := (2 ** 59) * (16 + qTarget)',
 4456 |     | //  '_target_.sqrt(false) := (2 ** 216) * exp(- 8 - qTarget / 2)',
 4457 |     | //  '_target_.sqrt(true) := (2 ** 216) * exp(- 8 + qTarget / 2)'.
 4458 |     | //
 4459 |     | // which can be accessed via 'PriceLibrary'. The logarithmic price
 4460 |     | // '_target_.log()' occupies 64 bits, whereas '_target_.sqrt(false)' and
 4461 |     | // '_target_.sqrt(true)' occupy 216 bits each.
 4462 |     | uint16 constant _target_ = 907;
 4463 |     | 
 4464 |     | // Assume that we are in the process of doing a swap within an interval for
 4465 |     | // which 'qTarget' as well as both 'amount0Partial' and 'amount1Partial' are
 4466 |     | // determined. Let '[qLower, pUpper]' represent the active liquidity interval
 4467 |     | // and define:
 4468 |     | //
 4469 |     | // Now we need to update the curve in preparation for the next swap. Before
 4470 |     | // doing so, define:
 4471 |     | //
 4472 |     | //                                - 8     / qUpper
 4473 |     | //    integral0Incremented      e        |    - h / 2
 4474 |     | //  '---------------------- := ------- * |  e         k(w(h)) dh',
 4475 |     | //          2 ** 216              2      |
 4476 |     | //                                      / qTarget
 4477 |     | //
 4478 |     | //                                - 8     / qTarget
 4479 |     | //    integral1Incremented      e        |    + h / 2
 4480 |     | //  '---------------------- := ------- * |  e         k(w(h)) dh'.
 4481 |     | //          2 ** 216              2      |
 4482 |     | //                                      / qLower
 4483 |     | //
 4484 |     | // Then we have:
 4485 |     | //
 4486 |     | //                                                                   growth
 4487 |     | //  'totalReserveOfTag0Before := sqrtInverseOffset * sharesTotal * ---------- * 
 4488 |     | //                                                                  2 ** 111
 4489 |     | //    integral0Incremented
 4490 |     | //   ----------------------'
 4491 |     | //        outgoingMax
 4492 |     | //
 4493 |     | //                                                            growth
 4494 |     | //  'totalReserveOfTag1Before := sqrtOffset * sharesTotal * ---------- * 
 4495 |     | //                                                           2 ** 111
 4496 |     | //    integral1Incremented
 4497 |     | //   ----------------------'
 4498 |     | //        outgoingMax
 4499 |     | //
 4500 |     | // Now, assume that the curve sequence is updated and the function 'w' is
 4501 |     | // transformed into a new function 'wAmended' which is constructed based on the
 4502 |     | // updated curve sequence. Then, we can similarly define:
 4503 |     | //
 4504 |     | //                            - 8     / qUpper
 4505 |     | //    integral0Amended      e        |    - h / 2
 4506 |     | //  '------------------ := ------- * |  e         k(wAmended(h)) dh',
 4507 |     | //        2 ** 216            2      |
 4508 |     | //                                  / qTarget
 4509 |     | //
 4510 |     | //                            - 8     / qTarget
 4511 |     | //    integral1Amended      e        |    + h / 2
 4512 |     | //  '------------------ := ------- * |  e         k(wAmended(h)) dh'.
 4513 |     | //        2 ** 216            2      |
 4514 |     | //                                  / qLower
 4515 |     | //
 4516 |     | // Then we have:
 4517 |     | //
 4518 |     | //  'totalReserveOfTag0After := sqrtInverseOffset * sharesTotal *
 4519 |     | //
 4520 |     | //    growthAmended     integral0Amended
 4521 |     | //   --------------- * ------------------'
 4522 |     | //      2 ** 111          outgoingMax
 4523 |     | //
 4524 |     | //  'totalReserveOfTag1After := sqrtOffset * sharesTotal * 
 4525 |     | //
 4526 |     | //    growthAmended     integral1Amended
 4527 |     | //   --------------- * ------------------'
 4528 |     | //      2 ** 111          outgoingMax
 4529 |     | //
 4530 |     | // Now, we need to make sure that the reserve amounts before and after the
 4531 |     | // curve update are the same, which means that:
 4532 |     | //
 4533 |     | //  'totalReserveOfTag0Before == totalReserveOfTag0After'
 4534 |     | //  'totalReserveOfTag1Before == totalReserveOfTag1After'
 4535 |     | //
 4536 |     | // This leads to the following two equations:
 4537 |     | // 
 4538 |     | //       growth            integral0Amended
 4539 |     | //  '--------------- == ----------------------'
 4540 |     | //    growthAmended      integral0Incremented
 4541 |     | // 
 4542 |     | //       growth            integral1Amended
 4543 |     | //  '--------------- == ----------------------'
 4544 |     | //    growthAmended      integral1Incremented
 4545 |     | //
 4546 |     | // Hence, we must have:
 4547 |     | //
 4548 |     | //      integral0Amended          integral1Amended
 4549 |     | //  '---------------------- == ----------------------'
 4550 |     | //    integral0Incremented      integral1Incremented
 4551 |     | //
 4552 |     | // which means that:
 4553 |     | //
 4554 |     | //      / qUpper                          / qTarget
 4555 |     | //     |   - h/2                         |   + h/2
 4556 |     | //     |  e      k(wAmended(h)) dh       |  e      k(wAmended(h)) dh
 4557 |     | //     |                                 |
 4558 |     | //    / qTarget                         / qLower
 4559 |     | //  '------------------------------ == ------------------------------'.
 4560 |     | //         / qUpper                          / qTarget
 4561 |     | //        |    - h/2                        |    + h/2
 4562 |     | //        |  e       k(w(h)) dh             |  e       k(w(h)) dh
 4563 |     | //        |                                 |
 4564 |     | //       / qTarget                         / qLower
 4565 |     | //
 4566 |     | // As a result, we should update the curve in such a way that the above
 4567 |     | // equality is satisfied.
 4568 |     | //
 4569 |     | // To that end, once 'qOvershoot' and both 'amount0Partial' and
 4570 |     | // 'amount1Partial' are determined, the curve sequence is amended with
 4571 |     | // 'qOvershoot' and then 'qTarget'.
 4572 |     | //
 4573 |     | // If 'getZeroForOne() == false' then 'qTarget <= qOvershoot' and if
 4574 |     | // 'getZeroForOne() == true' then 'qOvershoot <= qTarget'. Assume that
 4575 |     | // 'wAmended' is constructed from the amended curve sequence. 'qOvershoot' is
 4576 |     | // calculated in such a way that the above equality holds for the amended
 4577 |     | // curve. The process of searching for 'qOvershoot' is further explained at
 4578 |     | // the beginning of this section.
 4579 |     | //
 4580 |     | // The 62 bytes memory space which is pointed to by '_overshoot_' hosts the
 4581 |     | // following values:
 4582 |     | //
 4583 |     | //  '_overshoot_.log() := (2 ** 59) * (16 + qOvershoot)',
 4584 |     | //  '_overshoot_.sqrt(false) := (2 ** 216) * exp(- 8 - qOvershoot / 2)',
 4585 |     | //  '_overshoot_.sqrt(true) := (2 ** 216) * exp(- 8 + qOvershoot / 2)'.
 4586 |     | //
 4587 |     | // which can be accessed via 'PriceLibrary'. The logarithmic price
 4588 |     | // '_overshoot_.log()' occupies 64 bits, whereas '_overshoot_.sqrt(false)' and
 4589 |     | // '_overshoot_.sqrt(true)' occupy 216 bits each.
 4590 |     | uint16 constant _overshoot_ = 969;
 4591 |     | 
 4592 |     | // At every step of searching for 'qTarget', the range
 4593 |     | //
 4594 |     | //  'min(qBegin, qTarget) < h < max(qBegin, qTarget)'
 4595 |     | //
 4596 |     | // represents a piece of the liquidity distribution function 'k(w(.))' in which
 4597 |     | // 'k(w(.))' is linear. More precisely, if 'getDirection() == false', we have:
 4598 |     | //
 4599 |     | //  'k(w(h)) == k(h - qOrigin) == k_indexKernelTotal(h - qOrigin) :=
 4600 |     | //
 4601 |     | //                         cTotal1 - cTotal0
 4602 |     | //              cTotal0 + ------------------- * (h - qTotal0)'.
 4603 |     | //                         qTotal1 - qTotal0
 4604 |     | //
 4605 |     | // for every 'qBegin < h < qTarget' and if 'getDirection() == true', we have:
 4606 |     | //
 4607 |     | //  'k(w(h)) == k(qOrigin - h) == k_indexKernelTotal(qOrigin - h) :=
 4608 |     | //
 4609 |     | //                         cTotal1 - cTotal0
 4610 |     | //              cTotal0 + ------------------- * (qTotal0 - h)'.
 4611 |     | //                         qTotal0 - qTotal1
 4612 |     | //
 4613 |     | // for every 'qTarget < h < qBegin', where:
 4614 |     | //
 4615 |     | //  'cTotal0 := c[indexKernelTotal - 1]',
 4616 |     | //
 4617 |     | //  'qTotal0 := direction ? 
 4618 |     | //              qOrigin - b[indexKernelTotal - 1] : 
 4619 |     | //              qOrigin + b[indexKernelTotal - 1]',
 4620 |     | //
 4621 |     | //  'cTotal1 := c[indexKernelTotal]',
 4622 |     | //
 4623 |     | //  'qTotal1 := direction ? 
 4624 |     | //              qOrigin - b[indexKernelTotal] : 
 4625 |     | //              qOrigin + b[indexKernelTotal]'.
 4626 |     | //
 4627 |     | // The pair '(cTotal0, qTotal0)' is stored in the memory space which is pointed
 4628 |     | // to by '_total0_' and similarly, the pair '(cTotal1, qTotal1)' is stored in
 4629 |     | // the memory space which is pointed to by '_total1_'.
 4630 |     | //
 4631 |     | // The 64 bytes memory space which is pointed to by '_total0_' hosts the
 4632 |     | // following values:
 4633 |     | //
 4634 |     | //  '_total0_.height() := (2 ** 15) * cTotal0',
 4635 |     | //  '_total0_.log() := (2 ** 59) * (16 + qTotal0)',
 4636 |     | //  '_total0_.sqrt(false) := (2 ** 216) * exp(- 8 - qTotal0 / 2)',
 4637 |     | //  '_total0_.sqrt(true) := (2 ** 216) * exp(- 8 + qTotal0 / 2)'.
 4638 |     | //
 4639 |     | // which can be accessed via 'PriceLibrary'. The vertical coordinate
 4640 |     | // '_total0_.height()' occupies 16 bits, the logarithmic price '_total0_.log()'
 4641 |     | // occupies 64 bits, whereas '_total0_.sqrt(false)' and '_total0_.sqrt(true)'
 4642 |     | // occupy 216 bits each.
 4643 |     | //
 4644 |     | // The 64 bytes memory space which is pointed to by '_total1_' hosts the
 4645 |     | // following values:
 4646 |     | //
 4647 |     | //  '_total1_.height() := (2 ** 15) * cTotal1',
 4648 |     | //  '_total1_.log() := (2 ** 59) * (16 + qTotal1)',
 4649 |     | //  '_total1_.sqrt(false) := (2 ** 216) * exp(- 8 - qTotal1 / 2)',
 4650 |     | //  '_total1_.sqrt(true) := (2 ** 216) * exp(- 8 + qTotal1 / 2)'.
 4651 |     | //
 4652 |     | // which can be accessed via 'PriceLibrary'. The vertical coordinate
 4653 |     | // '_total1_.height()' occupies 16 bits, the logarithmic price '_total1_.log()'
 4654 |     | // occupies 64 bits, whereas '_total1_.sqrt(false)' and '_total1_.sqrt(true)'
 4655 |     | // occupy 216 bits each.
 4656 |     | uint16 constant _total0_ = 1033;
 4657 |     | uint16 constant _total1_ = 1097;
 4658 |     | 
 4659 |     | // At every step of searching for 'qOvershoot', the range
 4660 |     | //
 4661 |     | //  'min(qBegin, qOvershoot) < h < max(qBegin, qOvershoot)'
 4662 |     | //
 4663 |     | // represents a piece of 'k(|. - qTarget|)'. If 'getZeroForOne() == false',
 4664 |     | // then we have:
 4665 |     | //
 4666 |     | //  'k(h - qTarget) == k_indexKernelForward(h - qTarget) :=
 4667 |     | //
 4668 |     | //                                  cForward1 - cForward0
 4669 |     | //                     cForward0 + ----------------------- * (h - qForward0)',
 4670 |     | //                                  qForward1 - qForward0
 4671 |     | //
 4672 |     | // for every 'qBegin < h < qOvershoot' and if 'getZeroForOne() == true', then
 4673 |     | // we have:
 4674 |     | //
 4675 |     | //  'k(qTarget - h) == k_indexKernelForward(qTarget - h) :=
 4676 |     | //
 4677 |     | //                                  cForward1 - cForward0
 4678 |     | //                     cForward0 + ----------------------- * (qForward0 - h)',
 4679 |     | //                                  qForward0 - qForward1
 4680 |     | //
 4681 |     | // for every 'qOvershoot < h < qBegin' where
 4682 |     | //
 4683 |     | //  'cForward0 := c[indexKernelForward - 1]',
 4684 |     | //
 4685 |     | //  'qForward0 := getZeroForOne() ? 
 4686 |     | //                qTarget - b[indexKernelForward - 1] : 
 4687 |     | //                qTarget + b[indexKernelForward - 1]',
 4688 |     | //
 4689 |     | //  'cForward1 := c[indexKernelForward]',
 4690 |     | //
 4691 |     | //  'qForward1 := getZeroForOne() ? 
 4692 |     | //                qTarget - b[indexKernelForward] : 
 4693 |     | //                qTarget + b[indexKernelForward]'.
 4694 |     | //
 4695 |     | // The pair '(cForward0, qForward0)' is stored in the memory space which is
 4696 |     | // pointed to by '_forward0_' and similarly, the pair '(cForward1, qForward1)'
 4697 |     | // is stored in the memory space which is pointed to by '_forward1_'.
 4698 |     | //
 4699 |     | // The 64 bytes memory space which is pointed to by '_forward0_' hosts the
 4700 |     | // following values:
 4701 |     | //
 4702 |     | //  '_forward0_.height() := (2 ** 15) * cForward0',
 4703 |     | //  '_forward0_.log() := (2 ** 59) * (16 + qForward0)',
 4704 |     | //  '_forward0_.sqrt(false) := (2 ** 216) * exp(- 8 - qForward0 / 2)',
 4705 |     | //  '_forward0_.sqrt(true) := (2 ** 216) * exp(- 8 + qForward0 / 2)'.
 4706 |     | //
 4707 |     | // which can be accessed via 'PriceLibrary'. The vertical coordinate
 4708 |     | // '_forward0_.height()' occupies 16 bits, the logarithmic price
 4709 |     | // '_forward0_.log()' occupies 64 bits, whereas '_forward0_.sqrt(false)' and
 4710 |     | // '_forward0_.sqrt(true)' occupy 216 bits each.
 4711 |     | //
 4712 |     | // The 64 bytes memory space which is pointed to by '_forward1_' hosts the
 4713 |     | // following values:
 4714 |     | //
 4715 |     | //  '_forward1_.height() := (2 ** 15) * cForward1',
 4716 |     | //  '_forward1_.log() := (2 ** 59) * (16 + qForward1)',
 4717 |     | //  '_forward1_.sqrt(false) := (2 ** 216) * exp(- 8 - qForward1 / 2)',
 4718 |     | //  '_forward1_.sqrt(true) := (2 ** 216) * exp(- 8 + qForward1 / 2)'.
 4719 |     | //
 4720 |     | // which can be accessed via 'PriceLibrary'. The vertical coordinate
 4721 |     | // '_forward1_.height()' occupies 16 bits, the logarithmic price
 4722 |     | // '_forward1_.log()' occupies 64 bits, whereas '_forward1_.sqrt(false)' and
 4723 |     | // '_forward1_.sqrt(true)' occupy 216 bits each.
 4724 |     | uint16 constant _forward0_ = 1161;
 4725 |     | uint16 constant _forward1_ = 1225;
 4726 |     | 
 4727 |     | // While searching for 'qTarget', the integral 'incomingCurrentToTarget' is
 4728 |     | // calculated. This integral is defined as follows:
 4729 |     | //
 4730 |     | //                                   - 8
 4731 |     | //    incomingCurrentToTarget      e
 4732 |     | //  '------------------------- := ------- * (
 4733 |     | //           2 ** 216                2
 4734 |     | //
 4735 |     | //                         / qCurrent                 / qTarget
 4736 |     | //                        |    - h / 2               |    + h / 2
 4737 |     | //     getZeroForOne() ?  |  e         k(w(h)) dh :  |  e         k(w(h)) dh
 4738 |     | //                        |                          |
 4739 |     | //                       / qTarget                  / qCurrent
 4740 |     | //
 4741 |     | //   )'.
 4742 |     | //
 4743 |     | // The pointer below refers to the above integral in 'X216' representation
 4744 |     | // which takes up to 27 bytes.
 4745 |     | uint16 constant _incomingCurrentToTarget_ = 1287;
 4746 |     | 
 4747 |     | // While searching for 'qTarget', the integral 'currentToTarget' is calculated.
 4748 |     | // This integral is defined as follows:
 4749 |     | //
 4750 |     | //                           - 8
 4751 |     | //    currentToTarget      e
 4752 |     | //  '----------------- := ------- * (
 4753 |     | //       2 ** 216            2
 4754 |     | //
 4755 |     | //                         / qCurrent                 / qTarget
 4756 |     | //                        |    + h / 2               |    - h / 2
 4757 |     | //     getZeroForOne() ?  |  e         k(w(h)) dh :  |  e         k(w(h)) dh
 4758 |     | //                        |                          |
 4759 |     | //                       / qTarget                  / qCurrent
 4760 |     | //
 4761 |     | //   )'
 4762 |     | //
 4763 |     | // The pointer below refers to the above integral in 'X216' representation
 4764 |     | // which takes up to 27 bytes.
 4765 |     | uint16 constant _currentToTarget_ = 1314;
 4766 |     | 
 4767 |     | // While searching for 'qTarget' and 'qOvershoot', we need to calculate the
 4768 |     | // following integral:
 4769 |     | //
 4770 |     | //                           - 8
 4771 |     | //    currentToOrigin      e
 4772 |     | //  '----------------- := ------- * (
 4773 |     | //       2 ** 216            2
 4774 |     | //
 4775 |     | //                         / qOrigin                  / qCurrent
 4776 |     | //                        |    - h / 2               |    + h / 2
 4777 |     | //     getZeroForOne() ?  |  e         k(w(h)) dh :  |  e         k(w(h)) dh
 4778 |     | //                        |                          |
 4779 |     | //                       / qCurrent                 / qOrigin
 4780 |     | //
 4781 |     | //   )'.
 4782 |     | //
 4783 |     | // 'currentToOrigin' is used for the calculation of 'overshoot' as discussed in
 4784 |     | // 'Interval.sol'.
 4785 |     | //
 4786 |     | // The pointer below refers to the above integral in 'X216' representation
 4787 |     | // which takes up to 27 bytes.
 4788 |     | uint16 constant _currentToOrigin_ = 1341;
 4789 |     | 
 4790 |     | // While searching for 'qTarget' and 'qOvershoot', we need to calculate the
 4791 |     | // following integral:
 4792 |     | //
 4793 |     | //                              - 8
 4794 |     | //    currentToOvershoot      e
 4795 |     | //  '-------------------- := ------- * (
 4796 |     | //         2 ** 216             2
 4797 |     | //
 4798 |     | //                         / qCurrent                 / qOvershoot
 4799 |     | //                        |    + h / 2               |    - h / 2
 4800 |     | //     getZeroForOne() ?  |  e         k(w(h)) dh :  |  e         k(w(h)) dh
 4801 |     | //                        |                          |
 4802 |     | //                       / qOvershoot               / qCurrent
 4803 |     | //
 4804 |     | //   )'
 4805 |     | //
 4806 |     | // 'currentToOvershoot' is used for the calculation of 'overshoot' as discussed
 4807 |     | // in 'Interval.sol'.
 4808 |     | //
 4809 |     | // The pointer below refers to the above integral in 'X216' representation
 4810 |     | // which takes up to 27 bytes.
 4811 |     | uint16 constant _currentToOvershoot_ = 1368;
 4812 |     | 
 4813 |     | // While searching for 'qOvershoot', we need to calculate the following
 4814 |     | // integral:
 4815 |     | //
 4816 |     | //                             - 8
 4817 |     | //    targetToOvershoot      e
 4818 |     | //  '------------------- := ------- * (
 4819 |     | //         2 ** 216            2
 4820 |     | //
 4821 |     | //     getZeroForOne()
 4822 |     | //
 4823 |     | //         / qTarget
 4824 |     | //        |    + h / 2
 4825 |     | //     ?  |  e         k(qTarget - h) dh
 4826 |     | //        |
 4827 |     | //       / qOvershoot
 4828 |     | //
 4829 |     | //         / qOvershoot
 4830 |     | //        |    - h / 2
 4831 |     | //     :  |  e         k(h - qTarget) dh
 4832 |     | //        |
 4833 |     | //       / qTarget
 4834 |     | //
 4835 |     | //   )'
 4836 |     | //
 4837 |     | // 'targetToOvershoot' is used for the calculation of 'overshoot' as discussed
 4838 |     | // in 'Interval.sol'.
 4839 |     | //
 4840 |     | // The pointer below refers to the above integral in 'X216' representation
 4841 |     | // which takes up to 27 bytes.
 4842 |     | uint16 constant _targetToOvershoot_ = 1395;
 4843 |     | 
 4844 |     | // While searching for 'qTarget' and 'qOvershoot', we need to calculate the
 4845 |     | // following integral:
 4846 |     | //
 4847 |     | //                             - 8
 4848 |     | //    originToOvershoot      e
 4849 |     | //  '------------------- := ------- * (
 4850 |     | //        2 ** 216             2
 4851 |     | //
 4852 |     | //     getZeroForOne() ? 
 4853 |     | //
 4854 |     | //       / qOrigin
 4855 |     | //      |    + h / 2
 4856 |     | //      |  e         k(qOrigin - h) dh :
 4857 |     | //      |
 4858 |     | //     / qTarget
 4859 |     | //
 4860 |     | //       / qTarget
 4861 |     | //      |    - h / 2
 4862 |     | //      |  e         k(h - qOrigin) dh
 4863 |     | //      |
 4864 |     | //     / qOrigin
 4865 |     | //
 4866 |     | //   )'
 4867 |     | //
 4868 |     | // 'originToOvershoot' is used for the calculation of 'overshoot' as discussed
 4869 |     | // in 'Interval.sol'.
 4870 |     | //
 4871 |     | // The pointer below refers to the above integral in 'X216' representation
 4872 |     | // which takes up to 27 bytes.
 4873 |     | uint16 constant _originToOvershoot_ = 1422;
 4874 |     | 
 4875 |     | uint16 constant _endOfInterval_ = 1449;
 4876 |     | 
 4877 |     | // Accrued Parameters
 4878 |     | // ----------------------------------------------------------------------------
 4879 |     | // The spaces that are pointed to by the following memory pointers contain
 4880 |     | // information about the accrued growth portions that are owed to the protocol
 4881 |     | // and the pool. After each swap or donate, the interval liquidity grows. A
 4882 |     | // portion of this growth goes to the protocol. A portion of the remaining
 4883 |     | // growth goes to the pool owner. These values are compactly written on
 4884 |     | // protocol's storage in which they occupy exactly one slot.
 4885 |     | uint16 constant _accruedParams_ = 1449;
 4886 |     | 
 4887 |     | // This 32 bytes memory space hosts the 'X127' representation of 'accrued0'
 4888 |     | // where
 4889 |     | //
 4890 |     | //    accrued0
 4891 |     | //  '----------'
 4892 |     | //    2 ** 127
 4893 |     | //
 4894 |     | // is the total unclaimed amount in 'tag0' owed to both the protocol and the
 4895 |     | // pool owner.
 4896 |     | uint16 constant _accrued0_ = 1449;
 4897 |     | 
 4898 |     | // This 32 bytes memory space hosts the 'X127' representation of 'accrued1'
 4899 |     | // where
 4900 |     | //
 4901 |     | //    accrued1
 4902 |     | //  '----------'
 4903 |     | //    2 ** 127
 4904 |     | //
 4905 |     | // is the total unclaimed amount in 'tag1' owed to both the protocol and the
 4906 |     | // pool owner.
 4907 |     | uint16 constant _accrued1_ = 1481;
 4908 |     | 
 4909 |     | // This 3 bytes memory space hosts the 'X23' representation of 'poolRatio0'
 4910 |     | // where
 4911 |     | //
 4912 |     | //    poolRatio0     accrued0
 4913 |     | //  '------------ * ----------'
 4914 |     | //     2 ** 23       2 ** 127
 4915 |     | //
 4916 |     | // is the accrued amount in 'tag0' owed to the pool and
 4917 |     | //
 4918 |     | //    oneX23 - poolRatio0     accrued0
 4919 |     | //  '--------------------- * ----------'
 4920 |     | //          2 ** 23           2 ** 127
 4921 |     | //
 4922 |     | // is the accrued amount in 'tag0' owed to the protocol.
 4923 |     | uint16 constant _poolRatio0_ = 1513;
 4924 |     | 
 4925 |     | // This 3 bytes memory space hosts the 'X23' representation of 'poolRatio1'
 4926 |     | // where
 4927 |     | //
 4928 |     | //    poolRatio1     accrued1
 4929 |     | //  '------------ * ----------'
 4930 |     | //     2 ** 23       2 ** 127
 4931 |     | //
 4932 |     | // is the accrued amount in 'tag1' owed to the pool and
 4933 |     | //
 4934 |     | //    oneX23 - poolRatio1     accrued1
 4935 |     | //  '--------------------- * ----------'
 4936 |     | //          2 ** 23           2 ** 127
 4937 |     | //
 4938 |     | // is the accrued amount in 'tag1' owed to the protocol.
 4939 |     | uint16 constant _poolRatio1_ = 1516;
 4940 |     | 
 4941 |     | // Pointers
 4942 |     | // ----------------------------------------------------------------------------
 4943 |     | // The following memory pointers give access to data with dynamic size.
 4944 |     | uint16 constant _pointers_ = 1519;
 4945 |     | 
 4946 |     | // The content of this 32 bytes memory space points to the beginning of the
 4947 |     | // kernel.
 4948 |     | // The memory space starting from 'getKernel()' to
 4949 |     | // 'getKernel() + 64 * (getKernelLength() - 1)' hosts the kernel breakpoints
 4950 |     | // that are loaded from the bytecode of the storage smart contract (64 bytes
 4951 |     | // for each breakpoint of the kernel function except for '(b[0], c[0])' which
 4952 |     | // is omitted).
 4953 |     | uint16 constant _kernel_ = 1519;
 4954 |     | 
 4955 |     | // The content of this 32 bytes memory space points to the beginning of the
 4956 |     | // curve sequence. The memory space starting from 'getCurve()' to
 4957 |     | // 'getCurve() + 8 * getCurveLength()' hosts the curve sequence which is loaded
 4958 |     | // from the protocol's storage (8 bytes for each member of the curve sequence).
 4959 |     | uint16 constant _curve_ = 1551;
 4960 |     | 
 4961 |     | // The content of this 32 bytes memory space points to the beginning of
 4962 |     | // 'hookData'. The memory space starting from 'getHookData()' to
 4963 |     | // 'getHookData() + getHookDataByteCount()' hosts 'hookData' which is loaded
 4964 |     | // from calldata.
 4965 |     | uint16 constant _hookData_ = 1583;
 4966 |     | 
 4967 |     | // This 2 bytes memory space hosts the number of breakpoints of the kernel
 4968 |     | // function which is calculated from the size of the storage smart contract.
 4969 |     | uint16 constant _kernelLength_ = 1615;
 4970 |     | 
 4971 |     | // This 2 bytes memory space hosts the number of members of the curve sequence.
 4972 |     | uint16 constant _curveLength_ = 1617;
 4973 |     | 
 4974 |     | // This 2 bytes memory space hosts the number of bytes that 'hookData'
 4975 |     | // occupies.
 4976 |     | uint16 constant _hookDataByteCount_ = 1619;
 4977 |     | 
 4978 |     | // Dynamic Parameters
 4979 |     | // ----------------------------------------------------------------------------
 4980 |     | // The following memory pointers are dedicated to dynamic parameters of the
 4981 |     | // pool that may change with each swap. Dynamic parameters are stored in
 4982 |     | // protocol's storage and take a total of three slots. In the event that
 4983 |     | // 'staticParamsStoragePointer' overflows and
 4984 |     | // 'staticParamsStoragePointerExtension' is needed, a fourth storage slot is
 4985 |     | // populated, rendering interactions with the pool more expensive.
 4986 |     | uint16 constant _dynamicParams_ = 1621;
 4987 |     | 
 4988 |     | // The content of this 32 bytes memory space is referred to as
 4989 |     | // 'staticParamsStoragePointerExtension' which is closely related to
 4990 |     | // 'staticParamsStoragePointer'.
 4991 |     | //
 4992 |     | // If 'staticParamsStoragePointer < type(uint16).max', then
 4993 |     | // 'staticParamsStoragePointerExtension' is not written on protocol's storage
 4994 |     | // and we have:
 4995 |     | //
 4996 |     | //  'staticParamsStoragePointerExtension == staticParamsStoragePointer'
 4997 |     | //
 4998 |     | // If 'staticParamsStoragePointer == type(uint16).max', then
 4999 |     | // 'staticParamsStoragePointerExtension' populates a dedicated storage slot
 5000 |     | // whose content can be used to derive the address of the storage smart
 5001 |     | // contract that contains the static parameters and the kernel.
 5002 |     | uint16 constant _staticParamsStoragePointerExtension_ = 1621;
 5003 |     | 
 5004 |     | // The content of this 2 bytes memory space is used to retrieve the address of
 5005 |     | // the smart contract which holds the pool's static parameters and the kernel
 5006 |     | // in its bytecode. This value is incremented every time that any of the static
 5007 |     | // parameters are updated or when the kernel is modified. In the event of
 5008 |     | // overflow, this value is set to 'type(uint16).max' and the 32 bytes space
 5009 |     | // which is pointed to by '_staticParamsStoragePointerExtension_' is used to
 5010 |     | // store the value from which the address to the storage smart contract is
 5011 |     | // derived.
 5012 |     | uint16 constant _staticParamsStoragePointer_ = 1653;
 5013 |     | 
 5014 |     | // This 8 bytes memory space hosts 'logPriceCurrent' which is the offsetted
 5015 |     | // value of the current log price of the pool in 'X59' representation. More
 5016 |     | // precisely,
 5017 |     | //
 5018 |     | //  'logPriceCurrent := (2 ** 59) * (16 + qCurrent)'
 5019 |     | //
 5020 |     | // where 
 5021 |     | // 
 5022 |     | //  'qCurrent := log(pCurrent / pOffset)',
 5023 |     | //
 5024 |     | // and 'pCurrent' represents the current price of the pool.
 5025 |     | //
 5026 |     | // This value is also used to determine the end of the curve sequence while
 5027 |     | // reading the curve sequence from storage. Because the curve sequence does not
 5028 |     | // have a length slot, but its last member is equal to 'logPriceCurrent'.
 5029 |     | uint16 constant _logPriceCurrent_ = 1655;
 5030 |     | 
 5031 |     | // The total number of shares that are deposited in the current active
 5032 |     | // liquidity interval across all LPs.
 5033 |     | //
 5034 |     | // We keep track of the total share values in all of the liquidity intervals
 5035 |     | // via the mapping 'sharesDelta' within protocol's storage. Let 'qBoundary'
 5036 |     | // denote an arbitrary boundary for a liquidity interval, i.e.,
 5037 |     | //
 5038 |     | //  'qBoundary == qLower + j * qSpacing'
 5039 |     | //
 5040 |     | // for some integer 'j'. Let 'sharesTotalLeft' and 'sharesTotalRight' denote
 5041 |     | // the total number of shares within the intervals
 5042 |     | //
 5043 |     | //  '[qBoundary - qSpacing, qBoundary]' and
 5044 |     | //  '[qBoundary, qBoundary + qSpacing]',
 5045 |     | //
 5046 |     | // respectively. Define:
 5047 |     | //
 5048 |     | //  'sharesDelta[qBoundary] := sharesTotalRight - sharesTotalLeft'.
 5049 |     | //
 5050 |     | // In other words, 'sharesDelta[qBoundary]' is defined as the difference
 5051 |     | // between the total number of shares within the two liquidity intervals that
 5052 |     | // contain 'qBoundary'.
 5053 |     | uint16 constant _sharesTotal_ = 1663;
 5054 |     | 
 5055 |     | // With each visit to a liquidity interval or as a result of donations, the
 5056 |     | // amount of liquidity which is allocated to a single LP share increases. We
 5057 |     | // use the parameter 'growth' to keep track of liquidity per share for the
 5058 |     | // active interval. 'growth' is stored in 'X111' format and we always have
 5059 |     | // 'oneX111 <= growth <= maxGrowth == 1 << 127'.
 5060 |     | //
 5061 |     | // Let 'pLower' and 'pUpper', respectively, denote the minimum and maximum
 5062 |     | // price in the current active liquidity interval and define
 5063 |     | //
 5064 |     | //  'qLower := log(pLower / pOffset)',
 5065 |     | //  'qUpper := log(pUpper / pOffset)'.
 5066 |     | //
 5067 |     | // Growth values across inactive intervals are kept track of using the mapping
 5068 |     | // 'growthMultiplier' as explained below.
 5069 |     | //
 5070 |     | // For every integer 'm >= 1', let 
 5071 |     | // 
 5072 |     | //    sqrtInverseOffset     growthMultiplier[qLower + m * qSpacing]
 5073 |     | //  '------------------- * -----------------------------------------'
 5074 |     | //        2 ** 127                         2 ** 208
 5075 |     | //
 5076 |     | // represent the total amount of 'tag0' corresponding to a single liquidity
 5077 |     | // provider's share from 'qLower + m * qSpacing' to '+oo' and let
 5078 |     | //
 5079 |     | //    sqrtOffset     growthMultiplier[qUpper - m * qSpacing]
 5080 |     | //  '------------ * -----------------------------------------'
 5081 |     | //     2 ** 127                     2 ** 208
 5082 |     | //
 5083 |     | // represent the total amount of 'tag1' corresponding to a single liquidity
 5084 |     | // provider's share from '-oo' to 'qLower'.
 5085 |     | //
 5086 |     | // For every integer 'm', let 'growth(m)' denote the 'growth' value for the
 5087 |     | // interval
 5088 |     | //
 5089 |     | //  '[qLower + m * qSpacing, qUpper + m * qSpacing]'.
 5090 |     | //
 5091 |     | // Hence, 'growth(0)' corresponds to '[qLower, qUpper]' which is stored in
 5092 |     | // the following memory space.
 5093 |     | //
 5094 |     | // According to the above definitions, for every integer 'm >= 1', we have
 5095 |     | //
 5096 |     | //    growthMultiplier[qLower + m * qSpacing]
 5097 |     | //  '----------------------------------------- := 
 5098 |     | //                    2 ** 208
 5099 |     | //   ---- +oo
 5100 |     | //   \            growth(+j)      (- qLower - j * qSpacing) / 2
 5101 |     | //   /           ------------ * e                               '.
 5102 |     | //   ---- j = m    2 ** 111
 5103 |     | //
 5104 |     | // and
 5105 |     | //
 5106 |     | //    growthMultiplier[qUpper - m * qSpacing]
 5107 |     | //  '----------------------------------------- := 
 5108 |     | //                    2 ** 208
 5109 |     | //   ---- +oo
 5110 |     | //   \            growth(-j)      (+ qUpper - j * qSpacing) / 2
 5111 |     | //   /           ------------ * e                               '.
 5112 |     | //   ---- j = m    2 ** 111
 5113 |     | //
 5114 |     | // The following illustration further elaborates the notion of 'growth' and
 5115 |     | // 'growthMultiplier':
 5116 |     | //
 5117 |     | //                                         growthMultiplier[qUpper + qSpacing]
 5118 |     | //                                                                    |-->
 5119 |     | //       growthMultiplier[qLower - qSpacing]                          |
 5120 |     | //           <--|                                                     |
 5121 |     | //              |                        growthMultiplier[qUpper]     |
 5122 |     | //              |                                   |-->              |
 5123 |     | //              |      growthMultiplier[qLower]     |                 |
 5124 |     | //              |              <--|                 |                 |
 5125 |     | //              |                 |     growth      |                 |
 5126 |     | //              |                 |       ==        |                 |
 5127 |     | //              |    growth(-1)   |    growth(0)    |    growth(+1)   |
 5128 |     | //       ... <--+-----------------+-----------------+-----------------+--> ...
 5129 |     | //                                |                 |
 5130 |     | //                              qLower           qUpper
 5131 |     | //
 5132 |     | // In the above figure, 'growthMultiplier[qUpper]' and
 5133 |     | // 'growthMultiplier[qUpper + qSpacing]' point towards '+oo' as well as every
 5134 |     | // growthMultiplier[qLower + m * qSpacing] for positive integers 'm'.
 5135 |     | //
 5136 |     | // On the contrary, 'growthMultiplier[qLower]' and
 5137 |     | // 'growthMultiplier[qLower - qSpacing]' point towards '-oo' as well as every
 5138 |     | // growthMultiplier[qUpper - m * qSpacing] for positive integers 'm'.
 5139 |     | uint16 constant _growth_ = 1679;
 5140 |     | 
 5141 |     | // Let 'pCurrent' and 'pUpper' represent the current price and the maximum
 5142 |     | // price of the active liquidity interval, respectively, and define:
 5143 |     | //
 5144 |     | // 'qCurrent := log(pCurrent / pOffset)',
 5145 |     | // 'qUpper := log(pUpper / pOffset)'.
 5146 |     | //
 5147 |     | // The memory space which is pointed to by '_integral0_' hosts the following
 5148 |     | // integral in 'X216' representation which takes up to 27 bytes:
 5149 |     | //
 5150 |     | //                     - 8     / qUpper
 5151 |     | //    integral0      e        |    - h / 2
 5152 |     | //  '----------- := ------- * |  e         k(w(h)) dh'.
 5153 |     | //    2 ** 216         2      |
 5154 |     | //                           / qCurrent
 5155 |     | //
 5156 |     | // The total reserve of 'tag0' in the active liquidity interval can be derived
 5157 |     | // from the following formula:
 5158 |     | //
 5159 |     | //  'totalReserveOfTag0 == sqrtInverseOffset * sharesTotal *
 5160 |     | //
 5161 |     | //                           growth       integral0
 5162 |     | //                         ---------- * -------------
 5163 |     | //                          2 ** 111     outgoingMax
 5164 |     | //
 5165 |     | uint16 constant _integral0_ = 1695;
 5166 |     | 
 5167 |     | // Let 'pCurrent' and 'pLower' represent the current price and the minimum
 5168 |     | // price of the active liquidity interval, respectively, and define:
 5169 |     | //
 5170 |     | // 'qCurrent := log(pCurrent / pOffset)',
 5171 |     | // 'qLower := log(pLower / pOffset)'.
 5172 |     | //
 5173 |     | // The memory space which is pointed to by '_integral1_' hosts the following
 5174 |     | // integral in 'X216' representation which takes up to 27 bytes:
 5175 |     | //
 5176 |     | //                     - 8     / qCurrent
 5177 |     | //    integral1      e        |    + h / 2
 5178 |     | //  '----------- := ------- * |  e         k(w(h)) dh'.
 5179 |     | //    2 ** 216         2      |
 5180 |     | //                           / qLower
 5181 |     | //
 5182 |     | // The total reserve of 'tag1' in the active liquidity interval can be derived
 5183 |     | // from the following formula:
 5184 |     | //
 5185 |     | //  'totalReserveOfTag1 == sqrtOffset * sharesTotal *
 5186 |     | //
 5187 |     | //                           growth       integral1
 5188 |     | //                         ---------- * -------------
 5189 |     | //                          2 ** 111     outgoingMax
 5190 |     | //
 5191 |     | uint16 constant _integral1_ = 1722;
 5192 |     | 
 5193 |     | // For every pool, the static parameters and the kernel are encoded in the
 5194 |     | // source code of a storage smart contract which is deployed using a disposable
 5195 |     | // proxy contract. When deploying a new storage smart contract, its creation
 5196 |     | // code is stored in this 11 bytes memory space with static parameters and
 5197 |     | // kernel appearing immediately after. This way, a chunk of memory can be sent
 5198 |     | // to the proxy in order to deploy the storage smart contract.
 5199 |     | uint16 constant _deploymentCreationCode_ = 1749;
 5200 |     | 
 5201 |     | // Static Parameters
 5202 |     | // ----------------------------------------------------------------------------
 5203 |     | // The following memory pointers are dedicated to the static parameters of the
 5204 |     | // pool that do not change as frequently as dynamic parameters. They are stored
 5205 |     | // along with the kernel. Hence, everytime the kernel or any of the growth
 5206 |     | // portions are updated, the entire storage smart contract is redeployed.
 5207 |     | uint16 constant _staticParams_ = 1760;
 5208 |     | 
 5209 |     | // The arithmetically smaller tag to be traded by the pool. This value is
 5210 |     | // immutable. A tag may refer to native, ERC-20, ERC-6909, or ERC-1155 tokens
 5211 |     | // as described in 'Tag.sol'.
 5212 |     | uint16 constant _tag0_ = 1760;
 5213 |     | 
 5214 |     | // The arithmetically larger tag to be traded by the pool. This value is
 5215 |     | // immutable.
 5216 |     | uint16 constant _tag1_ = 1792;
 5217 |     | 
 5218 |     | // This memory space hosts the value:
 5219 |     | //
 5220 |     | // 'sqrtOffset := (2 ** 127) * sqrt(pOffset)'
 5221 |     | //
 5222 |     | // where the natural logarithm of 'pOffset' is an 'int8' which is encoded from
 5223 |     | // bit 181 to bit 188 of poolId.
 5224 |     | uint16 constant _sqrtOffset_ = 1824;
 5225 |     | 
 5226 |     | // This memory space hosts the value:
 5227 |     | //
 5228 |     | // 'sqrtInverseOffset := (2 ** 127) / sqrt(pOffset)'
 5229 |     | //
 5230 |     | // where the natural logarithm of 'pOffset' is an 'int8' which is encoded from
 5231 |     | // bit 181 to bit 188 of poolId.
 5232 |     | uint16 constant _sqrtInverseOffset_ = 1856;
 5233 |     | 
 5234 |     | // Let 'pLower' and 'pUpper' denote the minimum and maximum price in the active
 5235 |     | // liquidity interval, respectively, and define
 5236 |     | //
 5237 |     | //  'qSpacing := log(pUpper / pLower)',
 5238 |     | //
 5239 |     | // The 62 bytes memory space which is pointed to by '_spacing_' hosts the
 5240 |     | // following values:
 5241 |     | //
 5242 |     | //  '_spacing_.log() := (2 ** 59) * (16 + qSpacing)',
 5243 |     | //  '_spacing_.sqrt(false) := (2 ** 216) * exp(- qSpacing / 2)',
 5244 |     | //  '_spacing_.sqrt(true) := (2 ** 216) * exp(- 16 + qSpacing / 2)'.
 5245 |     | //
 5246 |     | // which can be accessed via 'PriceLibrary'. The logarithmic price
 5247 |     | // '_spacing_.log()' occupies 64 bits, whereas '_spacing_.sqrt(false)' and
 5248 |     | // '_spacing_.sqrt(true)' occupy 216 bits each.
 5249 |     | uint16 constant _spacing_ = 1888;
 5250 |     | 
 5251 |     | // Let 'pLower' and 'pUpper' denote the minimum and maximum price in the active
 5252 |     | // liquidity interval, respectively, and define
 5253 |     | //
 5254 |     | //  'qUpper := log(pUpper / pOffset)',
 5255 |     | //  'qLower := log(pLower / pOffset)',
 5256 |     | //  'qSpacing := log(pUpper / pLower)'.
 5257 |     | //
 5258 |     | // This 27 bytes memory space hosts 'outgoingMax' which is a kernel parameter.
 5259 |     | // The 'X216' representation of 'outgoingMax' is defined as follows:
 5260 |     | //
 5261 |     | //                       - 8     / qSpacing
 5262 |     | //    outgoingMax      e        |    - h / 2
 5263 |     | //  '------------- := ------- * |  e         k(h) dh'.
 5264 |     | //     2 ** 216          2      |
 5265 |     | //                             / 0
 5266 |     | //
 5267 |     | // 'outgoingMax' is used frequently for calculating any amount of 'tag0' and
 5268 |     | // 'tag1'. Because of this, we calculate 'outgoingMax' and its modular inverse
 5269 |     | // at the time of initialization or anytime that the kernel is modified and
 5270 |     | // then we store the resulting values among the static parameters.
 5271 |     | //
 5272 |     | // 'outgoingMax' can be calculated with the following two equivalent formulas
 5273 |     | // as well:
 5274 |     | //
 5275 |     | //                       - 8 + qLower / 2     / qUpper
 5276 |     | //    outgoingMax      e                     |    - h / 2
 5277 |     | //  '------------- := -------------------- * |  e         k(h - qLower) dh
 5278 |     | //     2 ** 216                 2            |
 5279 |     | //                                          / qLower
 5280 |     | //
 5281 |     | //                       - 8 - qUpper / 2     / qUpper
 5282 |     | //                     e                     |    + h / 2
 5283 |     | //                    -------------------- * |  e         k(qUpper - h) dh'.
 5284 |     | //                              2            |
 5285 |     | //                                          / qLower
 5286 |     | //
 5287 |     | // Notice that the above formulas are independent of the choice for 'qLower'
 5288 |     | // and 'qUpper', and they result in the same value as long as 
 5289 |     | // 'qUpper - qLower == qSpacing'.
 5290 |     | uint16 constant _outgoingMax_ = 1950;
 5291 |     | 
 5292 |     | // This 32 bytes memory space hosts 'outgoingMaxModularInverse' which is the
 5293 |     | // modular inverse of
 5294 |     | //
 5295 |     | //    outgoingMax 
 5296 |     | //  '-------------'
 5297 |     | //      2 ** n
 5298 |     | //
 5299 |     | // modulo '2 ** 256', where 'n' is the largest power of '2' that divides
 5300 |     | // 'outgoingMax'. This value is calculated at the time of initialization or
 5301 |     | // anytime that the kernel function is modified.
 5302 |     | //
 5303 |     | // Precalculation of 'outgoingMaxModularInverse' facilitates division by
 5304 |     | // 'outgoingMax' which is done frequently.
 5305 |     | uint16 constant _outgoingMaxModularInverse_ = 1977;
 5306 |     | 
 5307 |     | // Let 'pLower' and 'pUpper' denote the minimum and maximum price in the active
 5308 |     | // liquidity interval, respectively, and define
 5309 |     | //
 5310 |     | //  'qUpper := log(pUpper / pOffset)',
 5311 |     | //  'qLower := log(pLower / pOffset)',
 5312 |     | //  'qSpacing := log(pUpper / pLower)'.
 5313 |     | //
 5314 |     | // This 27 bytes memory space hosts 'outgoingMax' which is a kernel parameter.
 5315 |     | // The 'X216' representation of 'outgoingMax' is defined as follows:
 5316 |     | //
 5317 |     | //                       - 8 - qSpacing / 2     / qSpacing
 5318 |     | //    incomingMax      e                       |    + h / 2
 5319 |     | //  '------------- := ---------------------- * |  e         k(h) dh'.
 5320 |     | //     2 ** 216                 2              |
 5321 |     | //                                            / 0
 5322 |     | //
 5323 |     | // 'incomingMax' is used for calculating the incoming amount as we cross an
 5324 |     | // entire liquidity interval from 'qBack' to 'qNext'. Because of this, we
 5325 |     | // calculate 'incomingMax' at the time of initialization or anytime that the
 5326 |     | // kernel is modified and then we store the resulting value among the static
 5327 |     | // parameters.
 5328 |     | //
 5329 |     | // 'incomingMax' can be calculated with the following two equivalent formulas
 5330 |     | // as well:
 5331 |     | //
 5332 |     | //                       - 8 - qUpper / 2     / qUpper
 5333 |     | //    incomingMax      e                     |    + h / 2
 5334 |     | //  '------------- := -------------------- * |  e         k(h - qLower) dh
 5335 |     | //     2 ** 216                 2            |
 5336 |     | //                                          / qLower
 5337 |     | //
 5338 |     | //                       - 8 + qLower / 2     / qUpper
 5339 |     | //                     e                     |    - h / 2
 5340 |     | //                    -------------------- * |  e         k(qUpper - h) dh'.
 5341 |     | //                              2            |
 5342 |     | //                                          / qLower
 5343 |     | //
 5344 |     | // Notice that the above formulas are independent of the choice for 'qLower'
 5345 |     | // and 'qUpper', and they result in the same value as long as 
 5346 |     | // 'qUpper - qLower == qSpacing'.
 5347 |     | uint16 constant _incomingMax_ = 2009;
 5348 |     | 
 5349 |     | // The content of the 6 bytes memory space which is pointed to by
 5350 |     | // '_poolGrowthPortion_' dictates the portion of the growth that goes to the
 5351 |     | // pool owner followed by the protocol.
 5352 |     | //
 5353 |     | // The content of the 6 bytes memory space which is pointed to by
 5354 |     | // '_maxPoolGrowthPortion_' imposes a cap on the portion of the marginal growth
 5355 |     | // that goes to the pool owner followed by the protocol.
 5356 |     | //
 5357 |     | // The content of the 6 bytes memory space which is pointed to by
 5358 |     | // '_protocolGrowthPortion_' dictates the portion of the growth that goes to
 5359 |     | // the protocol.
 5360 |     | //
 5361 |     | // 'maxPoolGrowthPortion' and 'protocolGrowthPortion' are set by the protocol
 5362 |     | // slot or the sentinel contract. Any address can invoke a function to sync
 5363 |     | // these two values with the global portions.
 5364 |     | //
 5365 |     | // This value is set by the protocol slot or the sentinel contract.
 5366 |     | // Any address can invoke a function to sync this value with the global
 5367 |     | // portion.
 5368 |     | //
 5369 |     | // Let '[qLower, qUpper]' represent the active liquidity interval. As part of a
 5370 |     | // swap, assume that the price is moved from 'qCurrent' to 'qTarget' within
 5371 |     | // '[qLower, qUpper]'. Define:
 5372 |     | //
 5373 |     | //                                - 8     / qUpper
 5374 |     | //    integral0Incremented      e        |    - h / 2
 5375 |     | //  '---------------------- := ------- * |  e         k(w(h)) dh',
 5376 |     | //          2 ** 216              2      |
 5377 |     | //                                      / qTarget
 5378 |     | //
 5379 |     | //                                - 8     / qTarget
 5380 |     | //    integral1Incremented      e        |    + h / 2
 5381 |     | //  '---------------------- := ------- * |  e         k(w(h)) dh'.
 5382 |     | //          2 ** 216              2      |
 5383 |     | //                                      / qLower
 5384 |     | //
 5385 |     | // Now, assume that the curve sequence is updated and the function 'w' is
 5386 |     | // transformed into a new function 'wAmended' which is constructed based on the
 5387 |     | // updated curve sequence. Define:
 5388 |     | //
 5389 |     | //                            - 8     / qUpper
 5390 |     | //    integral0Amended      e        |    - h / 2
 5391 |     | //  '------------------ := ------- * |  e         k(wAmended(h)) dh',
 5392 |     | //        2 ** 216            2      |
 5393 |     | //                                  / qTarget
 5394 |     | //
 5395 |     | //                            - 8     / qTarget
 5396 |     | //    integral1Amended      e        |    + h / 2
 5397 |     | //  '------------------ := ------- * |  e         k(wAmended(h)) dh'.
 5398 |     | //        2 ** 216            2      |
 5399 |     | //                                  / qLower
 5400 |     | //
 5401 |     | // Then we have:
 5402 |     | //                              integral0Incremented
 5403 |     | //  'growthAmended := growth * ----------------------
 5404 |     | //                                integral0Amended
 5405 |     | //
 5406 |     | //                              integral1Incremented
 5407 |     | //                 == growth * ----------------------'.
 5408 |     | //                                integral1Amended
 5409 |     | //
 5410 |     | // Now, the marginal growth with respect to 'tag0' and 'tag1' can be defined
 5411 |     | // as:
 5412 |     | //
 5413 |     | //  'marginalGrowthOfTag0 := sqrtInverseOffset * sharesTotal * 
 5414 |     | //
 5415 |     | //                            growthAmended - growth     integral0Amended
 5416 |     | //                           ------------------------ * ------------------',
 5417 |     | //                                    2 ** 111             outgoingMax
 5418 |     | //
 5419 |     | //  'marginalGrowthOfTag1 := sqrtOffset * sharesTotal * 
 5420 |     | //
 5421 |     | //                            growthAmended - growth     integral1Amended
 5422 |     | //                           ------------------------ * ------------------'.
 5423 |     | //                                    2 ** 111             outgoingMax
 5424 |     | //
 5425 |     | // Hence, as a result of this swap, the amount of 'tag0' that goes to the
 5426 |     | // protocol is equal to:
 5427 |     | //
 5428 |     | //    protocolGrowthPortion
 5429 |     | //  '----------------------- * marginalGrowthOfTag0'
 5430 |     | //           2 ** 47
 5431 |     | //
 5432 |     | // and the amount of 'tag1' that goes to the protocol is equal to:
 5433 |     | //
 5434 |     | //    protocolGrowthPortion
 5435 |     | //  '----------------------- * marginalGrowthOfTag1'
 5436 |     | //           2 ** 47
 5437 |     | //
 5438 |     | // Additionally, the amount of 'tag0' that goes to the pool owner is equal to:
 5439 |     | //
 5440 |     | //    min(poolGrowthPortion, maxPoolGrowthPortion)
 5441 |     | //  '---------------------------------------------- * 
 5442 |     | //                      2 ** 47
 5443 |     | //
 5444 |     | //    oneX47 - protocolGrowthPortion
 5445 |     | //   -------------------------------- * marginalGrowthOfTag0'
 5446 |     | //               2 ** 47
 5447 |     | //
 5448 |     | // and the amount of 'tag1' that goes to the pool owner is equal to:
 5449 |     | //
 5450 |     | //    min(poolGrowthPortion, maxPoolGrowthPortion)
 5451 |     | //  '---------------------------------------------- * 
 5452 |     | //                      2 ** 47
 5453 |     | //
 5454 |     | //    oneX47 - protocolGrowthPortion
 5455 |     | //   -------------------------------- * marginalGrowthOfTag1'
 5456 |     | //               2 ** 47
 5457 |     | //
 5458 |     | uint16 constant _poolGrowthPortion_ = 2036;
 5459 |     | uint16 constant _maxPoolGrowthPortion_ = 2042;
 5460 |     | uint16 constant _protocolGrowthPortion_ = 2048;
 5461 |     | 
 5462 |     | // The number of members for the pending kernel. Once a new kernel is
 5463 |     | // introduced, it remains pending until transition to a new liquidity interval.
 5464 |     | // This value is an indicator for whether there exists a pending kernel.
 5465 |     | // This value is used to ensure that a sufficient amount of space is reserved
 5466 |     | // in memory for kernel, in case the pending kernel needs to be activated in
 5467 |     | // the middle of a swap, i.e., read from the new storage smart contract.
 5468 |     | uint16 constant _pendingKernelLength_ = 2054;
 5469 |     | 
 5470 |     | uint16 constant _endOfStaticParams_ = 2056;
 5471 |     | 
 5472 |     | // Modify Position Parameters
 5473 |     | // ----------------------------------------------------------------------------
 5474 |     | // The following memory pointers host the inputs and the resulting outputs of
 5475 |     | // the method 'modifyPosition'. An LP may choose any consecutive range of
 5476 |     | // liquidity intervals to deposit their liquidity. By doing so, the LP acquires
 5477 |     | // a number of shares in every liquidity interval that belongs to the given
 5478 |     | // range. The shares can be used later to withdraw liquidity along with any
 5479 |     | // accumulated growth which is accrued as a result of swap and donate actions.
 5480 |     | uint16 constant _modifyPositionInput_ = 248;
 5481 |     | 
 5482 |     | // Every LP position is characterized by two prices 'pMin' and 'pMax'. These
 5483 |     | // two prices, respectively, correspond to the left and the right boundaries of
 5484 |     | // the consecutive range in which the LP intends to deposit or withdraw
 5485 |     | // liquidity. The following two 8 bytes memory spaces, respectively, host:
 5486 |     | //
 5487 |     | //  '(2 ** 59) * (16 + log(pMin / pOffset))',
 5488 |     | //  '(2 ** 59) * (16 + log(pMax / pOffset))'.
 5489 |     | uint16 constant _logPriceMinOffsetted_ = 248;
 5490 |     | uint16 constant _logPriceMaxOffsetted_ = 256;
 5491 |     | 
 5492 |     | // This 32 bytes memory space hosts the number of shares to be added (positive)
 5493 |     | // or removed (negative).
 5494 |     | uint16 constant _shares_ = 264;
 5495 |     | 
 5496 |     | // The following two 32 bytes memory spaces, respectively, host:
 5497 |     | //
 5498 |     | //  'logPriceMin := (2 ** 59) * log(pMin)',
 5499 |     | //  'logPriceMax := (2 ** 59) * log(pMax)'.
 5500 |     | //
 5501 |     | // Both 'logPriceMin' and 'logPriceMax' must be equal to the active interval
 5502 |     | // boundaries modulo 'qSpacing'.
 5503 |     | uint16 constant _logPriceMin_ = 296;
 5504 |     | uint16 constant _logPriceMax_ = 328;
 5505 |     | 
 5506 |     | // The amount of 'tag0' to be added (positive) or removed (negative) in 'X127'
 5507 |     | // representation, as a result of modifyPosition.
 5508 |     | uint16 constant _positionAmount0_ = 360;
 5509 |     | // The amount of 'tag1' to be added (positive) or removed (negative) in 'X127'
 5510 |     | // representation, as a result of modifyPosition.
 5511 |     | uint16 constant _positionAmount1_ = 392;
 5512 |     | 
 5513 |     | uint16 constant _endOfModifyPosition_ = 424;
 5514 |     | 
 5515 |     | ////////////////////////////////////////////////////////////////////////////////
 5516 |     | // The remainder of this script contains automatically generated getter and
 5517 |     | // setter functions for the parameters introduced above.
 5518 |     | 
 5519 |     | function getFreeMemoryPointer() pure returns (
 5520 |     |   uint256 freeMemoryPointer
 5521 |     | ) {
 5522 | *   |   assembly {
 5523 |     |     freeMemoryPointer := mload(_freeMemoryPointer_)
 5524 |     |   }
 5525 |     | }
 5526 |     | 
 5527 | *   | function setFreeMemoryPointer(
 5528 |     |   uint256 freeMemoryPointer
 5529 |     | ) pure {
 5530 | *   |   assembly {
 5531 |     |     mstore(_freeMemoryPointer_, freeMemoryPointer)
 5532 |     |   }
 5533 |     | }
 5534 |     | 
 5535 |     | function setHookSelector(
 5536 |     |   uint32 hookSelector
 5537 |     | ) pure {
 5538 |     |   assembly {
 5539 |     |     mstore(
 5540 |     |       _hookSelector_,
 5541 |     |       or(
 5542 |     |         shl(224, hookSelector),
 5543 |     |         shr(32, mload(add(_hookSelector_, 4)))
 5544 |     |       )
 5545 |     |     )
 5546 |     |   }
 5547 |     | }
 5548 |     | 
 5549 |     | function setHookInputHeader(
 5550 |     |   uint256 hookInputHeader
 5551 |     | ) pure {
 5552 |     |   assembly {
 5553 |     |     mstore(_hookInputHeader_, hookInputHeader)
 5554 |     |   }
 5555 |     | }
 5556 |     | 
 5557 |     | function getHookInputByteCount() pure returns (
 5558 |     |   uint256 hookInputByteCount
 5559 |     | ) {
 5560 |     |   assembly {
 5561 |     |     hookInputByteCount := mload(_hookInputByteCount_)
 5562 |     |   }
 5563 |     | }
 5564 |     | 
 5565 | *   | function setHookInputByteCount(
 5566 |     |   uint256 hookInputByteCount
 5567 |     | ) pure {
 5568 | *   |   assembly {
 5569 |     |     mstore(_hookInputByteCount_, hookInputByteCount)
 5570 |     |   }
 5571 |     | }
 5572 |     | 
 5573 | *   | function setMsgSender(
 5574 |     |   address msgSender
 5575 |     | ) pure {
 5576 | *   |   assembly {
 5577 |     |     mstore(
 5578 |     |       _msgSender_,
 5579 |     |       or(
 5580 |     |         shl(96, msgSender),
 5581 |     |         shr(160, mload(add(_msgSender_, 20)))
 5582 |     |       )
 5583 |     |     )
 5584 |     |   }
 5585 |     | }
 5586 |     | 
 5587 |     | function getPoolId() pure returns (
 5588 |     |   uint256 poolId
 5589 |     | ) {
 5590 |     |   assembly {
 5591 |     |     poolId := mload(_poolId_)
 5592 |     |   }
 5593 |     | }
 5594 |     | 
 5595 | *   | function setPoolId(
 5596 |     |   uint256 poolId
 5597 |     | ) pure {
 5598 | *   |   assembly {
 5599 |     |     mstore(_poolId_, poolId)
 5600 |     |   }
 5601 |     | }
 5602 |     | 
 5603 |     | function getCrossThreshold() pure returns (
 5604 |     |   uint256 crossThreshold
 5605 |     | ) {
 5606 |     |   assembly {
 5607 |     |     crossThreshold := shr(128, mload(_crossThreshold_))
 5608 |     |   }
 5609 |     | }
 5610 |     | 
 5611 |     | function setCrossThreshold(
 5612 |     |   uint256 crossThreshold
 5613 |     | ) pure {
 5614 |     |   assembly {
 5615 |     |     mstore(
 5616 |     |       _crossThreshold_,
 5617 |     |       or(
 5618 |     |         shl(128, crossThreshold),
 5619 |     |         shr(128, mload(add(_crossThreshold_, 16)))
 5620 |     |       )
 5621 |     |     )
 5622 |     |   }
 5623 |     | }
 5624 |     | 
 5625 |     | function getAmountSpecified() pure returns (
 5626 |     |   X127 amountSpecified
 5627 |     | ) {
 5628 |     |   assembly {
 5629 |     |     amountSpecified := mload(_amountSpecified_)
 5630 |     |   }
 5631 |     | }
 5632 |     | 
 5633 |     | function setAmountSpecified(
 5634 |     |   X127 amountSpecified
 5635 |     | ) pure {
 5636 |     |   assembly {
 5637 |     |     mstore(_amountSpecified_, amountSpecified)
 5638 |     |   }
 5639 |     | }
 5640 |     | 
 5641 |     | function getLogPriceLimit() pure returns (
 5642 |     |   X59 logPriceLimit
 5643 |     | ) {
 5644 |     |   assembly {
 5645 |     |     logPriceLimit := mload(_logPriceLimit_)
 5646 |     |   }
 5647 |     | }
 5648 |     | 
 5649 | *   | function setLogPriceLimit(
 5650 |     |   X59 logPriceLimit
 5651 |     | ) pure {
 5652 | *   |   assembly {
 5653 |     |     mstore(_logPriceLimit_, logPriceLimit)
 5654 |     |   }
 5655 |     | }
 5656 |     | 
 5657 |     | function getLogPriceLimitOffsetted() pure returns (
 5658 |     |   X59 logPriceLimitOffsetted
 5659 |     | ) {
 5660 |     |   assembly {
 5661 |     |     logPriceLimitOffsetted := shr(192, mload(_logPriceLimitOffsetted_))
 5662 |     |   }
 5663 |     | }
 5664 |     | 
 5665 |     | function setLogPriceLimitOffsetted(
 5666 |     |   X59 logPriceLimitOffsetted
 5667 |     | ) pure {
 5668 |     |   assembly {
 5669 |     |     mstore(
 5670 |     |       _logPriceLimitOffsetted_,
 5671 |     |       or(
 5672 |     |         shl(192, logPriceLimitOffsetted),
 5673 |     |         shr(64, mload(add(_logPriceLimitOffsetted_, 8)))
 5674 |     |       )
 5675 |     |     )
 5676 |     |   }
 5677 |     | }
 5678 |     | 
 5679 |     | function getZeroForOne() pure returns (
 5680 |     |   bool zeroForOne
 5681 |     | ) {
 5682 |     |   assembly {
 5683 |     |     zeroForOne := shr(255, mload(_zeroForOne_))
 5684 |     |   }
 5685 |     | }
 5686 |     | 
 5687 |     | function setZeroForOne(
 5688 |     |   bool zeroForOne
 5689 |     | ) pure {
 5690 |     |   assembly {
 5691 |     |     mstore8(_zeroForOne_, mul(0xFF, zeroForOne))
 5692 |     |   }
 5693 |     | }
 5694 |     | 
 5695 |     | function getExactInput() pure returns (
 5696 |     |   bool exactInput
 5697 |     | ) {
 5698 |     |   assembly {
 5699 |     |     exactInput := shr(255, mload(_exactInput_))
 5700 |     |   }
 5701 |     | }
 5702 |     | 
 5703 |     | function setExactInput(
 5704 |     |   bool exactInput
 5705 |     | ) pure {
 5706 |     |   assembly {
 5707 |     |     mstore8(_exactInput_, mul(0xFF, exactInput))
 5708 |     |   }
 5709 |     | }
 5710 |     | 
 5711 |     | function getIntegralLimit() pure returns (
 5712 |     |   X216 integralLimit
 5713 |     | ) {
 5714 |     |   assembly {
 5715 |     |     integralLimit := shr(40, mload(_integralLimit_))
 5716 |     |   }
 5717 |     | }
 5718 |     | 
 5719 |     | function setIntegralLimit(
 5720 |     |   X216 integralLimit
 5721 |     | ) pure {
 5722 |     |   assembly {
 5723 |     |     mstore(
 5724 |     |       _integralLimit_,
 5725 |     |       or(
 5726 |     |         shl(40, integralLimit),
 5727 |     |         shr(216, mload(add(_integralLimit_, 27)))
 5728 |     |       )
 5729 |     |     )
 5730 |     |   }
 5731 |     | }
 5732 |     | 
 5733 |     | function getIntegralLimitInterval() pure returns (
 5734 |     |   X216 integralLimitInterval
 5735 |     | ) {
 5736 |     |   assembly {
 5737 |     |     integralLimitInterval := shr(40, mload(_integralLimitInterval_))
 5738 |     |   }
 5739 |     | }
 5740 |     | 
 5741 |     | function setIntegralLimitInterval(
 5742 |     |   X216 integralLimitInterval
 5743 |     | ) pure {
 5744 |     |   assembly {
 5745 |     |     mstore(
 5746 |     |       _integralLimitInterval_,
 5747 |     |       or(
 5748 |     |         shl(40, integralLimitInterval),
 5749 |     |         shr(216, mload(add(_integralLimitInterval_, 27)))
 5750 |     |       )
 5751 |     |     )
 5752 |     |   }
 5753 |     | }
 5754 |     | 
 5755 |     | function getAmount0() pure returns (
 5756 |     |   X127 amount0
 5757 |     | ) {
 5758 |     |   assembly {
 5759 |     |     amount0 := mload(_amount0_)
 5760 |     |   }
 5761 |     | }
 5762 |     | 
 5763 |     | function setAmount0(
 5764 |     |   X127 amount0
 5765 |     | ) pure {
 5766 |     |   assembly {
 5767 |     |     mstore(_amount0_, amount0)
 5768 |     |   }
 5769 |     | }
 5770 |     | 
 5771 |     | function getAmount1() pure returns (
 5772 |     |   X127 amount1
 5773 |     | ) {
 5774 |     |   assembly {
 5775 |     |     amount1 := mload(_amount1_)
 5776 |     |   }
 5777 |     | }
 5778 |     | 
 5779 |     | function setAmount1(
 5780 |     |   X127 amount1
 5781 |     | ) pure {
 5782 |     |   assembly {
 5783 |     |     mstore(_amount1_, amount1)
 5784 |     |   }
 5785 |     | }
 5786 |     | 
 5787 |     | function getBackGrowthMultiplier() pure returns (
 5788 |     |   X208 backGrowthMultiplier
 5789 |     | ) {
 5790 |     |   assembly {
 5791 |     |     backGrowthMultiplier := mload(_backGrowthMultiplier_)
 5792 |     |   }
 5793 |     | }
 5794 |     | 
 5795 |     | function setBackGrowthMultiplier(
 5796 |     |   X208 backGrowthMultiplier
 5797 |     | ) pure {
 5798 |     |   assembly {
 5799 |     |     mstore(_backGrowthMultiplier_, backGrowthMultiplier)
 5800 |     |   }
 5801 |     | }
 5802 |     | 
 5803 |     | function getNextGrowthMultiplier() pure returns (
 5804 |     |   X208 nextGrowthMultiplier
 5805 |     | ) {
 5806 |     |   assembly {
 5807 |     |     nextGrowthMultiplier := mload(_nextGrowthMultiplier_)
 5808 |     |   }
 5809 |     | }
 5810 |     | 
 5811 |     | function setNextGrowthMultiplier(
 5812 |     |   X208 nextGrowthMultiplier
 5813 |     | ) pure {
 5814 |     |   assembly {
 5815 |     |     mstore(_nextGrowthMultiplier_, nextGrowthMultiplier)
 5816 |     |   }
 5817 |     | }
 5818 |     | 
 5819 |     | function getDirection() pure returns (
 5820 |     |   bool direction
 5821 |     | ) {
 5822 |     |   assembly {
 5823 |     |     direction := shr(255, mload(_direction_))
 5824 |     |   }
 5825 |     | }
 5826 |     | 
 5827 |     | function setDirection(
 5828 |     |   bool direction
 5829 |     | ) pure {
 5830 |     |   assembly {
 5831 |     |     mstore8(_direction_, mul(0xFF, direction))
 5832 |     |   }
 5833 |     | }
 5834 |     | 
 5835 |     | function getIndexCurve() pure returns (
 5836 |     |   Index indexCurve
 5837 |     | ) {
 5838 |     |   assembly {
 5839 |     |     indexCurve := shr(240, mload(_indexCurve_))
 5840 |     |   }
 5841 |     | }
 5842 |     | 
 5843 |     | function setIndexCurve(
 5844 |     |   Index indexCurve
 5845 |     | ) pure {
 5846 |     |   assembly {
 5847 |     |     mstore(
 5848 |     |       _indexCurve_,
 5849 |     |       or(
 5850 |     |         shl(240, indexCurve),
 5851 |     |         shr(16, mload(add(_indexCurve_, 2)))
 5852 |     |       )
 5853 |     |     )
 5854 |     |   }
 5855 |     | }
 5856 |     | 
 5857 |     | function getLogPriceLimitOffsettedWithinInterval() pure returns (
 5858 |     |   X59 logPriceLimitOffsettedWithinInterval
 5859 |     | ) {
 5860 |     |   assembly {
 5861 |     |     logPriceLimitOffsettedWithinInterval := 
 5862 |     |       shr(192, mload(_logPriceLimitOffsettedWithinInterval_))
 5863 |     |   }
 5864 |     | }
 5865 |     | 
 5866 |     | function setLogPriceLimitOffsettedWithinInterval(
 5867 |     |   X59 logPriceLimitOffsettedWithinInterval
 5868 |     | ) pure {
 5869 |     |   assembly {
 5870 |     |     mstore(
 5871 |     |       _logPriceLimitOffsettedWithinInterval_,
 5872 |     |       or(
 5873 |     |         shl(192, logPriceLimitOffsettedWithinInterval),
 5874 |     |         shr(64, mload(add(_logPriceLimitOffsettedWithinInterval_, 8)))
 5875 |     |       )
 5876 |     |     )
 5877 |     |   }
 5878 |     | }
 5879 |     | 
 5880 |     | function getAccrued0() pure returns (
 5881 |     |   X127 accrued0
 5882 |     | ) {
 5883 |     |   assembly {
 5884 |     |     accrued0 := mload(_accrued0_)
 5885 |     |   }
 5886 |     | }
 5887 |     | 
 5888 |     | function setAccrued0(
 5889 |     |   X127 accrued0
 5890 |     | ) pure {
 5891 |     |   assembly {
 5892 |     |     mstore(_accrued0_, accrued0)
 5893 |     |   }
 5894 |     | }
 5895 |     | 
 5896 |     | function getAccrued1() pure returns (
 5897 |     |   X127 accrued1
 5898 |     | ) {
 5899 |     |   assembly {
 5900 |     |     accrued1 := mload(_accrued1_)
 5901 |     |   }
 5902 |     | }
 5903 |     | 
 5904 |     | function setAccrued1(
 5905 |     |   X127 accrued1
 5906 |     | ) pure {
 5907 |     |   assembly {
 5908 |     |     mstore(_accrued1_, accrued1)
 5909 |     |   }
 5910 |     | }
 5911 |     | 
 5912 |     | function getPoolRatio0() pure returns (
 5913 |     |   X23 poolRatio0
 5914 |     | ) {
 5915 |     |   assembly {
 5916 |     |     poolRatio0 := shr(232, mload(_poolRatio0_))
 5917 |     |   }
 5918 |     | }
 5919 |     | 
 5920 |     | function setPoolRatio0(
 5921 |     |   X23 poolRatio0
 5922 |     | ) pure {
 5923 |     |   assembly {
 5924 |     |     mstore(
 5925 |     |       _poolRatio0_,
 5926 |     |       or(
 5927 |     |         shl(232, poolRatio0),
 5928 |     |         shr(24, mload(add(_poolRatio0_, 3)))
 5929 |     |       )
 5930 |     |     )
 5931 |     |   }
 5932 |     | }
 5933 |     | 
 5934 |     | function getPoolRatio1() pure returns (
 5935 |     |   X23 poolRatio1
 5936 |     | ) {
 5937 |     |   assembly {
 5938 |     |     poolRatio1 := shr(232, mload(_poolRatio1_))
 5939 |     |   }
 5940 |     | }
 5941 |     | 
 5942 |     | function setPoolRatio1(
 5943 |     |   X23 poolRatio1
 5944 |     | ) pure {
 5945 |     |   assembly {
 5946 |     |     mstore(
 5947 |     |       _poolRatio1_,
 5948 |     |       or(
 5949 |     |         shl(232, poolRatio1),
 5950 |     |         shr(24, mload(add(_poolRatio1_, 3)))
 5951 |     |       )
 5952 |     |     )
 5953 |     |   }
 5954 |     | }
 5955 |     | 
 5956 |     | function getKernel() pure returns (
 5957 |     |   Kernel kernel
 5958 |     | ) {
 5959 |     |   assembly {
 5960 |     |     kernel := mload(_kernel_)
 5961 |     |   }
 5962 |     | }
 5963 |     | 
 5964 |     | function setKernel(
 5965 |     |   Kernel kernel
 5966 |     | ) pure {
 5967 |     |   assembly {
 5968 |     |     mstore(_kernel_, kernel)
 5969 |     |   }
 5970 |     | }
 5971 |     | 
 5972 |     | function getCurve() pure returns (
 5973 |     |   Curve curve
 5974 |     | ) {
 5975 |     |   assembly {
 5976 |     |     curve := mload(_curve_)
 5977 |     |   }
 5978 |     | }
 5979 |     | 
 5980 | *   | function setCurve(
 5981 |     |   Curve curve
 5982 |     | ) pure {
 5983 | *   |   assembly {
 5984 |     |     mstore(_curve_, curve)
 5985 |     |   }
 5986 |     | }
 5987 |     | 
 5988 |     | function getHookData() pure returns (
 5989 |     |   uint256 hookData
 5990 |     | ) {
 5991 |     |   assembly {
 5992 |     |     hookData := mload(_hookData_)
 5993 |     |   }
 5994 |     | }
 5995 |     | 
 5996 | *   | function setHookData(
 5997 |     |   uint256 hookData
 5998 |     | ) pure {
 5999 | *   |   assembly {
 6000 |     |     mstore(_hookData_, hookData)
 6001 |     |   }
 6002 |     | }
 6003 |     | 
 6004 |     | function getKernelLength() pure returns (
 6005 |     |   Index kernelLength
 6006 |     | ) {
 6007 |     |   assembly {
 6008 |     |     kernelLength := shr(240, mload(_kernelLength_))
 6009 |     |   }
 6010 |     | }
 6011 |     | 
 6012 |     | function setKernelLength(
 6013 |     |   Index kernelLength
 6014 |     | ) pure {
 6015 |     |   assembly {
 6016 |     |     mstore(
 6017 |     |       _kernelLength_,
 6018 |     |       or(
 6019 |     |         shl(240, kernelLength),
 6020 |     |         shr(16, mload(add(_kernelLength_, 2)))
 6021 |     |       )
 6022 |     |     )
 6023 |     |   }
 6024 |     | }
 6025 |     | 
 6026 |     | function getCurveLength() pure returns (
 6027 |     |   Index curveLength
 6028 |     | ) {
 6029 |     |   assembly {
 6030 |     |     curveLength := shr(240, mload(_curveLength_))
 6031 |     |   }
 6032 |     | }
 6033 |     | 
 6034 |     | function setCurveLength(
 6035 |     |   Index curveLength
 6036 |     | ) pure {
 6037 |     |   assembly {
 6038 |     |     mstore(
 6039 |     |       _curveLength_,
 6040 |     |       or(
 6041 |     |         shl(240, curveLength),
 6042 |     |         shr(16, mload(add(_curveLength_, 2)))
 6043 |     |       )
 6044 |     |     )
 6045 |     |   }
 6046 |     | }
 6047 |     | 
 6048 |     | function getHookDataByteCount() pure returns (
 6049 |     |   uint16 hookDataByteCount
 6050 |     | ) {
 6051 |     |   assembly {
 6052 |     |     hookDataByteCount := shr(240, mload(_hookDataByteCount_))
 6053 |     |   }
 6054 |     | }
 6055 |     | 
 6056 | *   | function setHookDataByteCount(
 6057 |     |   uint16 hookDataByteCount
 6058 |     | ) pure {
 6059 | *   |   assembly {
 6060 |     |     mstore(
 6061 |     |       _hookDataByteCount_,
 6062 |     |       or(
 6063 |     |         shl(240, hookDataByteCount),
 6064 |     |         shr(16, mload(add(_hookDataByteCount_, 2)))
 6065 |     |       )
 6066 |     |     )
 6067 |     |   }
 6068 |     | }
 6069 |     | 
 6070 |     | function getStaticParamsStoragePointerExtension() pure returns (
 6071 |     |   uint256 staticParamsStoragePointerExtension
 6072 |     | ) {
 6073 |     |   assembly {
 6074 |     |     staticParamsStoragePointerExtension := 
 6075 |     |       mload(_staticParamsStoragePointerExtension_)
 6076 |     |   }
 6077 |     | }
 6078 |     | 
 6079 |     | function setStaticParamsStoragePointerExtension(
 6080 |     |   uint256 staticParamsStoragePointerExtension
 6081 |     | ) pure {
 6082 |     |   assembly {
 6083 |     |     mstore(
 6084 |     |       _staticParamsStoragePointerExtension_,
 6085 |     |       staticParamsStoragePointerExtension
 6086 |     |     )
 6087 |     |   }
 6088 |     | }
 6089 |     | 
 6090 |     | function getGrowth() pure returns (
 6091 |     |   X111 growth
 6092 |     | ) {
 6093 |     |   assembly {
 6094 |     |     growth := shr(128, mload(_growth_))
 6095 |     |   }
 6096 |     | }
 6097 |     | 
 6098 |     | function setGrowth(
 6099 |     |   X111 growth
 6100 |     | ) pure {
 6101 |     |   assembly {
 6102 |     |     mstore(
 6103 |     |       _growth_,
 6104 |     |       or(
 6105 |     |         shl(128, growth),
 6106 |     |         shr(128, mload(add(_growth_, 16)))
 6107 |     |       )
 6108 |     |     )
 6109 |     |   }
 6110 |     | }
 6111 |     | 
 6112 |     | function getIntegral0() pure returns (
 6113 |     |   X216 integral0
 6114 |     | ) {
 6115 |     |   assembly {
 6116 |     |     integral0 := shr(40, mload(_integral0_))
 6117 |     |   }
 6118 |     | }
 6119 |     | 
 6120 |     | function setIntegral0(
 6121 |     |   X216 integral0
 6122 |     | ) pure {
 6123 |     |   assembly {
 6124 |     |     mstore(
 6125 |     |       _integral0_,
 6126 |     |       or(
 6127 |     |         shl(40, integral0),
 6128 |     |         shr(216, mload(add(_integral0_, 27)))
 6129 |     |       )
 6130 |     |     )
 6131 |     |   }
 6132 |     | }
 6133 |     | 
 6134 |     | function getIntegral1() pure returns (
 6135 |     |   X216 integral1
 6136 |     | ) {
 6137 |     |   assembly {
 6138 |     |     integral1 := shr(40, mload(_integral1_))
 6139 |     |   }
 6140 |     | }
 6141 |     | 
 6142 |     | function setIntegral1(
 6143 |     |   X216 integral1
 6144 |     | ) pure {
 6145 |     |   assembly {
 6146 |     |     mstore(
 6147 |     |       _integral1_,
 6148 |     |       or(
 6149 |     |         shl(40, integral1),
 6150 |     |         shr(216, mload(add(_integral1_, 27)))
 6151 |     |       )
 6152 |     |     )
 6153 |     |   }
 6154 |     | }
 6155 |     | 
 6156 |     | function getSharesTotal() pure returns (
 6157 |     |   uint256 sharesTotal
 6158 |     | ) {
 6159 |     |   assembly {
 6160 |     |     sharesTotal := shr(128, mload(_sharesTotal_))
 6161 |     |   }
 6162 |     | }
 6163 |     | 
 6164 |     | function setSharesTotal(
 6165 |     |   uint256 sharesTotal
 6166 |     | ) pure {
 6167 |     |   assembly {
 6168 |     |     mstore(
 6169 |     |       _sharesTotal_,
 6170 |     |       or(
 6171 |     |         shl(128, sharesTotal),
 6172 |     |         shr(128, mload(add(_sharesTotal_, 16)))
 6173 |     |       )
 6174 |     |     )
 6175 |     |   }
 6176 |     | }
 6177 |     | 
 6178 |     | function getStaticParamsStoragePointer() pure returns (
 6179 |     |   uint16 staticParamsStoragePointer
 6180 |     | ) {
 6181 |     |   assembly {
 6182 |     |     staticParamsStoragePointer := shr(240, mload(_staticParamsStoragePointer_))
 6183 |     |   }
 6184 |     | }
 6185 |     | 
 6186 |     | function setStaticParamsStoragePointer(
 6187 |     |   uint16 staticParamsStoragePointer
 6188 |     | ) pure {
 6189 |     |   assembly {
 6190 |     |     mstore(
 6191 |     |       _staticParamsStoragePointer_,
 6192 |     |       or(
 6193 |     |         shl(240, staticParamsStoragePointer),
 6194 |     |         shr(16, mload(add(_staticParamsStoragePointer_, 2)))
 6195 |     |       )
 6196 |     |     )
 6197 |     |   }
 6198 |     | }
 6199 |     | 
 6200 |     | function getLogPriceCurrent() pure returns (
 6201 |     |   X59 logPriceCurrent
 6202 |     | ) {
 6203 |     |   assembly {
 6204 |     |     logPriceCurrent := shr(192, mload(_logPriceCurrent_))
 6205 |     |   }
 6206 |     | }
 6207 |     | 
 6208 |     | function setLogPriceCurrent(
 6209 |     |   X59 logPriceCurrent
 6210 |     | ) pure {
 6211 |     |   assembly {
 6212 |     |     mstore(
 6213 |     |       _logPriceCurrent_,
 6214 |     |       or(
 6215 |     |         shl(192, logPriceCurrent),
 6216 |     |         shr(64, mload(add(_logPriceCurrent_, 8)))
 6217 |     |       )
 6218 |     |     )
 6219 |     |   }
 6220 |     | }
 6221 |     | 
 6222 |     | function setDeploymentCreationCode(
 6223 |     |   uint256 deploymentCreationCode
 6224 |     | ) pure {
 6225 |     |   assembly {
 6226 |     |     mstore(
 6227 |     |       _deploymentCreationCode_,
 6228 |     |       or(
 6229 |     |         shl(168, deploymentCreationCode),
 6230 |     |         shr(88, mload(add(_deploymentCreationCode_, 11)))
 6231 |     |       )
 6232 |     |     )
 6233 |     |   }
 6234 |     | }
 6235 |     | 
 6236 |     | function getTag0() pure returns (
 6237 |     |   Tag tag0
 6238 |     | ) {
 6239 |     |   assembly {
 6240 |     |     tag0 := mload(_tag0_)
 6241 |     |   }
 6242 |     | }
 6243 |     | 
 6244 |     | function setTag0(
 6245 |     |   Tag tag0
 6246 |     | ) pure {
 6247 |     |   assembly {
 6248 |     |     mstore(_tag0_, tag0)
 6249 |     |   }
 6250 |     | }
 6251 |     | 
 6252 |     | function getTag1() pure returns (
 6253 |     |   Tag tag1
 6254 |     | ) {
 6255 |     |   assembly {
 6256 |     |     tag1 := mload(_tag1_)
 6257 |     |   }
 6258 |     | }
 6259 |     | 
 6260 |     | function setTag1(
 6261 |     |   Tag tag1
 6262 |     | ) pure {
 6263 |     |   assembly {
 6264 |     |     mstore(_tag1_, tag1)
 6265 |     |   }
 6266 |     | }
 6267 |     | 
 6268 |     | function getSqrtOffset() pure returns (
 6269 |     |   X127 sqrtOffset
 6270 |     | ) {
 6271 |     |   assembly {
 6272 |     |     sqrtOffset := mload(_sqrtOffset_)
 6273 |     |   }
 6274 |     | }
 6275 |     | 
 6276 |     | function setSqrtOffset(
 6277 |     |   X127 sqrtOffset
 6278 |     | ) pure {
 6279 |     |   assembly {
 6280 |     |     mstore(_sqrtOffset_, sqrtOffset)
 6281 |     |   }
 6282 |     | }
 6283 |     | 
 6284 |     | function getSqrtInverseOffset() pure returns (
 6285 |     |   X127 sqrtInverseOffset
 6286 |     | ) {
 6287 |     |   assembly {
 6288 |     |     sqrtInverseOffset := mload(_sqrtInverseOffset_)
 6289 |     |   }
 6290 |     | }
 6291 |     | 
 6292 |     | function setSqrtInverseOffset(
 6293 |     |   X127 sqrtInverseOffset
 6294 |     | ) pure {
 6295 |     |   assembly {
 6296 |     |     mstore(_sqrtInverseOffset_, sqrtInverseOffset)
 6297 |     |   }
 6298 |     | }
 6299 |     | 
 6300 |     | function getOutgoingMax() pure returns (
 6301 |     |   X216 outgoingMax
 6302 |     | ) {
 6303 |     |   assembly {
 6304 |     |     outgoingMax := shr(40, mload(_outgoingMax_))
 6305 |     |   }
 6306 |     | }
 6307 |     | 
 6308 |     | function setOutgoingMax(
 6309 |     |   X216 outgoingMax
 6310 |     | ) pure {
 6311 |     |   assembly {
 6312 |     |     mstore(
 6313 |     |       _outgoingMax_,
 6314 |     |       or(
 6315 |     |         shl(40, outgoingMax),
 6316 |     |         shr(216, mload(add(_outgoingMax_, 27)))
 6317 |     |       )
 6318 |     |     )
 6319 |     |   }
 6320 |     | }
 6321 |     | 
 6322 |     | function getOutgoingMaxModularInverse() pure returns (
 6323 |     |   uint256 outgoingMaxModularInverse
 6324 |     | ) {
 6325 |     |   assembly {
 6326 |     |     outgoingMaxModularInverse := mload(_outgoingMaxModularInverse_)
 6327 |     |   }
 6328 |     | }
 6329 |     | 
 6330 |     | function setOutgoingMaxModularInverse(
 6331 |     |   uint256 outgoingMaxModularInverse
 6332 |     | ) pure {
 6333 |     |   assembly {
 6334 |     |     mstore(_outgoingMaxModularInverse_, outgoingMaxModularInverse)
 6335 |     |   }
 6336 |     | }
 6337 |     | 
 6338 |     | function getIncomingMax() pure returns (
 6339 |     |   X216 incomingMax
 6340 |     | ) {
 6341 |     |   assembly {
 6342 |     |     incomingMax := shr(40, mload(_incomingMax_))
 6343 |     |   }
 6344 |     | }
 6345 |     | 
 6346 |     | function setIncomingMax(
 6347 |     |   X216 incomingMax
 6348 |     | ) pure {
 6349 |     |   assembly {
 6350 |     |     mstore(
 6351 |     |       _incomingMax_,
 6352 |     |       or(
 6353 |     |         shl(40, incomingMax),
 6354 |     |         shr(216, mload(add(_incomingMax_, 27)))
 6355 |     |       )
 6356 |     |     )
 6357 |     |   }
 6358 |     | }
 6359 |     | 
 6360 |     | function getPoolGrowthPortion() pure returns (
 6361 |     |   X47 poolGrowthPortion
 6362 |     | ) {
 6363 |     |   assembly {
 6364 |     |     poolGrowthPortion := shr(208, mload(_poolGrowthPortion_))
 6365 |     |   }
 6366 |     | }
 6367 |     | 
 6368 |     | function setPoolGrowthPortion(
 6369 |     |   X47 poolGrowthPortion
 6370 |     | ) pure {
 6371 |     |   assembly {
 6372 |     |     mstore(
 6373 |     |       _poolGrowthPortion_,
 6374 |     |       or(
 6375 |     |         shl(208, poolGrowthPortion),
 6376 |     |         shr(48, mload(add(_poolGrowthPortion_, 6)))
 6377 |     |       )
 6378 |     |     )
 6379 |     |   }
 6380 |     | }
 6381 |     | 
 6382 |     | function getMaxPoolGrowthPortion() pure returns (
 6383 |     |   X47 maxPoolGrowthPortion
 6384 |     | ) {
 6385 |     |   assembly {
 6386 |     |     maxPoolGrowthPortion := shr(208, mload(_maxPoolGrowthPortion_))
 6387 |     |   }
 6388 |     | }
 6389 |     | 
 6390 |     | function setMaxPoolGrowthPortion(
 6391 |     |   X47 maxPoolGrowthPortion
 6392 |     | ) pure {
 6393 |     |   assembly {
 6394 |     |     mstore(
 6395 |     |       _maxPoolGrowthPortion_,
 6396 |     |       or(
 6397 |     |         shl(208, maxPoolGrowthPortion),
 6398 |     |         shr(48, mload(add(_maxPoolGrowthPortion_, 6)))
 6399 |     |       )
 6400 |     |     )
 6401 |     |   }
 6402 |     | }
 6403 |     | 
 6404 |     | function getProtocolGrowthPortion() pure returns (
 6405 |     |   X47 protocolGrowthPortion
 6406 |     | ) {
 6407 |     |   assembly {
 6408 |     |     protocolGrowthPortion := shr(208, mload(_protocolGrowthPortion_))
 6409 |     |   }
 6410 |     | }
 6411 |     | 
 6412 |     | function setProtocolGrowthPortion(
 6413 |     |   X47 protocolGrowthPortion
 6414 |     | ) pure {
 6415 |     |   assembly {
 6416 |     |     mstore(
 6417 |     |       _protocolGrowthPortion_,
 6418 |     |       or(
 6419 |     |         shl(208, protocolGrowthPortion),
 6420 |     |         shr(48, mload(add(_protocolGrowthPortion_, 6)))
 6421 |     |       )
 6422 |     |     )
 6423 |     |   }
 6424 |     | }
 6425 |     | 
 6426 |     | function getPendingKernelLength() pure returns (
 6427 |     |   Index pendingKernelLength
 6428 |     | ) {
 6429 |     |   assembly {
 6430 |     |     pendingKernelLength := shr(240, mload(_pendingKernelLength_))
 6431 |     |   }
 6432 |     | }
 6433 |     | 
 6434 |     | function setPendingKernelLength(
 6435 |     |   Index pendingKernelLength
 6436 |     | ) pure {
 6437 |     |   assembly {
 6438 |     |     mstore(
 6439 |     |       _pendingKernelLength_,
 6440 |     |       or(
 6441 |     |         shl(240, pendingKernelLength),
 6442 |     |         shr(16, mload(add(_pendingKernelLength_, 2)))
 6443 |     |       )
 6444 |     |     )
 6445 |     |   }
 6446 |     | }
 6447 |     | 
 6448 |     | function getLogPriceMinOffsetted() pure returns (
 6449 |     |   X59 logPriceMinOffsetted
 6450 |     | ) {
 6451 |     |   assembly {
 6452 |     |     logPriceMinOffsetted := shr(192, mload(_logPriceMinOffsetted_))
 6453 |     |   }
 6454 |     | }
 6455 |     | 
 6456 | *   | function setLogPriceMinOffsetted(
 6457 |     |   X59 logPriceMinOffsetted
 6458 |     | ) pure {
 6459 | *   |   assembly {
 6460 |     |     mstore(
 6461 |     |       _logPriceMinOffsetted_,
 6462 |     |       or(
 6463 |     |         shl(192, logPriceMinOffsetted),
 6464 |     |         shr(64, mload(add(_logPriceMinOffsetted_, 8)))
 6465 |     |       )
 6466 |     |     )
 6467 |     |   }
 6468 |     | }
 6469 |     | 
 6470 |     | function getLogPriceMaxOffsetted() pure returns (
 6471 |     |   X59 logPriceMaxOffsetted
 6472 |     | ) {
 6473 |     |   assembly {
 6474 |     |     logPriceMaxOffsetted := shr(192, mload(_logPriceMaxOffsetted_))
 6475 |     |   }
 6476 |     | }
 6477 |     | 
 6478 | *   | function setLogPriceMaxOffsetted(
 6479 |     |   X59 logPriceMaxOffsetted
 6480 |     | ) pure {
 6481 | *   |   assembly {
 6482 |     |     mstore(
 6483 |     |       _logPriceMaxOffsetted_,
 6484 |     |       or(
 6485 |     |         shl(192, logPriceMaxOffsetted),
 6486 |     |         shr(64, mload(add(_logPriceMaxOffsetted_, 8)))
 6487 |     |       )
 6488 |     |     )
 6489 |     |   }
 6490 |     | }
 6491 |     | 
 6492 |     | function getShares() pure returns (
 6493 |     |   int256 shares
 6494 |     | ) {
 6495 |     |   assembly {
 6496 |     |     shares := mload(_shares_)
 6497 |     |   }
 6498 |     | }
 6499 |     | 
 6500 | *   | function setShares(
 6501 |     |   int256 shares
 6502 |     | ) pure {
 6503 | *   |   assembly {
 6504 |     |     mstore(_shares_, shares)
 6505 |     |   }
 6506 |     | }
 6507 |     | 
 6508 |     | function getLogPriceMin() pure returns (
 6509 |     |   X59 logPriceMin
 6510 |     | ) {
 6511 |     |   assembly {
 6512 |     |     logPriceMin := mload(_logPriceMin_)
 6513 |     |   }
 6514 |     | }
 6515 |     | 
 6516 |     | function setLogPriceMin(
 6517 |     |   X59 logPriceMin
 6518 |     | ) pure {
 6519 |     |   assembly {
 6520 |     |     mstore(_logPriceMin_, logPriceMin)
 6521 |     |   }
 6522 |     | }
 6523 |     | 
 6524 |     | function getLogPriceMax() pure returns (
 6525 |     |   X59 logPriceMax
 6526 |     | ) {
 6527 |     |   assembly {
 6528 |     |     logPriceMax := mload(_logPriceMax_)
 6529 |     |   }
 6530 |     | }
 6531 |     | 
 6532 | *   | function setLogPriceMax(
 6533 |     |   X59 logPriceMax
 6534 |     | ) pure {
 6535 | *   |   assembly {
 6536 |     |     mstore(_logPriceMax_, logPriceMax)
 6537 |     |   }
 6538 |     | }
 6539 |     | 
 6540 |     | function getPositionAmount0() pure returns (
 6541 |     |   int256 positionAmount0
 6542 |     | ) {
 6543 |     |   assembly {
 6544 |     |     positionAmount0 := mload(_positionAmount0_)
 6545 |     |   }
 6546 |     | }
 6547 |     | 
 6548 |     | function setPositionAmount0(
 6549 |     |   int256 positionAmount0
 6550 |     | ) pure {
 6551 |     |   assembly {
 6552 |     |     mstore(_positionAmount0_, positionAmount0)
 6553 |     |   }
 6554 |     | }
 6555 |     | 
 6556 |     | function getPositionAmount1() pure returns (
 6557 |     |   int256 positionAmount1
 6558 |     | ) {
 6559 |     |   assembly {
 6560 |     |     positionAmount1 := mload(_positionAmount1_)
 6561 |     |   }
 6562 |     | }
 6563 |     | 
 6564 |     | function setPositionAmount1(
 6565 |     |   int256 positionAmount1
 6566 |     | ) pure {
 6567 |     |   assembly {
 6568 |     |     mstore(_positionAmount1_, positionAmount1)
 6569 |     |   }
 6570 |     | }

R:/LIAT.AI/question2-calldata/contracts/utilities/PoolId.sol
  1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
  2 |     | pragma solidity ^0.8.28;
  3 |     | 
  4 |     | import {X59} from "./X59.sol";
  5 |     | 
  6 |     | /// @notice Extracts '(2 ** 59) * log(pOffset)' from poolId.
  7 |     | function getLogOffsetFromPoolId(
  8 |     |   uint256 poolId
  9 |     | ) pure returns (
 10 |     |   X59 logOffset
 11 |     | ) {
 12 | *   |   assembly {
 13 |     |     // Bits 181 to 188 of poolId represent an 8-bit integer in two's
 14 |     |     // complement which is equal to the natural logarithm of 'pOffset'. We
 15 |     |     // extract this value and convert it to an 'int256' by extending its sign
 16 |     |     // bit. Next, we multiply it by '2 ** 59' to obtain 'log(pOffset)' in 'X59'
 17 |     |     // representation.
 18 |     |     logOffset := mul(shl(59, 1), signextend(0, shr(180, poolId)))
 19 |     |   }
 20 |     | }
 21 |     | 
 22 |     | /// @notice Derives 'poolId' based on the following rule:
 23 |     | ///
 24 |     | /// 'poolId = unsaltedPoolId + (
 25 |     | ///     keccak256(abi.encodePacked(msg.sender, unsaltedPoolId)) << 188
 26 |     | ///  )'
 27 |     | ///
 28 |     | function derivePoolId(
 29 |     |   uint256 unsaltedPoolId
 30 |     | ) view returns (
 31 |     |   uint256 poolId
 32 |     | ) {
 33 |     |   assembly {
 34 |     |     mstore(0, shl(96, caller()))
 35 |     |     mstore(20, unsaltedPoolId)
 36 |     |     poolId := add(unsaltedPoolId, shl(188, keccak256(0, 52)))
 37 |     |   }
 38 |     | }

R:/LIAT.AI/question2-calldata/contracts/utilities/Price.sol
   1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
   2 |     | pragma solidity ^0.8.28;
   3 |     | 
   4 |     | import {X15} from "./X15.sol";
   5 |     | import {X59} from "./X59.sol";
   6 |     | import {X216} from "./X216.sol";
   7 |     | 
   8 |     | library PriceLibrary {
   9 |     |   using PriceLibrary for uint256;
  10 |     | 
  11 |     |   /// @notice Stores a given price in a given memory location with the 
  12 |     |   /// following layout:
  13 |     |   ///
  14 |     |   ///  pointer
  15 |     |   ///     |
  16 |     |   ///     +--------+---------------------------+---------------------------+
  17 |     |   ///     | 8 byte |          27 byte          |          27 byte          |
  18 |     |   ///     +--------+---------------------------+---------------------------+
  19 |     |   ///     |        |                           |
  20 |     |   ///     |        |                            \
  21 |     |   ///     |        |                             sqrtInversePrice
  22 |     |   ///     |         \
  23 |     |   ///     |          sqrtPrice
  24 |     |   ///      \
  25 |     |   ///       logPrice
  26 |     |   ///
  27 |     |   /// 'pointer' should not be less than '32'.
  28 |     |   /// 'logPrice' should be non-negative and less than '2 ** 64'.
  29 |     |   /// 'sqrtPrice' should be non-negative and less than 'oneX216'.
  30 |     |   /// 'sqrtInversePrice' should be non-negative and less than 'oneX216'.
  31 |     |   function storePrice(
  32 |     |     uint256 pointer,
  33 |     |     X59 logPrice,
  34 |     |     X216 sqrtPrice,
  35 |     |     X216 sqrtInversePrice
  36 |     |   ) internal pure {
  37 |     |     assembly {
  38 |     |       // The preceding slot is cached so that it can be restored after we place
  39 |     |       // all values in their appropriate memory locations.
  40 |     |       // The subtraction is safe because of the input requirement on 'pointer'.
  41 |     |       let precedingPointer := sub(pointer, 32)
  42 |     |       let precedingSlot := mload(precedingPointer)
  43 |     | 
  44 |     |       // We move '64 + 216 + 216' bits forward to reach the following location:
  45 |     |       //
  46 |     |       //                                                          pointer + 62
  47 |     |       //                                                                  \
  48 |     |       //                                                                   |
  49 |     |       //  +--------+---------------------------+---------------------------+
  50 |     |       //  | 8 byte |          27 byte          |          27 byte          |
  51 |     |       //  +--------+---------------------------+---------------------------+
  52 |     |       //  |        |                           |
  53 |     |       //  |        |                            \
  54 |     |       //  |        |                             sqrtInversePrice
  55 |     |       //  |         \
  56 |     |       //  |          sqrtPrice
  57 |     |       //   \
  58 |     |       //    logPrice
  59 |     |       //
  60 |     |       // Then we move '256' bits backward to point to the beginning of the slot
  61 |     |       // whose least significant '216' bits are supposed to host
  62 |     |       // 'sqrtInversePrice'.
  63 |     |       //
  64 |     |       // '64 + 216 + 216 - 256' bits == '30' bytes.
  65 |     |       mstore(add(pointer, 30), sqrtInversePrice)
  66 |     | 
  67 |     |       // We move '64 + 216' bits forward to reach the following location:
  68 |     |       //
  69 |     |       //                                  pointer + 35
  70 |     |       //                                       |
  71 |     |       //  +--------+---------------------------+---------------------------+
  72 |     |       //  | 8 byte |          27 byte          |          27 byte          |
  73 |     |       //  +--------+---------------------------+---------------------------+
  74 |     |       //  |        |                           |
  75 |     |       //  |        |                            \
  76 |     |       //  |        |                             sqrtInversePrice
  77 |     |       //  |         \
  78 |     |       //  |          sqrtPrice
  79 |     |       //   \
  80 |     |       //    logPrice
  81 |     |       //
  82 |     |       // Then we move '256' bits backward to point to the beginning of the slot
  83 |     |       // whose least significant '216' bits are supposed to host 'sqrtPrice'.
  84 |     |       //
  85 |     |       // '64 + 216 - 256' bits == '3' bytes.
  86 |     |       mstore(add(pointer, 3), sqrtPrice)
  87 |     | 
  88 |     |       // We move '64' bits forward to reach the following location:
  89 |     |       //
  90 |     |       //      pointer + 8
  91 |     |       //           |
  92 |     |       //  +--------+---------------------------+---------------------------+
  93 |     |       //  | 8 byte |          27 byte          |          27 byte          |
  94 |     |       //  +--------+---------------------------+---------------------------+
  95 |     |       //  |        |                           |
  96 |     |       //  |        |                            \
  97 |     |       //  |        |                             sqrtInversePrice
  98 |     |       //  |         \
  99 |     |       //  |          sqrtPrice
 100 |     |       //   \
 101 |     |       //    logPrice
 102 |     |       //
 103 |     |       // Then we move '256' bits backward to point to the beginning of the slot
 104 |     |       // whose least significant '64' bits are supposed to host 'logPrice'.
 105 |     |       //
 106 |     |       // '64 - 256' bits == '-24' bytes.
 107 |     |       //
 108 |     |       // The subtraction is safe because of the input requirement on 'pointer'.
 109 |     |       mstore(sub(pointer, 24), logPrice)
 110 |     | 
 111 |     |       // The preceding slot is restored.
 112 |     |       mstore(precedingPointer, precedingSlot)
 113 |     |     }
 114 |     |   }
 115 |     | 
 116 |     |   /// @notice Calculates the sqrt and sqrtInverse of a given logPrice and
 117 |     |   /// stores everything in the given memory location with the following
 118 |     |   /// layout:
 119 |     |   ///
 120 |     |   ///  pointer
 121 |     |   ///     |
 122 |     |   ///     +--------+---------------------------+---------------------------+
 123 |     |   ///     | 8 byte |          27 byte          |          27 byte          |
 124 |     |   ///     +--------+---------------------------+---------------------------+
 125 |     |   ///     |        |                           |
 126 |     |   ///     |        |                            \
 127 |     |   ///     |        |                             sqrtInversePrice
 128 |     |   ///     |         \
 129 |     |   ///     |          sqrtPrice
 130 |     |   ///      \
 131 |     |   ///       logPrice
 132 |     |   ///
 133 |     |   /// 'pointer' should not be less than '32' and 'pointer + 30' should not
 134 |     |   /// overflow.
 135 |     |   ///
 136 |     |   /// 'logPrice' should be greater than 0 and less than (2 ** 64).
 137 |     |   function storePrice(
 138 |     |     uint256 pointer,
 139 |     |     X59 logPrice
 140 |     |   ) internal pure {
 141 |     |     // The requirements of 'exp' are satisfied here because 
 142 |     |     // '0 < logPrice < 2 ** 64'.
 143 |     |     (X216 sqrtPrice, X216 sqrtInversePrice) = logPrice.exp();
 144 |     | 
 145 |     |     // The requirements of 'storePrice' are satisfied here, because of the
 146 |     |     // input requirement on 'pointer' and because both outputs of 'exp' are
 147 |     |     // less than 'oneX216':
 148 |     |     //
 149 |     |     // '0 < logPrice' -> '(2 ** 216) * exp(- logPrice / (2 ** 60)) < 2 ** 216'
 150 |     |     //
 151 |     |     // 'logPrice < 2 ** 64' -> 
 152 |     |     // '(2 ** 216) * exp(- 16 + logPrice / (2 ** 60)) < 2 ** 216'
 153 |     |     //
 154 |     |     pointer.storePrice(logPrice, sqrtPrice, sqrtInversePrice);
 155 |     |   }
 156 |     | 
 157 |     |   /// @notice Stores a given price in a given memory location with the
 158 |     |   /// following layout:
 159 |     |   ///
 160 |     |   ///   pointer
 161 |     |   ///      |
 162 |     |   ///   +--+--------+---------------------------+---------------------------+
 163 |     |   ///   |  | 8 byte |          27 byte          |          27 byte          |
 164 |     |   ///   +--+--------+---------------------------+---------------------------+
 165 |     |   ///   |  |        |                           |
 166 |     |   ///   |  |        |                            \
 167 |     |   ///   |  |        |                             sqrtInversePrice
 168 |     |   ///   |  |         \
 169 |     |   ///   |  |          sqrtPrice
 170 |     |   ///   |   \
 171 |     |   ///   |    logPrice
 172 |     |   ///    \
 173 |     |   ///     heightPrice
 174 |     |   ///
 175 |     |   /// 'pointer' should not be less than '34'.
 176 |     |   /// 'heightPrice' should be less than or equal to 'oneX15'.
 177 |     |   /// 'logPrice' should be non-negative and less than (2 ** 64).
 178 |     |   /// 'sqrtPrice' should be non-negative and less than 'oneX216'.
 179 |     |   /// 'sqrtInversePrice' should be non-negative and less than 'oneX216'.
 180 |     |   function storePrice(
 181 |     |     uint256 pointer,
 182 |     |     X15 heightPrice,
 183 |     |     X59 logPrice,
 184 |     |     X216 sqrtPrice,
 185 |     |     X216 sqrtInversePrice
 186 |     |   ) internal pure {
 187 |     |     assembly {
 188 |     |       // The preceding slot is cached so that it can be restored after we place
 189 |     |       // all values in their appropriate memory location.
 190 |     |       // The subtraction is safe because of the input requirement on 'pointer'.
 191 |     |       let precedingPointer := sub(pointer, 34)
 192 |     |       let precedingSlot := mload(precedingPointer)
 193 |     | 
 194 |     |       // We move '64 + 216 + 216' bits forward to reach the following location:
 195 |     |       //
 196 |     |       //                                                          pointer + 62
 197 |     |       //                                                                     \
 198 |     |       //                                                                      |
 199 |     |       //  +--+--------+---------------------------+---------------------------+
 200 |     |       //  |  | 8 byte |          27 byte          |          27 byte          |
 201 |     |       //  +--+--------+---------------------------+---------------------------+
 202 |     |       //  |  |        |                           |
 203 |     |       //  |  |        |                            \
 204 |     |       //  |  |        |                             sqrtInversePrice
 205 |     |       //  |  |         \
 206 |     |       //  |  |          sqrtPrice
 207 |     |       //  |   \
 208 |     |       //  |    logPrice
 209 |     |       //   \
 210 |     |       //    heightPrice
 211 |     |       //
 212 |     |       // Then we move '256' bits backward to point to the beginning of the slot
 213 |     |       // whose least significant '216' bits are supposed to host
 214 |     |       // 'sqrtInversePrice'.
 215 |     |       //
 216 |     |       // '64 + 216 + 216 - 256' bits == '30' bytes.
 217 |     |       mstore(add(pointer, 30), sqrtInversePrice)
 218 |     | 
 219 |     |       // We move '64 + 216' bits forward to reach the following location:
 220 |     |       //
 221 |     |       //                                  pointer + 35
 222 |     |       //                                         \
 223 |     |       //                                          |
 224 |     |       //  +--+--------+---------------------------+---------------------------+
 225 |     |       //  |  | 8 byte |          27 byte          |          27 byte          |
 226 |     |       //  +--+--------+---------------------------+---------------------------+
 227 |     |       //  |  |        |                           |
 228 |     |       //  |  |        |                            \
 229 |     |       //  |  |        |                             sqrtInversePrice
 230 |     |       //  |  |         \
 231 |     |       //  |  |          sqrtPrice
 232 |     |       //  |   \
 233 |     |       //  |    logPrice
 234 |     |       //   \
 235 |     |       //    heightPrice
 236 |     |       //
 237 |     |       // Then we move '256' bits backward to point to the beginning of the slot
 238 |     |       // whose least significant '216' bits are supposed to host 'sqrtPrice'.
 239 |     |       //
 240 |     |       // '64 + 216 - 256' bits == '3' bytes.
 241 |     |       mstore(add(pointer, 3), sqrtPrice)
 242 |     | 
 243 |     |       // We move '64' bits forward to reach the following location:
 244 |     |       //
 245 |     |       //      pointer + 8
 246 |     |       //             \
 247 |     |       //              |
 248 |     |       //  +--+--------+---------------------------+---------------------------+
 249 |     |       //  |  | 8 byte |          27 byte          |          27 byte          |
 250 |     |       //  +--+--------+---------------------------+---------------------------+
 251 |     |       //  |  |        |                           |
 252 |     |       //  |  |        |                            \
 253 |     |       //  |  |        |                             sqrtInversePrice
 254 |     |       //  |  |         \
 255 |     |       //  |  |          sqrtPrice
 256 |     |       //  |   \
 257 |     |       //  |    logPrice
 258 |     |       //   \
 259 |     |       //    heightPrice
 260 |     |       //
 261 |     |       // Then we move '256' bits backward to point to the beginning of the slot
 262 |     |       // whose least significant '64' bits are supposed to host 'logPrice'.
 263 |     |       //
 264 |     |       // '64 - 256' bits == '-24' bytes.
 265 |     |       // The subtraction is safe because of the input requirement on 'pointer'.
 266 |     |       mstore(sub(pointer, 24), logPrice)
 267 |     | 
 268 |     |       // We move '256' bits backward to point to the beginning of the slot
 269 |     |       // whose least significant '16' bits are supposed to host 'heightPrice'.
 270 |     |       //
 271 |     |       // '0 - 256' bits == '-32' bytes.
 272 |     |       // The subtraction is safe because of the input requirement on 'pointer'.
 273 |     |       mstore(sub(pointer, 32), heightPrice)
 274 |     | 
 275 |     |       // The preceding slot is restored.
 276 |     |       mstore(precedingPointer, precedingSlot)
 277 |     |     }
 278 |     |   }
 279 |     | 
 280 |     |   /// @notice Returns the height of a price given its memory pointer with the 
 281 |     |   /// following layout:
 282 |     |   ///
 283 |     |   ///       pointer
 284 |     |   ///      /
 285 |     |   ///     |
 286 |     |   ///  +--+--------+---------------------------+---------------------------+
 287 |     |   ///  |  | 8 byte |          27 byte          |          27 byte          |
 288 |     |   ///  +--+--------+---------------------------+---------------------------+
 289 |     |   ///  |  |        |                           |
 290 |     |   ///  |  |        |                            \
 291 |     |   ///  |  |        |                             sqrtInversePrice
 292 |     |   ///  |  |         \
 293 |     |   ///  |  |          sqrtPrice
 294 |     |   ///  |   \
 295 |     |   ///  |    logPrice
 296 |     |   ///   \
 297 |     |   ///    heightPrice
 298 |     |   ///
 299 |     |   function height(
 300 |     |     uint256 pointer
 301 |     |   ) internal pure returns (
 302 |     |     X15 value
 303 |     |   ) {
 304 |     |     assembly {
 305 |     |       // We move '2' bytes backward to read the slot whose most significant
 306 |     |       // '16' bits host 'height'.
 307 |     |       //
 308 |     |       //    pointer - 2
 309 |     |       //   /
 310 |     |       //  |
 311 |     |       //  +--+--------+---------------------------+---------------------------+
 312 |     |       //  |  | 8 byte |          27 byte          |          27 byte          |
 313 |     |       //  +--+--------+---------------------------+---------------------------+
 314 |     |       //  |  |        |                           |
 315 |     |       //  |  |        |                            \
 316 |     |       //  |  |        |                             sqrtInversePrice
 317 |     |       //  |  |         \
 318 |     |       //  |  |          sqrtPrice
 319 |     |       //  |   \
 320 |     |       //  |    logPrice
 321 |     |       //   \
 322 |     |       //    heightPrice
 323 |     |       //
 324 |     |       // Then we shift the content by '240' bits to the right in order to get
 325 |     |       // 'height'.
 326 |     |       //
 327 |     |       // The subtraction is safe, because the pointer refer to a price with
 328 |     |       // height and therefore its value is not less than '2'.
 329 |     |       value := shr(240, mload(sub(pointer, 2)))
 330 |     |     }
 331 |     |   }
 332 |     | 
 333 |     |   /// @notice Returns the logarithm of a price given its memory pointer with
 334 |     |   /// the following layout:
 335 |     |   ///
 336 |     |   ///       pointer
 337 |     |   ///      /
 338 |     |   ///     |
 339 |     |   ///  +--+--------+---------------------------+---------------------------+
 340 |     |   ///  |  | 8 byte |          27 byte          |          27 byte          |
 341 |     |   ///  +--+--------+---------------------------+---------------------------+
 342 |     |   ///  |  |        |                           |
 343 |     |   ///  |  |        |                            \
 344 |     |   ///  |  |        |                             sqrtInversePrice
 345 |     |   ///  |  |         \
 346 |     |   ///  |  |          sqrtPrice
 347 |     |   ///  |   \
 348 |     |   ///  |    logPrice
 349 |     |   ///   \
 350 |     |   ///    heightPrice
 351 |     |   ///
 352 |     |   function log(
 353 |     |     uint256 pointer
 354 |     |   ) internal pure returns (
 355 |     |     X59 logPrice
 356 |     |   ) {
 357 |     |     assembly {
 358 |     |       // The given pointer refers to the slot whose most significant '64' bits
 359 |     |       // host 'logPrice'. We read this slot and then we shift the content by
 360 |     |       // '192' bits to the right in order to get 'logPrice'.
 361 |     |       logPrice := shr(192, mload(pointer))
 362 |     |     }
 363 |     |   }
 364 |     | 
 365 |     |   /// @notice Returns the 'sqrtPrice' or 'sqrtInversePrice' given a memory 
 366 |     |   /// pointer with the following layout:
 367 |     |   ///
 368 |     |   ///       pointer
 369 |     |   ///      /
 370 |     |   ///     |
 371 |     |   ///  +--+--------+---------------------------+---------------------------+
 372 |     |   ///  |  | 8 byte |          27 byte          |          27 byte          |
 373 |     |   ///  +--+--------+---------------------------+---------------------------+
 374 |     |   ///  |  |        |                           |
 375 |     |   ///  |  |        |                            \
 376 |     |   ///  |  |        |                             sqrtInversePrice
 377 |     |   ///  |  |         \
 378 |     |   ///  |  |          sqrtPrice
 379 |     |   ///  |   \
 380 |     |   ///  |    logPrice
 381 |     |   ///   \
 382 |     |   ///    heightPrice
 383 |     |   ///
 384 |     |   function sqrt(
 385 |     |     uint256 pointer,
 386 |     |     bool inverse
 387 |     |   ) internal pure returns (
 388 |     |     X216 value
 389 |     |   ) {
 390 |     |     assembly {
 391 |     |       // If 'inverse == true' then we move '35' bytes forward to read the slot
 392 |     |       // whose most significant '216' bits host 'sqrtPriceInverse'.
 393 |     |       //
 394 |     |       //                                  pointer + 35
 395 |     |       //                                         \
 396 |     |       //                                          |
 397 |     |       //  +--+--------+---------------------------+---------------------------+
 398 |     |       //  |  | 8 byte |          27 byte          |          27 byte          |
 399 |     |       //  +--+--------+---------------------------+---------------------------+
 400 |     |       //  |  |        |                           |
 401 |     |       //  |  |        |                            \
 402 |     |       //  |  |        |                             sqrtInversePrice
 403 |     |       //  |  |         \
 404 |     |       //  |  |          sqrtPrice
 405 |     |       //  |   \
 406 |     |       //  |    logPrice
 407 |     |       //   \
 408 |     |       //    heightPrice
 409 |     |       //
 410 |     |       // Then we shift the content by '40' bits to the right in order to get
 411 |     |       // 'sqrtPriceInverse'.
 412 |     |       //
 413 |     |       // If 'inverse == false' then we move '8' bytes forward to read the slot
 414 |     |       // whose most significant '216' bits host 'sqrtPrice'.
 415 |     |       //
 416 |     |       //      pointer + 8
 417 |     |       //             \
 418 |     |       //              |
 419 |     |       //  +--+--------+---------------------------+---------------------------+
 420 |     |       //  |  | 8 byte |          27 byte          |          27 byte          |
 421 |     |       //  +--+--------+---------------------------+---------------------------+
 422 |     |       //  |  |        |                           |
 423 |     |       //  |  |        |                            \
 424 |     |       //  |  |        |                             sqrtInversePrice
 425 |     |       //  |  |         \
 426 |     |       //  |  |          sqrtPrice
 427 |     |       //  |   \
 428 |     |       //  |    logPrice
 429 |     |       //   \
 430 |     |       //    heightPrice
 431 |     |       //
 432 |     |       // Then we shift the content by '40' bits to the right in order to get
 433 |     |       // 'sqrtPrice'.
 434 |     |       //
 435 |     |       // The additions and the multiplication are safe because 
 436 |     |       // 'iszero(inverse)' is a boolean.
 437 |     |       value := shr(
 438 |     |         40,
 439 |     |         mload(
 440 |     |           add(
 441 |     |             sub(35, mul(27, iszero(inverse))), // inverse ? 35 : 8
 442 |     |             pointer
 443 |     |           )
 444 |     |         )
 445 |     |       )
 446 |     |     }
 447 |     |   }
 448 |     | 
 449 |     |   /// @notice Copies a price from one memory pointer to another each with the 
 450 |     |   /// following layout:
 451 |     |   ///
 452 |     |   ///  pointer
 453 |     |   ///     |
 454 |     |   ///     +--------+---------------------------+---------------------------+
 455 |     |   ///     | 8 byte |          27 byte          |          27 byte          |
 456 |     |   ///     +--------+---------------------------+---------------------------+
 457 |     |   ///     |        |                           |
 458 |     |   ///     |        |                            \
 459 |     |   ///     |        |                             sqrtInversePrice
 460 |     |   ///     |         \
 461 |     |   ///     |          sqrtPrice
 462 |     |   ///      \
 463 |     |   ///       logPrice
 464 |     |   ///
 465 |     |   function copyPrice(
 466 |     |     uint256 pointer0,
 467 |     |     uint256 pointer1
 468 |     |   ) internal pure {
 469 |     |     assembly {
 470 |     |       // Each price contains '62' bytes which is copied from one place to the
 471 |     |       // next.
 472 |     |       mcopy(pointer0, pointer1, 62)
 473 |     |     }
 474 |     |   }
 475 |     | 
 476 |     |   /// @notice Copies a price with height from one memory pointer to another
 477 |     |   /// each with the following layout:
 478 |     |   ///
 479 |     |   ///       pointer
 480 |     |   ///      /
 481 |     |   ///     |
 482 |     |   ///  +--+--------+---------------------------+---------------------------+
 483 |     |   ///  |  | 8 byte |          27 byte          |          27 byte          |
 484 |     |   ///  +--+--------+---------------------------+---------------------------+
 485 |     |   ///  |  |        |                           |
 486 |     |   ///  |  |        |                            \
 487 |     |   ///  |  |        |                             sqrtInversePrice
 488 |     |   ///  |  |         \
 489 |     |   ///  |  |          sqrtPrice
 490 |     |   ///  |   \
 491 |     |   ///  |    logPrice
 492 |     |   ///   \
 493 |     |   ///    heightPrice
 494 |     |   ///
 495 |     |   function copyPriceWithHeight(
 496 |     |     uint256 pointer0,
 497 |     |     uint256 pointer1
 498 |     |   ) internal pure {
 499 |     |     assembly {
 500 |     |       // Each price contains '64' bytes which is copied from one place to the
 501 |     |       // next. We move two bytes backward to point to the beginning of 'height'
 502 |     |       // as opposed to the end of 'height':
 503 |     |       //
 504 |     |       //    pointer
 505 |     |       //   /
 506 |     |       //  |
 507 |     |       //  +--+--------+---------------------------+---------------------------+
 508 |     |       //  |  | 8 byte |          27 byte          |          27 byte          |
 509 |     |       //  +--+--------+---------------------------+---------------------------+
 510 |     |       //  |  |        |                           |
 511 |     |       //  |  |        |                            \
 512 |     |       //  |  |        |                             sqrtInversePrice
 513 |     |       //  |  |         \
 514 |     |       //  |  |          sqrtPrice
 515 |     |       //  |   \
 516 |     |       //  |    logPrice
 517 |     |       //   \
 518 |     |       //    heightPrice
 519 |     |       //
 520 |     |       // The subtractions are safe, because both pointers refer to prices with
 521 |     |       // height and therefore their values are not less than '2'.
 522 |     |       mcopy(sub(pointer0, 2), sub(pointer1, 2), 64)
 523 |     |     }
 524 |     |   }
 525 |     | 
 526 |     |   /// @notice Given the memory pointer for a pair of prices with height, this
 527 |     |   /// function reads the corresponding horizontal and vertical coordinates.
 528 |     |   /// 'pointer' refers to the first price and 'pointer + 64' refers to the
 529 |     |   /// second one.
 530 |     |   function segment(
 531 |     |     uint256 pointer
 532 |     |   ) internal pure returns (
 533 |     |     X59 b0,
 534 |     |     X59 b1,
 535 |     |     X15 c0,
 536 |     |     X15 c1
 537 |     |   ) {
 538 |     |     c0 = pointer.height();
 539 |     |     b0 = pointer.log();
 540 |     | 
 541 |     |     // We move '64' bytes forward to point to the second price.
 542 |     |     unchecked {
 543 |     |       pointer += 64;
 544 |     |     }
 545 |     | 
 546 |     |     c1 = pointer.height();
 547 |     |     b1 = pointer.log();
 548 |     |   }
 549 |     | }

R:/LIAT.AI/question2-calldata/contracts/utilities/SentinelCalls.sol
   1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
   2 |     | pragma solidity ^0.8.28;
   3 |     | 
   4 |     | import {ISentinel} from "../interfaces/ISentinel.sol";
   5 |     | import {
   6 |     |   _hookSelector_,
   7 |     |   getHookInputByteCount,
   8 |     |   setHookInputHeader,
   9 |     |   setHookSelector
  10 |     | } from "./Memory.sol";
  11 |     | import {InvalidSentinelResponse} from "./Errors.sol";
  12 |     | import {readSentinel} from "./Storage.sol";
  13 |     | import {X47, maxX47} from "./X47.sol";
  14 |     | 
  15 |     | ISentinel constant nullSentinel = ISentinel(address(0));
  16 |     | 
  17 |     | /// @notice Calls protocol's Sentinel to get 'maxPoolGrowthPortion' and 
  18 |     | /// 'protocolGrowthPortion'.
  19 |     | function invokeSentinelGetGrowthPortions() returns (
  20 |     |   X47 maxPoolGrowthPortion,
  21 |     |   X47 protocolGrowthPortion
  22 |     | ) {
  23 |     |   // The outputs 'maxPoolGrowthPortion' and 'protocolGrowthPortion' are
  24 |     |   // initially set to the invalid value 'maxX47'. If the Sentinel contract
  25 |     |   // exists, these two values will be overwritten.
  26 |     |   maxPoolGrowthPortion = maxX47;
  27 |     |   protocolGrowthPortion = maxX47;
  28 |     | 
  29 |     |   // The Sentinel contract is read from the protocol's storage.
  30 |     |   ISentinel sentinel = readSentinel();
  31 |     | 
  32 |     |   // If the Sentinel contract exists, then 'ISentinel.getGrowthPortions' is
  33 |     |   // invoked and 'maxPoolGrowthPortion' and 'protocolGrowthPortion' are
  34 |     |   // overwritten.
  35 |     |   if (sentinel != nullSentinel) {
  36 |     |     // The appropriate selector corresponding to the method to be invoked is
  37 |     |     // placed in memory. 'selector' is cast as a 'uint32' because the setter
  38 |     |     // function 'setHookSelector' uses the least significant 32 bits as opposed
  39 |     |     // the most significant '32' bits.
  40 |     |     setHookSelector(uint32(ISentinel.getGrowthPortions.selector));
  41 |     | 
  42 |     |     // An abi offset of '0x20' is placed in memory in order to encode the
  43 |     |     // memory snapshot to be sent to the hook as type 'bytes'.
  44 |     |     setHookInputHeader(0x20);
  45 |     | 
  46 |     |     // The byte count of the memory snapshot to be sent to the Sentinel
  47 |     |     // contract is loaded from the memory.
  48 |     |     uint256 hookInputByteCount = getHookInputByteCount();
  49 |     | 
  50 |     |     assembly {
  51 |     |       // Invokes the 'ISentinel.getGrowthPortions' and relays the reason if
  52 |     |       // reverted.
  53 |     |       if iszero(
  54 |     |         // '_hookSelector_' points to the beginning of the calldata to be sent
  55 |     |         // to the Sentinel contract. The total calldata byte count is
  56 |     |         // 'hookInputByteCount + 4 + 32 + 32' where '4' accounts for the
  57 |     |         // selector, the first '32' accounts for the abi offset slot which is
  58 |     |         // populated with '0x20', and the second '32' accounts for the length
  59 |     |         // slot which is populated with 'hookInputByteCount'.
  60 |     |         call(
  61 |     |           gas(),
  62 |     |           sentinel,
  63 |     |           0,
  64 |     |           _hookSelector_,
  65 |     |           add(hookInputByteCount, 68),
  66 |     |           0,
  67 |     |           64
  68 |     |         )
  69 |     |       ) {
  70 |     |         // Return data is copied to memory and relayed as a revert message.
  71 |     |         returndatacopy(0, 0, returndatasize())
  72 |     |         revert(0, returndatasize())
  73 |     |       }
  74 |     | 
  75 |     |       // The output of 'ISentinel.getGrowthPortions' overwrites 
  76 |     |       // 'maxPoolGrowthPortion' and 'protocolGrowthPortion'.
  77 |     |       maxPoolGrowthPortion := mload(0)
  78 |     |       protocolGrowthPortion := mload(32)
  79 |     |     }
  80 |     |   }
  81 |     | }
  82 |     | 
  83 |     | /// @notice Calls protocol's Sentinel to authorize initialization.
  84 |     | function invokeAuthorizeInitialization() {
  85 |     |   // The Sentinel contract is read from the protocol's storage.
  86 |     |   ISentinel sentinel = readSentinel();
  87 |     | 
  88 |     |   // If the Sentinel contract exists, then 'ISentinel.authorizeInitialization'
  89 |     |   // is invoked to authorize initialization.
  90 |     |   if (sentinel != nullSentinel) {
  91 |     |     // The appropriate selector corresponding to the method to be invoked is
  92 |     |     // placed in memory. 'selector' is cast as a 'uint32' because the setter
  93 |     |     // function 'setHookSelector' uses the least significant 32 bits as opposed
  94 |     |     // the most significant '32' bits.
  95 |     |     setHookSelector(uint32(ISentinel.authorizeInitialization.selector));
  96 |     | 
  97 |     |     // An abi offset of '0x20' is placed in memory in order to encode the
  98 |     |     // memory snapshot to be sent to the hook as type 'bytes'.
  99 |     |     setHookInputHeader(0x20);
 100 |     | 
 101 |     |     // The byte count of the memory snapshot to be sent to the Sentinel
 102 |     |     // contract is loaded from the memory.
 103 |     |     uint256 hookInputByteCount = getHookInputByteCount();
 104 |     | 
 105 |     |     bytes4 response;
 106 |     |     assembly {
 107 |     |       // Invokes the method 'ISentinel.authorizeInitialization' and relays the
 108 |     |       // reason if reverted.
 109 |     |       if iszero(
 110 |     |         // '_hookSelector_' points to the beginning of the calldata to be sent
 111 |     |         // to the Sentinel contract. The total calldata byte count is
 112 |     |         // 'hookInputByteCount + 4 + 32 + 32' where '4' accounts for the
 113 |     |         // selector, the first '32' accounts for the abi offset slot which is
 114 |     |         // populated with '0x20', and the second '32' accounts for length slot
 115 |     |         // which is populated with 'hookInputByteCount'.
 116 |     |         call(
 117 |     |           gas(),
 118 |     |           sentinel,
 119 |     |           0,
 120 |     |           _hookSelector_,
 121 |     |           add(hookInputByteCount, 68),
 122 |     |           0,
 123 |     |           32
 124 |     |         )
 125 |     |       ) {
 126 |     |         // Return data is copied to memory and relayed as a revert message.
 127 |     |         returndatacopy(0, 0, returndatasize())
 128 |     |         revert(0, returndatasize())
 129 |     |       }
 130 |     | 
 131 |     |       response := mload(0)
 132 |     |     }
 133 |     | 
 134 |     |     // The output of 'ISentinel.authorizeInitialization' is examined.
 135 |     |     require(
 136 |     |       response == ISentinel.authorizeInitialization.selector,
 137 |     |       InvalidSentinelResponse(response)
 138 |     |     );
 139 |     |   }
 140 |     | }
 141 |     | 
 142 |     | /// @notice Calls protocol's Sentinel to authorize modification of pool growth
 143 |     | /// portion.
 144 |     | function invokeAuthorizeModificationOfPoolGrowthPortion() {
 145 |     |   // The Sentinel contract is read from the protocol's storage.
 146 |     |   ISentinel sentinel = readSentinel();
 147 |     | 
 148 |     |   // If the Sentinel contract exists, then 
 149 |     |   // 'ISentinel.authorizeModificationOfPoolGrowthPortion'
 150 |     |   // is invoked to authorize initialization.
 151 |     |   if (sentinel != nullSentinel) {
 152 |     |     // The appropriate selector corresponding to the method to be invoked is
 153 |     |     // placed in memory. 'selector' is cast as a 'uint32' because the setter
 154 |     |     // function 'setHookSelector' uses the least significant 32 bits as opposed
 155 |     |     // the most significant '32' bits.
 156 |     |     setHookSelector(
 157 |     |       uint32(ISentinel.authorizeModificationOfPoolGrowthPortion.selector)
 158 |     |     );
 159 |     | 
 160 |     |     // An abi offset of '0x20' is placed in memory in order to encode the
 161 |     |     // memory snapshot to be sent to the hook as type 'bytes'.
 162 |     |     setHookInputHeader(0x20);
 163 |     | 
 164 |     |     // The byte count of the memory snapshot to be sent to the Sentinel
 165 |     |     // contract is loaded from the memory.
 166 |     |     uint256 hookInputByteCount = getHookInputByteCount();
 167 |     | 
 168 |     |     bytes4 response;
 169 |     |     assembly {
 170 |     |       // Invokes the method 
 171 |     |       // 'ISentinel.authorizeModificationOfPoolGrowthPortion' and relays the
 172 |     |       // reason if reverted.
 173 |     |       if iszero(
 174 |     |         // '_hookSelector_' points to the beginning of the calldata to be sent
 175 |     |         // to the Sentinel contract. The total calldata byte count is
 176 |     |         // 'hookInputByteCount + 4 + 32 + 32' where '4' accounts for the
 177 |     |         // selector, the first '32' accounts for the abi offset slot which is
 178 |     |         // populated with '0x20', and the second '32' accounts for length slot
 179 |     |         // which is populated with 'hookInputByteCount'.
 180 |     |         call(
 181 |     |           gas(),
 182 |     |           sentinel,
 183 |     |           0,
 184 |     |           _hookSelector_,
 185 |     |           add(hookInputByteCount, 68),
 186 |     |           0,
 187 |     |           32
 188 |     |         )
 189 |     |       ) {
 190 |     |         // Return data is copied to memory and relayed as a revert message.
 191 |     |         returndatacopy(0, 0, returndatasize())
 192 |     |         revert(0, returndatasize())
 193 |     |       }
 194 |     | 
 195 |     |       response := mload(0)
 196 |     |     }
 197 |     | 
 198 |     |     // The output of 'ISentinel.authorizeModificationOfPoolGrowthPortion' is
 199 |     |     // examined.
 200 |     |     require(
 201 |     |       response == ISentinel.authorizeModificationOfPoolGrowthPortion.selector,
 202 |     |       InvalidSentinelResponse(response)
 203 |     |     );
 204 |     |   }
 205 |     | }

R:/LIAT.AI/question2-calldata/contracts/utilities/Storage.sol
    1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
    2 |     | pragma solidity ^0.8.28;
    3 |     | 
    4 |     | /// @dev Nofeeswap's storage layout.
    5 |     | 
    6 |     | import {
    7 |     |   _hookInputByteCount_,
    8 |     |   _dynamicParams_,
    9 |     |   _staticParams_,
   10 |     |   _endOfStaticParams_,
   11 |     |   _deploymentCreationCode_,
   12 |     |   _spacing_,
   13 |     |   getPoolId,
   14 |     |   getPoolRatio0,
   15 |     |   getPoolRatio1,
   16 |     |   getAccrued0,
   17 |     |   getAccrued1,
   18 |     |   getShares,
   19 |     |   getLogPriceMinOffsetted,
   20 |     |   getLogPriceMaxOffsetted,
   21 |     |   getGrowth,
   22 |     |   getStaticParamsStoragePointer,
   23 |     |   getStaticParamsStoragePointerExtension,
   24 |     |   getCurve,
   25 |     |   getCurveLength,
   26 |     |   getLogPriceCurrent,
   27 |     |   getKernelLength,
   28 |     |   getKernel,
   29 |     |   getPoolGrowthPortion,
   30 |     |   getMaxPoolGrowthPortion,
   31 |     |   getPendingKernelLength,
   32 |     |   setMaxPoolGrowthPortion,
   33 |     |   setProtocolGrowthPortion,
   34 |     |   setPoolRatio0,
   35 |     |   setPoolRatio1,
   36 |     |   setAccrued0,
   37 |     |   setAccrued1,
   38 |     |   setStaticParamsStoragePointer,
   39 |     |   setStaticParamsStoragePointerExtension,
   40 |     |   setCurveLength,
   41 |     |   setDeploymentCreationCode,
   42 |     |   setKernelLength,
   43 |     |   setPoolGrowthPortion,
   44 |     |   setCurve,
   45 |     |   setFreeMemoryPointer,
   46 |     |   setHookInputByteCount
   47 |     | } from "./Memory.sol";
   48 |     | import {ISentinel} from "../interfaces/ISentinel.sol";
   49 |     | import {invokeSentinelGetGrowthPortions} from "./SentinelCalls.sol";
   50 |     | import {PriceLibrary} from "./Price.sol";
   51 |     | import {Curve} from "./Curve.sol";
   52 |     | import {Kernel} from "./Kernel.sol";
   53 |     | import {Index, zeroIndex, oneIndex, twoIndex, max} from "./Index.sol";
   54 |     | import {Tag} from "./Tag.sol";
   55 |     | import {X23} from "./X23.sol";
   56 |     | import {X47, oneX47, min} from "./X47.sol";
   57 |     | import {X59} from "./X59.sol";
   58 |     | import {zeroX111} from "./X111.sol";
   59 |     | import {X127, zeroX127, accruedMax} from "./X127.sol";
   60 |     | import {X208, zeroX208, exp8X208} from "./X208.sol";
   61 |     | import {X216, oneX216} from "./X216.sol";
   62 |     | import {emitTransferEvent} from "./Events.sol";
   63 |     | import {
   64 |     |   InsufficientPermission,
   65 |     |   AccruedGrowthPortionOverflow,
   66 |     |   SharesGrossOverflow,
   67 |     |   PoolDoesNotExist,
   68 |     |   DeploymentFailed,
   69 |     |   BalanceOverflow,
   70 |     |   InsufficientBalance
   71 |     | } from "./Errors.sol";
   72 |     | 
   73 |     | using PriceLibrary for uint16;
   74 |     | 
   75 |     | /// @notice Writes a single slot on storage.
   76 |     | /// @param storageSlot the slot to be populated.
   77 |     | /// @param value the content.
   78 |     | function writeStorage(uint256 storageSlot, uint256 value) {
   79 |     |   assembly {
   80 |     |     sstore(storageSlot, value)
   81 |     |   }
   82 |     | }
   83 |     | 
   84 |     | /// @notice Reads a single slot from storage.
   85 |     | /// @param storageSlot the slot to be read.
   86 |     | /// @return value the content.
   87 |     | function readStorage(uint256 storageSlot) view returns (uint256 value) {
   88 |     |   assembly {
   89 |     |     value := sload(storageSlot)
   90 |     |   }
   91 |     | }
   92 |     | 
   93 |     | /////////////////////////////////////////////////// Protocol and Sentinel slots
   94 |     | 
   95 |     | // uint256(keccak256("protocol")) - 1
   96 |     | uint256 constant protocolSlot = 
   97 |     |   0xFB342FA999FEA16067B1F01BAF96673F31A25F2B1443E6754D93FC40B57E8DF1;
   98 |     | 
   99 |     | // uint256(keccak256("sentinel")) - 1
  100 |     | uint256 constant sentinelSlot = 
  101 |     |   0xD0716769B9821201D69D150FACFD6F46F5FD95AC252F6ECCB21B7560A01E078B;
  102 |     | 
  103 |     | /// @notice Writes 'maxPoolGrowthPortion', 'protocolGrowthPortion', and 
  104 |     | /// protocol's owner in one storage slot.
  105 |     | /// @param protocol the content to be written on 'protocolSlot', i.e.,
  106 |     | ///
  107 |     | ///   'protocol == (
  108 |     | ///      (X47.unwrap(maxPoolGrowthPortion) << 208) | 
  109 |     | ///      (X47.unwrap(protocolGrowthPortion) << 160) | 
  110 |     | ///      uint256(uint160(owner))
  111 |     | ///    )'.
  112 |     | ///
  113 |     | function writeProtocol(uint256 protocol) {
  114 |     |   writeStorage(protocolSlot, protocol);
  115 |     | }
  116 |     | 
  117 |     | /// @notice Reads the content of protocol's slot.
  118 |     | /// @return protocol The content of protocol's slot.
  119 |     | function readProtocol() view returns (
  120 |     |   uint256 protocol
  121 |     | ) {
  122 |     |   return readStorage(protocolSlot);
  123 |     | }
  124 |     | 
  125 |     | /// @notice Determines protocol's owner from the content of protocol's slot.
  126 |     | /// @param protocol The content of protocol's slot.
  127 |     | /// @return protocolOwner The protocol owner.
  128 |     | function getProtocolOwner(
  129 |     |   uint256 protocol
  130 |     | ) pure returns (
  131 |     |   address protocolOwner
  132 |     | ) {
  133 |     |   //
  134 |     |   //            6 bytes                 6 bytes             20 bytes
  135 |     |   //    +----------------------+-----------------------+---------------+
  136 |     |   //    | maxPoolGrowthPortion | protocolGrowthPortion | protocolOwner |
  137 |     |   //    +----------------------+-----------------------+---------------+
  138 |     |   //
  139 |     |   return address(uint160(protocol));
  140 |     | }
  141 |     | 
  142 |     | /// @notice Determines 'maxPoolGrowthPortion' and 'protocolGrowthPortion' from
  143 |     | /// the content of protocol's slot.
  144 |     | /// @param protocol The content of protocol's slot.
  145 |     | /// @return maxPoolGrowthPortion This value imposes a cap on the portion of the
  146 |     | /// marginal growth that goes to the pool owner followed by the protocol.
  147 |     | /// @return protocolGrowthPortion This value dictates the portion of the growth
  148 |     | /// that goes to the protocol.
  149 |     | function getGrowthPortions(
  150 |     |   uint256 protocol
  151 |     | ) pure returns (
  152 |     |   X47 maxPoolGrowthPortion,
  153 |     |   X47 protocolGrowthPortion
  154 |     | ) {
  155 |     |   //
  156 |     |   //            6 bytes                 6 bytes             20 bytes
  157 |     |   //    +----------------------+-----------------------+---------------+
  158 |     |   //    | maxPoolGrowthPortion | protocolGrowthPortion | protocolOwner |
  159 |     |   //    +----------------------+-----------------------+---------------+
  160 |     |   //
  161 |     |   assembly {
  162 |     |     maxPoolGrowthPortion := shr(208, protocol)
  163 |     |     protocolGrowthPortion := and(shr(160, protocol), 0xFFFFFFFFFFFF)
  164 |     |   }
  165 |     | }
  166 |     | 
  167 |     | /// @notice Populates the Sentinel slot.
  168 |     | /// @param sentinel The Sentinel contract to be written on storage.
  169 |     | function writeSentinel(ISentinel sentinel) {
  170 |     |   assembly {
  171 |     |     sstore(sentinelSlot, sentinel)
  172 |     |   }
  173 |     | }
  174 |     | 
  175 |     | /// @notice Reads the Sentinel slot.
  176 |     | /// @return sentinel The Sentinel contract read from storage.
  177 |     | function readSentinel() view returns (ISentinel sentinel) {
  178 |     |   assembly {
  179 |     |     sentinel := sload(sentinelSlot)
  180 |     |   }
  181 |     | }
  182 |     | 
  183 |     | /// @notice This function reads 'maxPoolGrowthPortion' and 
  184 |     | /// 'protocolGrowthPortion' from the Sentinel contract or the protocol slot. The
  185 |     | /// Sentinel contract provides the growth portions based on a snapshot of the
  186 |     | /// memory. If the portions are not set for that pool at Sentinel, it returns 
  187 |     | /// an infeasible response larger than 'oneX47' and then the default value from
  188 |     | /// the protocol slot is read.
  189 |     | function readGrowthPortions() {
  190 |     |   // First, the Sentinel contract is invoked (it it exists).
  191 |     |   (
  192 |     |     X47 maxPoolGrowthPortion,
  193 |     |     X47 protocolGrowthPortion
  194 |     |   ) = invokeSentinelGetGrowthPortions();
  195 |     | 
  196 |     |   // If any of the two given values are infeasible, then the protocol slot is
  197 |     |   // read and the resulting values from the Sentinel contract are overwritten.
  198 |     |   if (maxPoolGrowthPortion > oneX47 || protocolGrowthPortion > oneX47) {
  199 |     |     // 'maxPoolGrowthPortionProtocol' and 'protocolGrowthPortionProtocol' are
  200 |     |     // read from the protocol slot.
  201 |     |     (
  202 |     |       X47 maxPoolGrowthPortionProtocol,
  203 |     |       X47 protocolGrowthPortionProtocol
  204 |     |     ) = getGrowthPortions(readProtocol());
  205 |     | 
  206 |     |     // If 'maxPoolGrowthPortion' from the Sentinel contract is infeasible, then
  207 |     |     // 'maxPoolGrowthPortionProtocol' is chosen.
  208 |     |     if (maxPoolGrowthPortion > oneX47) {
  209 |     |       maxPoolGrowthPortion = maxPoolGrowthPortionProtocol;
  210 |     |     }
  211 |     | 
  212 |     |     // If 'protocolGrowthPortion' from the Sentinel contract is infeasible,
  213 |     |     // then 'protocolGrowthPortionProtocol' is chosen.
  214 |     |     if (protocolGrowthPortion > oneX47) {
  215 |     |       protocolGrowthPortion = protocolGrowthPortionProtocol;
  216 |     |     }
  217 |     |   }
  218 |     | 
  219 |     |   // The resulting growth portions are set in memory.
  220 |     |   setMaxPoolGrowthPortion(maxPoolGrowthPortion);
  221 |     |   setProtocolGrowthPortion(protocolGrowthPortion);
  222 |     | }
  223 |     | 
  224 |     | ////////////////////////////////////////////////////////// Single balance slots
  225 |     | 
  226 |     | // uint96(uint256(keccak256("singleBalance"))) - 1
  227 |     | uint96 constant singleBalanceSlot = 0x3C244899B5FA3E971383AC4B;
  228 |     | 
  229 |     | /// @notice This function returns the storage slot referring to
  230 |     | /// 'balanceOf(owner, tag)'.
  231 |     | /// @param owner Balance owner.
  232 |     | /// @param tag The corresponding tag.
  233 |     | /// @return storageSlot The storage slot containing 'balanceOf(owner, tag)'.
  234 |     | function getSingleBalanceSlot(
  235 |     |   address owner,
  236 |     |   Tag tag
  237 |     | ) pure returns (
  238 |     |   uint256 storageSlot
  239 |     | ) {
  240 |     |   assembly {
  241 |     |     // We populate the first two memory slots from right to left:
  242 |     |     //
  243 |     |     //    0                               32          52                  64
  244 |     |     //    |                               |           |                   |
  245 |     |     //    +-------------------------------+-----------+-------------------+
  246 |     |     //    |              tag              |   owner   | singleBalanceSlot |
  247 |     |     //    +-------------------------------+-----------+-------------------+
  248 |     |     //
  249 |     | 
  250 |     |     // Populates the least significant 12 bytes of the memory slot 1 (from 52
  251 |     |     // to 64).
  252 |     |     mstore(32, singleBalanceSlot) // 32 = 64 - 32
  253 |     | 
  254 |     |     // Populates the most significant 20 bytes of the memory slot 1 (from 32 to
  255 |     |     // 52).
  256 |     |     mstore(20, owner) // 20 = 52 - 32
  257 |     | 
  258 |     |     // Populates the entire memory slot 0.
  259 |     |     mstore(0, tag) // 0 = 32 - 32
  260 |     | 
  261 |     |     // Calculates the resulting hash.
  262 |     |     storageSlot := keccak256(0, 64)
  263 |     |   }
  264 |     | }
  265 |     | 
  266 |     | /// @notice Increments a single balance slot.
  267 |     | ///
  268 |     | /// 'amount' should be less than '2 ** 255'.
  269 |     | ///
  270 |     | /// @param owner Balance owner.
  271 |     | /// @param tag The corresponding tag.
  272 |     | /// @param amount The increment amount.
  273 |     | function incrementBalance(
  274 |     |   address owner,
  275 |     |   Tag tag,
  276 |     |   uint256 amount
  277 |     | ) {
  278 |     |   uint256 storageSlot = getSingleBalanceSlot(owner, tag);
  279 |     |   unchecked {
  280 |     |     // The addition is safe, because the current content of the 'storageSlot'
  281 |     |     // does not exceed 'type(uint128).max' and 'amount < 2 ** 255'.
  282 |     |     uint256 newBalance = readStorage(storageSlot) + amount;
  283 |     |     require(newBalance <= type(uint128).max, BalanceOverflow(newBalance));
  284 |     |     writeStorage(storageSlot, newBalance);
  285 |     |   }
  286 |     |   emitTransferEvent(msg.sender, address(0), owner, tag, amount);
  287 |     | }
  288 |     | 
  289 |     | /// @notice Decrements a single balance slot.
  290 |     | ///
  291 |     | /// @param owner Balance owner.
  292 |     | /// @param tag The corresponding tag.
  293 |     | /// @param absoluteValue The decrement amount.
  294 |     | function decrementBalance(
  295 |     |   address owner,
  296 |     |   Tag tag,
  297 |     |   uint256 absoluteValue
  298 |     | ) {
  299 |     |   uint256 storageSlot = getSingleBalanceSlot(owner, tag);
  300 |     |   uint256 balance = readStorage(storageSlot);
  301 |     |   updateAllowance(owner, tag, absoluteValue);
  302 |     |   require(balance >= absoluteValue, InsufficientBalance(owner, tag));
  303 |     |   unchecked {
  304 |     |     // The subtraction is safe due to the prior check.
  305 |     |     writeStorage(storageSlot, balance - absoluteValue);
  306 |     |   }
  307 |     |   emitTransferEvent(msg.sender, owner, address(0), tag, absoluteValue);
  308 |     | }
  309 |     | 
  310 |     | ////////////////////////////////////////////////////////// Double balance slots
  311 |     | 
  312 |     | // uint96(uint256(keccak256("doubleBalance"))) - 1
  313 |     | uint96 constant doubleBalanceSlot = 0xC8F78086C3211E71A328E7F5;
  314 |     | 
  315 |     | /// @notice This function returns the storage slot pointing to owner's double
  316 |     | /// balance of tags 0 and 1. This storage slot contains a balance for both
  317 |     | /// tokens which can be used to save gas.
  318 |     | ///
  319 |     | /// @param owner Balance owner.
  320 |     | /// @param tag0 The corresponding tag0.
  321 |     | /// @param tag1 The corresponding tag1.
  322 |     | /// @return storageSlot The storage slot containing the double balance of
  323 |     | /// 'tag0' and 'tag1'.
  324 |     | function getDoubleBalanceSlot(
  325 |     |   address owner,
  326 |     |   Tag tag0,
  327 |     |   Tag tag1
  328 |     | ) pure returns (uint256 storageSlot) {
  329 |     |   assembly {
  330 |     |     // We populate the first three memory slots from right to left:
  331 |     |     //
  332 |     |     //    0              32             64              84                  96
  333 |     |     //    |              |              |               |                   |
  334 |     |     //    +--------------+--------------+---------------+-------------------+
  335 |     |     //    |     tag0     |     tag1     |     owner     | doubleBalanceSlot |
  336 |     |     //    +--------------+--------------+---------------+-------------------+
  337 |     |     //
  338 |     |     let freeMemoryPointer := mload(0x40)
  339 |     |     mstore(64, doubleBalanceSlot) // 64 = 96 - 32
  340 |     |     mstore(52, owner) // 52 = 84 - 32
  341 |     |     mstore(32, tag1) // 32 = 64 - 32
  342 |     |     mstore(0, tag0) // 32 = 32 - 32
  343 |     |     storageSlot := keccak256(0, 96)
  344 |     |     mstore(0x40, freeMemoryPointer)
  345 |     |   }
  346 |     | }
  347 |     | 
  348 |     | /// @notice This function returns the content of the double balance slot which
  349 |     | /// is pointed to by 'storageSlot'.
  350 |     | ///
  351 |     | /// @param storageSlot The storage slot containing the double balance of 'tag0'
  352 |     | /// and 'tag1'.
  353 |     | /// @return amount0 The amount of tag0.
  354 |     | /// @return amount1 The amount of tag1.
  355 |     | function readDoubleBalance(
  356 |     |   uint256 storageSlot
  357 |     | ) view returns (
  358 |     |   uint256 amount0,
  359 |     |   uint256 amount1
  360 |     | ) {
  361 |     |   uint256 pairBalance = readStorage(storageSlot);
  362 |     |   assembly {
  363 |     |     amount0 := and(pairBalance, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)
  364 |     |     amount1 := shr(128, pairBalance)
  365 |     |   }
  366 |     | }
  367 |     | 
  368 |     | /// @notice This function populates the double balance slot which is pointed to
  369 |     | /// by 'storageSlot'.
  370 |     | ///
  371 |     | /// @param storageSlot The storage slot to be populated.
  372 |     | /// @param amount0 The amount of tag0.
  373 |     | /// @param amount1 The amount of tag1.
  374 |     | function writeDoubleBalance(
  375 |     |   uint256 storageSlot,
  376 |     |   uint256 amount0,
  377 |     |   uint256 amount1
  378 |     | ) {
  379 |     |   require(amount0 <= type(uint128).max, BalanceOverflow(amount0));
  380 |     |   require(amount1 <= type(uint128).max, BalanceOverflow(amount1));
  381 |     |   writeStorage(storageSlot, (amount1 << 128) | amount0);
  382 |     | }
  383 |     | 
  384 |     | ///////////////////////////////////////////////////////// LP total supply slots
  385 |     | 
  386 |     | // uint128(uint256(keccak256("totalSupply"))) - 1
  387 |     | uint128 constant totalSupplySlot = 0x5daca5ccc655360fa5ccacf9c267936c;
  388 |     | 
  389 |     | /// @notice This function increments/decrements total supply associated with
  390 |     | /// LP positions.
  391 |     | ///
  392 |     | /// @param poolId The pool identifier hosting this liquidity position.
  393 |     | /// @param qMin Equal to '(2 ** 59) * (16 + log(pMin / pOffset))'.
  394 |     | /// @param qMax Equal to '(2 ** 59) * (16 + log(pMax / pOffset))'.
  395 |     | /// @param shares The number of shares to be added/subtracted.
  396 |     | function updateTotalSupply(
  397 |     |   uint256 poolId,
  398 |     |   X59 qMin,
  399 |     |   X59 qMax,
  400 |     |   int256 shares
  401 |     | ) {
  402 |     |   // We populate the first two memory slots from right to left:
  403 |     |   //
  404 |     |   //    0        32     40     48                64
  405 |     |   //    |        |      |      |                 |
  406 |     |   //    +--------+------+------+-----------------+
  407 |     |   //    | poolId | qMin | qMax | totalSupplySlot |
  408 |     |   //    +--------+------+------+-----------------+
  409 |     |   //
  410 |     |   uint256 storageSlot;
  411 |     |   assembly {
  412 |     |     mstore(32, totalSupplySlot) // 32 = 64 - 32
  413 |     |     mstore(16, qMax) // 16 = 48 - 32
  414 |     |     mstore(8, qMin) // 8 = 40 - 32
  415 |     |     mstore(0, poolId) // 0 = 32 - 32
  416 |     |     storageSlot := keccak256(0, 64)
  417 |     |   }
  418 |     |   uint256 totalSupply = readStorage(storageSlot);
  419 |     |   assembly {
  420 |     |     totalSupply := add(totalSupply, shares)
  421 |     |   }
  422 |     |   require(totalSupply <= type(uint128).max, BalanceOverflow(totalSupply));
  423 |     |   writeStorage(storageSlot, totalSupply);
  424 |     | }
  425 |     | 
  426 |     | //////////////////////////////////////////////////////////////// Operator slots
  427 |     | 
  428 |     | // uint96(uint256(keccak256("isOperator"))) - 1
  429 |     | uint96 constant isOperatorSlot = 0xE442B523D9447037E4923F5B;
  430 |     | 
  431 |     | /// @notice This function returns the storage slot referring to
  432 |     | /// 'isOperator(owner, spender)'.
  433 |     | ///
  434 |     | /// @param owner Balance owner.
  435 |     | /// @param spender The spender whose allowance to be read.
  436 |     | /// @return storageSlot The storage slot which records whether the 'spender'
  437 |     | /// is an operator for the 'owner' or not.
  438 |     | function getIsOperatorSlot(
  439 |     |   address owner,
  440 |     |   address spender
  441 |     | ) pure returns (uint256 storageSlot) {
  442 |     |   // We populate the first two memory slots from right to left:
  443 |     |   //
  444 |     |   //    12              32              52               64
  445 |     |   //    |               |               |                |
  446 |     |   //    +---------------+---------------+----------------+
  447 |     |   //    |    spender    |     owner     | isOperatorSlot |
  448 |     |   //    +---------------+---------------+----------------+
  449 |     |   //
  450 |     |   assembly {
  451 |     |     mstore(32, isOperatorSlot) // 32 = 64 - 32
  452 |     |     mstore(20, owner) // 20 = 52 - 32
  453 |     |     mstore(0, spender) // 0 = 32 - 32
  454 |     |     storageSlot := keccak256(12, 52) // 52 = 64 - 12
  455 |     |   }
  456 |     | }
  457 |     | 
  458 |     | /////////////////////////////////////////////////////////////// Allowance slots
  459 |     | 
  460 |     | // uint96(uint256(keccak256("allowance"))) - 1
  461 |     | uint96 constant allowanceSlot = 0x34105B980BA117BD0C29FE0;
  462 |     | 
  463 |     | /// @notice This function returns the storage slot pointing to
  464 |     | /// 'allowance(owner, spender, tag)'.
  465 |     | ///
  466 |     | /// @param owner Balance owner.
  467 |     | /// @param spender The spender whose allowance to be read.
  468 |     | /// @param tag The corresponding tag.
  469 |     | /// @return storageSlot The storage slot to be calculated.
  470 |     | function getAllowanceSlot(
  471 |     |   address owner,
  472 |     |   address spender,
  473 |     |   Tag tag
  474 |     | ) pure returns (
  475 |     |   uint256 storageSlot
  476 |     | ) {
  477 |     |   // We populate the first three memory slots from right to left:
  478 |     |   //
  479 |     |   //    0             32              52              72              84
  480 |     |   //    |             |               |               |               |
  481 |     |   //    +-------------+---------------+---------------+---------------+
  482 |     |   //    |     tag     |    spender    |     owner     | allowanceSlot |
  483 |     |   //    +-------------+---------------+---------------+---------------+
  484 |     |   //
  485 |     |   assembly {
  486 |     |     let freeMemoryPointer := mload(0x40)
  487 |     |     mstore(52, allowanceSlot) // 52 = 84 - 32
  488 |     |     mstore(40, owner) // 40 = 72 - 32
  489 |     |     mstore(20, spender) // 20 = 52 - 32
  490 |     |     mstore(0, tag) // 0 = 32 - 32
  491 |     |     storageSlot := keccak256(0, 84)
  492 |     |     mstore(0x40, freeMemoryPointer)
  493 |     |   }
  494 |     | }
  495 |     | 
  496 |     | /// @notice This function updates ERC-6909 allowance after each expenditure
  497 |     | /// performed by a spender.
  498 |     | ///
  499 |     | /// @param owner Balance owner.
  500 |     | /// @param tag The corresponding tag.
  501 |     | /// @param amount The amount to be decremented from allowance.
  502 |     | function updateAllowance(
  503 |     |   address owner,
  504 |     |   Tag tag,
  505 |     |   uint256 amount
  506 |     | ) {
  507 |     |   // If 'owner' is equal to 'spender', then we do not need to decrement any
  508 |     |   // allowance value.
  509 |     |   if (owner != msg.sender) {
  510 |     |     // If 'owner' is the operator, then we do not need to decrement any
  511 |     |     // allowance value either.
  512 |     |     if (readStorage(getIsOperatorSlot(owner, msg.sender)) == 0) {
  513 |     |       uint256 storageSlot = getAllowanceSlot(owner, msg.sender, tag);
  514 |     |       uint256 senderAllowance = readStorage(storageSlot);
  515 |     |       require(
  516 |     |         senderAllowance >= amount,
  517 |     |         InsufficientPermission(msg.sender, tag)
  518 |     |       );
  519 |     |       if (senderAllowance != type(uint256).max) {
  520 |     |         unchecked {
  521 |     |           // The subtraction is safe due to the prior check.
  522 |     |           writeStorage(storageSlot, senderAllowance - amount);
  523 |     |         }
  524 |     |       }
  525 |     |     }
  526 |     |   }
  527 |     | }
  528 |     | 
  529 |     | ////////////////////////////////////////////////////////////// Pool owner slots
  530 |     | 
  531 |     | // uint128(uint256(keccak256("poolOwner"))) - 1
  532 |     | uint128 constant poolOwnerSlot = 0x68E919334073168F7B6F6D0178986A64;
  533 |     | 
  534 |     | /// @notice This function returns the storage slot referring to the owner of
  535 |     | /// a pool.
  536 |     | ///
  537 |     | /// @param poolId The 'poolId' whose owner slot to be derived.
  538 |     | /// @return storageSlot The storage slot containing the pool owner.
  539 |     | function getPoolOwnerSlot(
  540 |     |   uint256 poolId
  541 |     | ) pure returns (uint256 storageSlot) {
  542 |     |   assembly {
  543 |     |     // We populate the first two memory slots from right to left:
  544 |     |     //
  545 |     |     //    0              32              48
  546 |     |     //    |              |               |
  547 |     |     //    +--------------+---------------+
  548 |     |     //    |    poolId    | poolOwnerSlot |
  549 |     |     //    +--------------+---------------+
  550 |     |     //
  551 |     |     mstore(16, poolOwnerSlot) // 16 = 48 - 32
  552 |     |     mstore(0, poolId)
  553 |     |     storageSlot := keccak256(0, 48)
  554 |     |   }
  555 |     | }
  556 |     | 
  557 |     | /// @notice Returns the owner of a given pool.
  558 |     | ///
  559 |     | /// @param storageSlot The storage slot containing the pool owner.
  560 |     | /// @return poolOwner The pool owner to be returned.
  561 |     | function readPoolOwner(
  562 |     |   uint256 storageSlot
  563 |     | ) view returns (address poolOwner) {
  564 |     |   return address(uint160(readStorage(storageSlot)));
  565 |     | }
  566 |     | 
  567 |     | /// @notice Writes the owner of a given pool on storage.
  568 |     | ///
  569 |     | /// @param storageSlot The storage slot to be populated.
  570 |     | /// @param poolOwner The pool owner to be written on the 'storageSlot'.
  571 |     | function writePoolOwner(
  572 |     |   uint256 storageSlot,
  573 |     |   address poolOwner
  574 |     | ) {
  575 |     |   writeStorage(storageSlot, uint256(uint160(poolOwner)));
  576 |     | }
  577 |     | 
  578 |     | ////////////////////////////////////////////////////// Accrued parameters slots
  579 |     | 
  580 |     | // uint128(uint256(keccak256("accruedParams"))) - 1
  581 |     | uint128 constant accruedParamsSlot = 0x5E1C6265E3E30CEA650443FB20EF1EF9;
  582 |     | 
  583 |     | /// @notice This function returns the storage slot containing to the pool's
  584 |     | /// accrued growth portions.
  585 |     | ///
  586 |     | /// @param poolId The 'poolId' whose owner slot to be derived.
  587 |     | /// @return storageSlot The storage slot containing the pool owner.
  588 |     | function getAccruedParamsSlot(
  589 |     |   uint256 poolId
  590 |     | ) pure returns (uint256 storageSlot) {
  591 |     |   assembly {
  592 |     |     // We populate the first two memory slots from right to left:
  593 |     |     //
  594 |     |     //    0              32                  48
  595 |     |     //    |              |                   |
  596 |     |     //    +--------------+-------------------+
  597 |     |     //    |    poolId    | accruedParamsSlot |
  598 |     |     //    +--------------+-------------------+
  599 |     |     //
  600 |     |     mstore(16, accruedParamsSlot) // 16 = 48 - 32
  601 |     |     mstore(0, poolId)
  602 |     |     storageSlot := keccak256(0, 48)
  603 |     |   }
  604 |     | }
  605 |     | 
  606 |     | /// @notice This function reads the pool's accrued growth portions from storage
  607 |     | /// and sets them in the appropriate memory locations:
  608 |     | ///
  609 |     | /// poolRatio0 (24 bits): the ratio of accrued value0 belonging to the pool.
  610 |     | /// poolRatio1 (24 bits): the ratio of accrued value1 belonging to the pool.
  611 |     | /// accrued0 (104 bits): total accrued in tag0 owed to both pool and protocol.
  612 |     | /// accrued1 (104 bits): total accrued in tag1 owed to both pool and protocol.
  613 |     | ///
  614 |     | /// The above values are encoded tightly in the following order:
  615 |     | ///
  616 |     | ///         3 bytes          3 bytes          13 bytes         13 bytes
  617 |     | ///    +----------------+----------------+----------------+----------------+
  618 |     | ///    |   poolRatio1   |   poolRatio0   |    accrued1    |    accrued0    |
  619 |     | ///    +----------------+----------------+----------------+----------------+
  620 |     | ///
  621 |     | function readAccruedParams() view {
  622 |     |   X23 poolRatio0;
  623 |     |   X23 poolRatio1;
  624 |     |   X127 accrued0;
  625 |     |   X127 accrued1;
  626 |     |   uint256 accruedSlot = readStorage(getAccruedParamsSlot(getPoolId()));
  627 |     |   assembly {
  628 |     |     poolRatio0 := and(shr(208, accruedSlot), 0xFFFFFF)
  629 |     |     poolRatio1 := shr(232, accruedSlot)
  630 |     |     accrued0 := shl(127, and(accruedSlot, 0xFFFFFFFFFFFFFFFFFFFFFFFFFF))
  631 |     |     accrued1 := shl(23, and(
  632 |     |       accruedSlot,
  633 |     |       shl(104, 0xFFFFFFFFFFFFFFFFFFFFFFFFFF)
  634 |     |     ))
  635 |     |   }
  636 |     |   setPoolRatio0(poolRatio0);
  637 |     |   setPoolRatio1(poolRatio1);
  638 |     |   setAccrued0(accrued0);
  639 |     |   setAccrued1(accrued1);
  640 |     | }
  641 |     | 
  642 |     | /// @notice This function writes pool's accrued growth portions to storage from
  643 |     | /// memory.
  644 |     | function writeAccruedParams() {
  645 |     |   X127 accrued0 = getAccrued0();
  646 |     |   require(accrued0 >= zeroX127, AccruedGrowthPortionOverflow(accrued0));
  647 |     |   require(accrued0 <= accruedMax, AccruedGrowthPortionOverflow(accrued0));
  648 |     | 
  649 |     |   X127 accrued1 = getAccrued1();
  650 |     |   require(accrued1 >= zeroX127, AccruedGrowthPortionOverflow(accrued1));
  651 |     |   require(accrued1 <= accruedMax, AccruedGrowthPortionOverflow(accrued1));
  652 |     | 
  653 |     |   X23 poolRatio0 = getPoolRatio0();
  654 |     |   X23 poolRatio1 = getPoolRatio1();
  655 |     | 
  656 |     |   uint256 accruedSlot = getAccruedParamsSlot(getPoolId());
  657 |     |   uint256 accrued;
  658 |     |   assembly {
  659 |     |     accrued := or(
  660 |     |       or(shl(232, poolRatio1), shl(208, poolRatio0)),
  661 |     |       or(shl(104, shr(127, accrued1)), shr(127, accrued0))
  662 |     |     )
  663 |     |   }
  664 |     |   writeStorage(accruedSlot, accrued);
  665 |     | }
  666 |     | 
  667 |     | /////////////////////////////////////////////////////// Growth multiplier slots
  668 |     | 
  669 |     | // uint64(uint256(keccak256("growthMultiplier"))) - 1
  670 |     | uint64 constant growthMultiplierSlot = 0x1447E579411C2C93;
  671 |     | 
  672 |     | /// @notice This function returns the storage slot containing the pool's growth
  673 |     | /// multiplier at the given interval boundary, i.e.,
  674 |     | /// 'growthMultiplier[qBoundary]'.
  675 |     | ///
  676 |     | /// @param poolId The corresponding poolId.
  677 |     | /// @param qBoundary The interval boundary whose corresponding growth
  678 |     | /// multiplier slot is to be derived.
  679 |     | /// @return storageSlot The storage slot containing the growth multiplier.
  680 |     | function getGrowthMultiplierSlot(
  681 |     |   uint256 poolId,
  682 |     |   X59 qBoundary
  683 |     | ) pure returns (uint256 storageSlot) {
  684 |     |   assembly {
  685 |     |     // We populate the first two memory slots from right to left:
  686 |     |     //
  687 |     |     //    0                32                   40                     48
  688 |     |     //    |                |                    |                      |
  689 |     |     //    +----------------+--------------------+----------------------+
  690 |     |     //    |     poolId     |      qBoundary     | growthMultiplierSlot |
  691 |     |     //    +----------------+--------------------+----------------------+
  692 |     |     //
  693 |     |     mstore(16, growthMultiplierSlot) // 16 = 48 - 32
  694 |     |     mstore(8, qBoundary) // 8 = 40 - 32
  695 |     |     mstore(0, poolId) // 0 = 32 - 32
  696 |     |     storageSlot := keccak256(0, 48)
  697 |     |   }
  698 |     | }
  699 |     | 
  700 |     | /// @notice Reads the growth multiplier from 'storageSlot'.
  701 |     | ///
  702 |     | /// @param storageSlot The storage slot hosting the growth multiplier.
  703 |     | /// @return growthMultiplier The growth multiplier to be returned.
  704 |     | function readGrowthMultiplier(
  705 |     |   uint256 storageSlot
  706 |     | ) view returns (
  707 |     |   X208 growthMultiplier
  708 |     | ) {
  709 |     |   assembly {
  710 |     |     growthMultiplier := sload(storageSlot)
  711 |     |   }
  712 |     | }
  713 |     | 
  714 |     | /// @notice This function calculates the following default value of
  715 |     | /// 'growthMultiplier[qBoundary]' for a given spaced 'qBoundary' with the
  716 |     | /// assumption that "qUpper <= qBoundary":
  717 |     | ///
  718 |     | ///                                     +oo
  719 |     | ///                                    -----
  720 |     | ///    growthMultiplier[qBoundary]     \       - (qBoundary + j * qSpacing) / 2
  721 |     | ///  '----------------------------- == /     e
  722 |     | ///              2 ** 208              -----
  723 |     | ///                                    j = 0
  724 |     | ///
  725 |     | ///       - qBoundary / 2
  726 |     | ///     e
  727 |     | ///   ---------------------- ==
  728 |     | ///          - qSpacing / 2
  729 |     | ///    1 - e
  730 |     | ///
  731 |     | ///                                - 8 - qBoundary / 2
  732 |     | ///     + 8         (2 ** 216) * e
  733 |     | ///   e     * -------------------------------------------- ==
  734 |     | ///                                        - qSpacing / 2
  735 |     | ///            (2 ** 216) - (2 ** 216) * e
  736 |     | ///
  737 |     | ///                                - 8 - qBoundary / 2
  738 |     | ///    exp8X208     (2 ** 216) * e
  739 |     | ///   ---------- * ------------------------------------ '.
  740 |     | ///    2 ** 208      oneX216 - _spacing_.sqrt(false)
  741 |     | ///
  742 |     | /// This is because the boundary is touched for the first time and the growth 
  743 |     | /// for every single interval on its right side is equal to '1'.
  744 |     | ///
  745 |     | /// 'qBoundary' should be positive and less than '2 ** 64'.
  746 |     | ///
  747 |     | /// @param qBoundary The interval boundary whose corresponding growth
  748 |     | /// multiplier is to be derived.
  749 |     | /// @return growthMultiplier The growth multiplier to be returned.
  750 |     | function calculateGrowthMultiplier0(
  751 |     |   X59 qBoundary
  752 |     | ) pure returns (
  753 |     |   X208 growthMultiplier
  754 |     | ) {
  755 |     |   // The requirements of 'exp' are satisfied here due to the input 
  756 |     |   // requirement of the present function.
  757 |     |   (X216 sqrtPrice, ) = qBoundary.exp();
  758 |     | 
  759 |     |   // 'mulDiv' is safe because both the 'numerator' and 'denominator' are
  760 |     |   // nonnegative and also, the output does not exceed 256-bits. More
  761 |     |   // precisely:
  762 |     |   //
  763 |     |   //                     - qBoundary / 2
  764 |     |   //                   e
  765 |     |   //   '(2 ** 208) * ---------------------- ==
  766 |     |   //                        - qSpacing / 2
  767 |     |   //                  1 - e
  768 |     |   //
  769 |     |   //                                  + 8
  770 |     |   //                                e
  771 |     |   //    (2 ** 208) * ----------------------------------- < 2 ** 256'
  772 |     |   //                        - minLogSpacing / (2 ** 60)
  773 |     |   //                  1 - e
  774 |     |   //
  775 |     |   growthMultiplier = exp8X208.mulDiv(
  776 |     |     sqrtPrice,
  777 |     |     oneX216 - _spacing_.sqrt(false)
  778 |     |   );
  779 |     | }
  780 |     | 
  781 |     | /// @notice This function calculates the following default value of
  782 |     | /// 'growthMultiplier[qBoundary]' for a given spaced 'qBoundary' with the
  783 |     | /// assumption that "qBoundary <= qLower":
  784 |     | ///
  785 |     | ///                                     +oo
  786 |     | ///                                    -----
  787 |     | ///    growthMultiplier[qBoundary]     \       + (qBoundary - j * qSpacing) / 2
  788 |     | ///  '----------------------------- == /     e
  789 |     | ///              2 ** 208              -----
  790 |     | ///                                    j = 0
  791 |     | ///
  792 |     | ///       + qBoundary / 2
  793 |     | ///     e
  794 |     | ///   ---------------------- ==
  795 |     | ///          - qSpacing / 2
  796 |     | ///    1 - e
  797 |     | ///
  798 |     | ///                                - 8 + qBoundary / 2
  799 |     | ///     + 8         (2 ** 216) * e
  800 |     | ///   e     * -------------------------------------------- ==
  801 |     | ///                                        - qSpacing / 2
  802 |     | ///            (2 ** 216) - (2 ** 216) * e
  803 |     | ///
  804 |     | ///                                - 8 + qBoundary / 2
  805 |     | ///    exp8X208     (2 ** 216) * e
  806 |     | ///   ---------- * ------------------------------------ '.
  807 |     | ///    2 ** 208      oneX216 - _spacing_.sqrt(false)
  808 |     | ///
  809 |     | /// This is because the boundary is touched for the first time and the growth 
  810 |     | /// for every single interval on its right side is equal to '1'.
  811 |     | /// 
  812 |     | /// 'qBoundary' should be positive and less than '2 ** 64'.
  813 |     | ///
  814 |     | /// @param qBoundary The interval boundary whose corresponding growth
  815 |     | /// multiplier is to be derived.
  816 |     | /// @return growthMultiplier The growth multiplier to be returned.
  817 |     | function calculateGrowthMultiplier1(
  818 |     |   X59 qBoundary
  819 |     | ) pure returns (
  820 |     |   X208 growthMultiplier
  821 |     | ) {
  822 |     |   // The requirements of 'exp' are satisfied here due to the input 
  823 |     |   // requirement of the present function.
  824 |     |   (, X216 sqrtInversePrice) = qBoundary.exp();
  825 |     | 
  826 |     |   // 'mulDiv' is safe because both the 'numerator' and 'denominator' are
  827 |     |   // nonnegative and also, the output does not exceed 256-bits. More
  828 |     |   // precisely:
  829 |     |   //
  830 |     |   //                     + qBoundary / 2
  831 |     |   //                   e
  832 |     |   //   '(2 ** 208) * ---------------------- ==
  833 |     |   //                        - qSpacing / 2
  834 |     |   //                  1 - e
  835 |     |   //
  836 |     |   //                                  + 8
  837 |     |   //                                e
  838 |     |   //    (2 ** 208) * ----------------------------------- < 2 ** 256'
  839 |     |   //                        - minLogSpacing / (2 ** 60)
  840 |     |   //                  1 - e
  841 |     |   //
  842 |     |   growthMultiplier = exp8X208.mulDiv(
  843 |     |     sqrtInversePrice,
  844 |     |     oneX216 - _spacing_.sqrt(false)
  845 |     |   );
  846 |     | }
  847 |     | 
  848 |     | /// @notice This function returns 'growthMultiplier[qBoundary]' for a given
  849 |     | /// spaced 'qBoundary' with the assumption that "qUpper <= qBoundary". If 
  850 |     | /// 'growthMultiplier[qBoundary]' is never set on storage, the function returns
  851 |     | /// the default value.
  852 |     | ///
  853 |     | /// 'qBoundary' should be positive and less than '2 ** 64'.
  854 |     | ///
  855 |     | /// @param qBoundary The interval boundary whose corresponding growth
  856 |     | /// multiplier is to be derived.
  857 |     | /// @return growthMultiplier The growth multiplier to be returned.
  858 |     | function readGrowthMultiplier0(
  859 |     |   X59 qBoundary
  860 |     | ) returns (
  861 |     |   X208 growthMultiplier
  862 |     | ) {
  863 |     |   // The storage slot containing 'growthMultiplier[qBoundary]' is derived.
  864 |     |   uint256 storageSlot = getGrowthMultiplierSlot(getPoolId(), qBoundary);
  865 |     | 
  866 |     |   // 'growthMultiplier[qBoundary]' is read from storage.
  867 |     |   growthMultiplier = readGrowthMultiplier(storageSlot);
  868 |     | 
  869 |     |   // If 'growthMultiplier[qBoundary]' is not set before, then it should be
  870 |     |   // calculated, written on storage and returned.
  871 |     |   if (growthMultiplier == zeroX208) {
  872 |     |     // The default value for 'growthMultiplier[qBoundary]' is calculated.
  873 |     |     growthMultiplier = calculateGrowthMultiplier0(qBoundary);
  874 |     | 
  875 |     |     // The calculation for 'growthMultiplier[qBoundary]' is written on storage.
  876 |     |     writeGrowthMultiplier(storageSlot, growthMultiplier);
  877 |     |   }
  878 |     | }
  879 |     | 
  880 |     | /// @notice This function returns 'growthMultiplier[qBoundary]' for a given
  881 |     | /// spaced 'qBoundary' with the assumption that "qBoundary <= qLower". If 
  882 |     | /// 'growthMultiplier[qBoundary]' is never set on storage, the function returns
  883 |     | /// the default value.
  884 |     | ///
  885 |     | /// 'qBoundary' should be positive and less than '2 ** 64'.
  886 |     | ///
  887 |     | /// @param qBoundary The interval boundary whose corresponding growth
  888 |     | /// multiplier is to be derived.
  889 |     | /// @return growthMultiplier The growth multiplier to be returned.
  890 |     | function readGrowthMultiplier1(
  891 |     |   X59 qBoundary
  892 |     | ) returns (
  893 |     |   X208 growthMultiplier
  894 |     | ) {
  895 |     |   // The storage slot containing 'growthMultiplier[qBoundary]' is derived.
  896 |     |   uint256 storageSlot = getGrowthMultiplierSlot(getPoolId(), qBoundary);
  897 |     | 
  898 |     |   // 'growthMultiplier[qBoundary]' is read from storage.
  899 |     |   growthMultiplier = readGrowthMultiplier(storageSlot);
  900 |     | 
  901 |     |   // If 'growthMultiplier[qBoundary]' is not set before, then it should be
  902 |     |   // calculated, written on storage and returned.
  903 |     |   if (growthMultiplier == zeroX208) {
  904 |     |     // The default value for 'growthMultiplier[qBoundary]' is calculated.
  905 |     |     growthMultiplier = calculateGrowthMultiplier1(qBoundary);
  906 |     | 
  907 |     |     // The calculated for 'growthMultiplier[qBoundary]' is written on storage.
  908 |     |     writeGrowthMultiplier(storageSlot, growthMultiplier);
  909 |     |   }
  910 |     | }
  911 |     | 
  912 |     | /// @notice This function writes the given 'growthMultiplier' in the given
  913 |     | ///  'storageSlot'.
  914 |     | ///
  915 |     | /// @param storageSlot The storage slot on which the growth multiplier is
  916 |     | /// written.
  917 |     | /// @param growthMultiplier The growth multiplier to be written.
  918 |     | function writeGrowthMultiplier(
  919 |     |   uint256 storageSlot,
  920 |     |   X208 growthMultiplier
  921 |     | ) {
  922 |     |   assembly {
  923 |     |     sstore(storageSlot, growthMultiplier)
  924 |     |   }
  925 |     | }
  926 |     | 
  927 |     | /// @notice This function writes 'growthMultiplier' values for the boundaries
  928 |     | /// of the first active interval.
  929 |     | ///
  930 |     | /// @param qLower The left boundary of the active liquidity interval
  931 |     | /// @param qUpper The right boundary of the active liquidity interval
  932 |     | ///
  933 |     | /// 'qLower' and 'qUpper' should be positive and less than '2 ** 64'.
  934 |     | ///
  935 |     | function writeGrowthMultipliers(
  936 |     |   X59 qLower,
  937 |     |   X59 qUpper
  938 |     | ) {
  939 |     |   uint256 poolId = getPoolId();
  940 |     | 
  941 |     |   // The default value for 'growthMultiplier[qLower]' is calculated and written
  942 |     |   // in the appropriate storage slot.
  943 |     |   writeGrowthMultiplier(
  944 |     |     getGrowthMultiplierSlot(poolId, qLower),
  945 |     |     calculateGrowthMultiplier1(qLower)
  946 |     |   );
  947 |     | 
  948 |     |   // The default value for 'growthMultiplier[qUpper]' is calculated and written
  949 |     |   // in the appropriate storage slot.
  950 |     |   writeGrowthMultiplier(
  951 |     |     getGrowthMultiplierSlot(poolId, qUpper),
  952 |     |     calculateGrowthMultiplier0(qUpper)
  953 |     |   );
  954 |     | }
  955 |     | 
  956 |     | ////////////////////////////////////////////////////////////////// Shares slots
  957 |     | 
  958 |     | // uint128(uint256(keccak256("sharesGross"))) - 1
  959 |     | uint128 constant sharesGrossSlot = 0xA20D6232B6352D00ABC0D966E2BCFB8A;
  960 |     | 
  961 |     | /// @notice This function returns the storage slot hosting the total number of
  962 |     | /// shares across every single interval of a pool.
  963 |     | ///
  964 |     | /// @param poolId The 'poolId' whose owner slot to be derived.
  965 |     | /// @return storageSlot The storage slot containing the pool owner.
  966 |     | function getSharesGrossSlot(
  967 |     |   uint256 poolId
  968 |     | ) pure returns (
  969 |     |   uint256 storageSlot
  970 |     | ) {
  971 |     |   assembly {
  972 |     |     // We populate the first two memory slots from right to left:
  973 |     |     //
  974 |     |     //    0                32                         48
  975 |     |     //    |                |                          |
  976 |     |     //    +----------------+--------------------------+
  977 |     |     //    |     poolId     |      sharesGrossSlot     |
  978 |     |     //    +----------------+--------------------------+
  979 |     |     //
  980 |     |     mstore(16, sharesGrossSlot)
  981 |     |     mstore(0, poolId)
  982 |     |     storageSlot := keccak256(0, 48)
  983 |     |   }
  984 |     | }
  985 |     | 
  986 |     | // uint64(uint256(keccak256("sharesDelta"))) - 1
  987 |     | uint64 constant sharesDeltaSlot = 0xD7CB7A927A838D41;
  988 |     | 
  989 |     | /// @notice This function returns the storage slot containing the pool's shares
  990 |     | /// delta at the given interval boundary, i.e., 'sharesDelta[qBoundary]'.
  991 |     | ///
  992 |     | /// @param poolId The corresponding poolId.
  993 |     | /// @param qBoundary The interval boundary whose corresponding shares delta
  994 |     | /// slot is to be derived.
  995 |     | /// @return storageSlot The storage slot containing the shares delta.
  996 |     | function getSharesDeltaSlot(
  997 |     |   uint256 poolId,
  998 |     |   X59 qBoundary
  999 |     | ) pure returns (
 1000 |     |   uint256 storageSlot
 1001 |     | ) {
 1002 |     |   assembly {
 1003 |     |     // We populate the first two memory slots from right to left:
 1004 |     |     //
 1005 |     |     //    0                32                   40                48
 1006 |     |     //    |                |                    |                 |
 1007 |     |     //    +----------------+--------------------+-----------------+
 1008 |     |     //    |     poolId     |      qBoundary     | sharesDeltaSlot |
 1009 |     |     //    +----------------+--------------------+-----------------+
 1010 |     |     //
 1011 |     |     mstore(16, sharesDeltaSlot)
 1012 |     |     mstore(8, qBoundary)
 1013 |     |     mstore(0, poolId)
 1014 |     |     storageSlot := keccak256(0, 48)
 1015 |     |   }
 1016 |     | }
 1017 |     | 
 1018 |     | /// @notice Reads shares delta from 'storageSlot'.
 1019 |     | ///
 1020 |     | /// @param storageSlot The storage slot hosting the shares delta.
 1021 |     | /// @return sharesDelta The shares delta to be returned.
 1022 |     | function readSharesDelta(
 1023 |     |   uint256 storageSlot
 1024 |     | ) view returns (
 1025 |     |   int256 sharesDelta
 1026 |     | ) {
 1027 |     |   assembly {
 1028 |     |     sharesDelta := sload(storageSlot)
 1029 |     |   }
 1030 |     | }
 1031 |     | 
 1032 |     | /// @notice Gets the number of shares to be deposited/withdrawn as a result of
 1033 |     | /// modifying a position from memory and adjusting 'sharesDelta' values in
 1034 |     | /// storage accordingly.
 1035 |     | function modifySharesDelta() {
 1036 |     |   // 'poolId' and the number of shares to be added/subtracted are loaded from
 1037 |     |   // the memory.
 1038 |     |   uint256 poolId = getPoolId();
 1039 |     |   int256 shares = getShares();
 1040 |     | 
 1041 |     |   // 'sharesDelta[logPriceMinOffsetted]' is adjusted.
 1042 |     |   X59 logPriceMinOffsetted = getLogPriceMinOffsetted();
 1043 |     |   uint256 storageSlot = getSharesDeltaSlot(poolId, logPriceMinOffsetted);
 1044 |     |   assembly {
 1045 |     |     sstore(storageSlot, add(sload(storageSlot), shares))
 1046 |     |   }
 1047 |     | 
 1048 |     |   // 'sharesDelta[logPriceMaxOffsetted]' is adjusted.
 1049 |     |   X59 logPriceMaxOffsetted = getLogPriceMaxOffsetted();
 1050 |     |   storageSlot = getSharesDeltaSlot(poolId, logPriceMaxOffsetted);
 1051 |     |   assembly {
 1052 |     |     sstore(storageSlot, sub(sload(storageSlot), shares))
 1053 |     |   }
 1054 |     | 
 1055 |     |   // The total number of shares across all intervals may never exceed
 1056 |     |   // 'type(int128).max'. This is verified next.
 1057 |     |   int256 sharesGross;
 1058 |     |   storageSlot = getSharesGrossSlot(poolId);
 1059 |     |   X59 qSpacing = _spacing_.log();
 1060 |     |   assembly {
 1061 |     |     sharesGross := add(
 1062 |     |       sload(storageSlot),
 1063 |     |       //
 1064 |     |       //             logPriceMaxOffsetted - logPriceMinOffsetted
 1065 |     |       //  'shares * ---------------------------------------------'
 1066 |     |       //                               qSpacing
 1067 |     |       mul(
 1068 |     |         // 'qSpacing' is non-zero. Hence, division is safe.
 1069 |     |         div(sub(logPriceMaxOffsetted, logPriceMinOffsetted), qSpacing),
 1070 |     |         shares
 1071 |     |       )
 1072 |     |     )
 1073 |     |     sstore(storageSlot, sharesGross)
 1074 |     |   }
 1075 |     | 
 1076 |     |   require(sharesGross <= type(int128).max, SharesGrossOverflow(sharesGross));
 1077 |     | }
 1078 |     | 
 1079 |     | //////////////////////////////////////////////////////////// Dynamic parameters
 1080 |     | 
 1081 |     | // uint128(uint256(keccak256("dynamicParams"))) - 1
 1082 |     | uint128 constant dynamicParamsSlot = 0x6890D047AD8C870137858A70716B2C6B;
 1083 |     | 
 1084 |     | /// @notice This function returns the storage slot hosting the dynamic
 1085 |     | /// parameters of a pool.
 1086 |     | ///
 1087 |     | /// @param poolId The 'poolId' whose owner slot to be derived.
 1088 |     | /// @return storageSlot The storage slot containing the pool owner.
 1089 |     | function getDynamicParamsSlot(
 1090 |     |   uint256 poolId
 1091 |     | ) pure returns (
 1092 |     |   uint256 storageSlot
 1093 |     | ) {
 1094 |     |   assembly {
 1095 |     |     // We populate the first two memory slots from right to left:
 1096 |     |     //
 1097 |     |     //    0                32                  48
 1098 |     |     //    |                |                   |
 1099 |     |     //    +----------------+-------------------+
 1100 |     |     //    |     poolId     | dynamicParamsSlot |
 1101 |     |     //    +----------------+-------------------+
 1102 |     |     //
 1103 |     |     mstore(16, dynamicParamsSlot)
 1104 |     |     mstore(0, poolId)
 1105 |     |     storageSlot := keccak256(0, 48)
 1106 |     |   }
 1107 |     | }
 1108 |     | 
 1109 |     | /// @notice This function reads pool's dynamic parameters from storage and sets
 1110 |     | /// them in appropriate memory locations.
 1111 |     | function readDynamicParams() view {
 1112 |     |   // The storage slot hosting the dynamic parameters of the pool is derived.
 1113 |     |   uint256 storageSlot = getDynamicParamsSlot(getPoolId());
 1114 |     | 
 1115 |     |   // Dynamic parameters are read from storage and stored in memory.
 1116 |     |   assembly {
 1117 |     |     mstore(add(_dynamicParams_, 32), sload(storageSlot))
 1118 |     |     mstore(add(_dynamicParams_, 64), sload(add(storageSlot, 1)))
 1119 |     |     mstore(add(_dynamicParams_, 96), sload(add(storageSlot, 2)))
 1120 |     |   }
 1121 |     | 
 1122 |     |   // For an existing pool, 'growth' is always greater than or equal to
 1123 |     |   // 'oneX111'. Hence, 'getGrowth() == zeroX111' indicates that the pool does
 1124 |     |   // not exist.
 1125 |     |   require(getGrowth() != zeroX111, PoolDoesNotExist(getPoolId()));
 1126 |     | 
 1127 |     |   // 'staticParamsStoragePointer == type(uint16).max' indicates that the
 1128 |     |   // storage pointer for static parameters has overflowed and the storage slot
 1129 |     |   // for 'staticParamsStoragePointerExtension' needs to be read.
 1130 |     |   uint16 staticParamsStoragePointer = getStaticParamsStoragePointer();
 1131 |     |   if (staticParamsStoragePointer == type(uint16).max) {
 1132 |     |     assembly {
 1133 |     |       mstore(_dynamicParams_, sload(sub(storageSlot, 1)))
 1134 |     |     } 
 1135 |     |   } else {
 1136 |     |     setStaticParamsStoragePointerExtension(
 1137 |     |       uint256(staticParamsStoragePointer)
 1138 |     |     );
 1139 |     |   }
 1140 |     | }
 1141 |     | 
 1142 |     | /// @notice This function loads pool's dynamic parameters from the memory and
 1143 |     | /// writes them on storage.
 1144 |     | function writeDynamicParams() {
 1145 |     |   // The storage slot hosting the dynamic parameters of the pool is derived.
 1146 |     |   uint256 storageSlot = getDynamicParamsSlot(getPoolId());
 1147 |     | 
 1148 |     |   // 'staticParamsStoragePointer >= type(uint16).max' indicates that the
 1149 |     |   // storage pointer for static parameters has overflowed and the storage slot
 1150 |     |   // for 'staticParamsStoragePointerExtension' needs to be used.
 1151 |     |   if (getStaticParamsStoragePointerExtension() >= type(uint16).max) {
 1152 |     |     assembly {
 1153 |     |       sstore(sub(storageSlot, 1), mload(_dynamicParams_))
 1154 |     |     }
 1155 |     |     setStaticParamsStoragePointer(type(uint16).max);
 1156 |     |   } else {
 1157 |     |     setStaticParamsStoragePointer(
 1158 |     |       uint16(getStaticParamsStoragePointerExtension())
 1159 |     |     );
 1160 |     |   }
 1161 |     | 
 1162 |     |   // Next, the dynamic parameters are loaded from the memory and written on 
 1163 |     |   // storage.
 1164 |     |   assembly {
 1165 |     |     sstore(storageSlot, mload(add(_dynamicParams_, 32)))
 1166 |     |     sstore(add(storageSlot, 1), mload(add(_dynamicParams_, 64)))
 1167 |     |     sstore(add(storageSlot, 2), mload(add(_dynamicParams_, 96)))
 1168 |     |   }
 1169 |     | }
 1170 |     | 
 1171 |     | /////////////////////////////////////////////////////////////////// Curve slots
 1172 |     | 
 1173 |     | // uint128(uint256(keccak256("curve"))) - 1
 1174 |     | uint128 constant curveSlot = 0x3B2D91718DFB37F9969A1B0670A83E70;
 1175 |     | 
 1176 |     | /// @notice This function returns the storage slot hosting the curve sequence
 1177 |     | /// of a pool.
 1178 |     | ///
 1179 |     | /// @param poolId The 'poolId' whose owner slot to be derived.
 1180 |     | /// @return storageSlot The storage slot containing the pool owner.
 1181 |     | function getCurveSlot(
 1182 |     |   uint256 poolId
 1183 |     | ) pure returns (
 1184 |     |   uint256 storageSlot
 1185 |     | ) {
 1186 |     |   assembly {
 1187 |     |     // We populate the first two memory slots from right to left:
 1188 |     |     //
 1189 |     |     //    0                32                  48
 1190 |     |     //    |                |                   |
 1191 |     |     //    +----------------+-------------------+
 1192 |     |     //    |     poolId     |     curveSlot     |
 1193 |     |     //    +----------------+-------------------+
 1194 |     |     //
 1195 |     |     mstore(16, curveSlot)
 1196 |     |     mstore(0, poolId)
 1197 |     |     storageSlot := keccak256(0, 48)
 1198 |     |   }
 1199 |     | }
 1200 |     | 
 1201 |     | /// @notice Reads 'qLower' and 'qUpper' boundaries of the current interval from
 1202 |     | /// storage.
 1203 |     | ///
 1204 |     | /// @return qLower The left boundary of the active liquidity interval
 1205 |     | /// @return qUpper The right boundary of the active liquidity interval
 1206 |     | function readBoundaries() view returns (
 1207 |     |   X59 qLower,
 1208 |     |   X59 qUpper
 1209 |     | ) {
 1210 |     |   // Reads the first slot of the curve sequence from storage.
 1211 |     |   uint256 firstSlot = readStorage(getCurveSlot(getPoolId()));
 1212 |     |   
 1213 |     |   Curve curve = getCurve();
 1214 |     |   setCurveLength(twoIndex);
 1215 |     |   
 1216 |     |   assembly {
 1217 |     |     mstore(curve, firstSlot)
 1218 |     |   }
 1219 |     |   
 1220 |     |   qLower = curve.member(zeroIndex);
 1221 |     |   qUpper = curve.member(oneIndex);
 1222 |     |   (qLower, qUpper) = qLower < qUpper ? (qLower, qUpper) : (qUpper, qLower);
 1223 |     | }
 1224 |     | 
 1225 |     | /// @notice Reads the entire curve from storage and stores it in memory.
 1226 |     | function readCurve() view returns (Index curveLength) {
 1227 |     |   // Reads the first slot of the curve sequence from storage.
 1228 |     |   uint256 storageSlot = getCurveSlot(getPoolId());
 1229 |     | 
 1230 |     |   // The memory pointer referring to the first member of the curve sequence is
 1231 |     |   // loaded from the memory.
 1232 |     |   Curve memoryPointer = getCurve();
 1233 |     | 
 1234 |     |   // Let 'l' denote the number of members in the curve sequence. Since, we
 1235 |     |   // already know 'qCurrent' from dynamic parameters, we can determine 'l'
 1236 |     |   // without having to load an entire length slot! In other words, we keep
 1237 |     |   // reading members of the curve sequence from protocol's storage (four
 1238 |     |   // members per slot) until we encounter 'qCurrent' which is already known
 1239 |     |   // from dynamic parameters. Then, 'l' can be determined based on the position
 1240 |     |   // of 'qCurrent' in the curve sequence.
 1241 |     |   X59 qCurrent = getLogPriceCurrent();
 1242 |     | 
 1243 |     |   assembly {
 1244 |     |     let value
 1245 |     | 
 1246 |     |     // The loop is broken whenever we encounter 'qCurrent'.
 1247 |     |     for {} 0x1 {} {
 1248 |     |       value := sload(storageSlot)
 1249 |     | 
 1250 |     |       // Examines if the most significant 64 bits are equal to 'qCurrent'.
 1251 |     |       let member := shr(192, value)
 1252 |     |       if eq(member, qCurrent) {
 1253 |     |         curveLength := add(curveLength, 1)
 1254 |     |         value := shl(192, member)
 1255 |     |         break
 1256 |     |       }
 1257 |     | 
 1258 |     |       // Examines if the second most significant 64 bits are equal to
 1259 |     |       // 'qCurrent'.
 1260 |     |       member := shr(128, value)
 1261 |     |       if eq(and(member, 0xFFFFFFFFFFFFFFFF), qCurrent) {
 1262 |     |         curveLength := add(curveLength, 2)
 1263 |     |         value := shl(128, member)
 1264 |     |         break
 1265 |     |       }
 1266 |     | 
 1267 |     |       // Examines if the third most significant 64 bits are equal to
 1268 |     |       // 'qCurrent'.
 1269 |     |       member := shr(64, value)
 1270 |     |       if eq(and(member, 0xFFFFFFFFFFFFFFFF), qCurrent) {
 1271 |     |         curveLength := add(curveLength, 3)
 1272 |     |         value := shl(64, member)
 1273 |     |         break
 1274 |     |       }
 1275 |     | 
 1276 |     |       curveLength := add(curveLength, 4)
 1277 |     | 
 1278 |     |       // Examines if the least significant 64 bits are equal to
 1279 |     |       // 'qCurrent'.
 1280 |     |       if eq(and(value, 0xFFFFFFFFFFFFFFFF), qCurrent) {
 1281 |     |         break
 1282 |     |       }
 1283 |     | 
 1284 |     |       // 'value' is stored in memory.
 1285 |     |       mstore(memoryPointer, value)
 1286 |     | 
 1287 |     |       // 'storageSlot' is incremented.
 1288 |     |       storageSlot := add(storageSlot, 1)
 1289 |     | 
 1290 |     |       // 'memoryPointer' is incremented by 32 bytes.
 1291 |     |       memoryPointer := add(memoryPointer, 32)
 1292 |     |     }
 1293 |     | 
 1294 |     |     // 'value' is stored in memory.
 1295 |     |     mstore(memoryPointer, value)
 1296 |     |   }
 1297 |     | }
 1298 |     | 
 1299 |     | /// @notice Writes the current curve sequence on storage.
 1300 |     | function writeCurve() {
 1301 |     |   // Reads the first slot of the curve sequence from storage.
 1302 |     |   uint256 storageSlot = getCurveSlot(getPoolId());
 1303 |     | 
 1304 |     |   // The memory pointer referring to the first member of the curve sequence is
 1305 |     |   // loaded from the memory.
 1306 |     |   Curve memoryPointer = getCurve();
 1307 |     | 
 1308 |     |   // The length of the current curve squence in memory is loaded.
 1309 |     |   Index curveLength = getCurveLength();
 1310 |     | 
 1311 |     |   assembly {
 1312 |     |     // The last storage slot for the curve sequence is read derived.
 1313 |     |     let finalSlot := add(storageSlot, shr(2, sub(curveLength, 1)))
 1314 |     | 
 1315 |     |     // The first slot of the curve sequence is loaded from memory and written
 1316 |     |     // on storage.
 1317 |     |     sstore(storageSlot, mload(memoryPointer))
 1318 |     | 
 1319 |     |     // This loop continues until we encounter 'finalSlot'.
 1320 |     |     for {} lt(storageSlot, finalSlot) {} {
 1321 |     |       // 'storageSlot' is incremented.
 1322 |     |       storageSlot := add(storageSlot, 1)
 1323 |     | 
 1324 |     |       // 'memoryPointer' is incremented by 32 bytes.
 1325 |     |       memoryPointer := add(memoryPointer, 32)
 1326 |     | 
 1327 |     |       // The slot of the curve sequence which is pointed to by 'memoryPointer'
 1328 |     |       // is loaded from the memory and is written on storage.
 1329 |     |       sstore(storageSlot, mload(memoryPointer))
 1330 |     |     }
 1331 |     |   }
 1332 |     | }
 1333 |     | 
 1334 |     | ////////////////////////////////////////// Static parameters and kernel storage
 1335 |     | 
 1336 |     | /// @notice This function deploys a storage contract whose bytecode contains
 1337 |     | /// the pool's static parameters.
 1338 |     | ///
 1339 |     | /// @param storagePointer The pointer which is used to derive the address of
 1340 |     | /// the storage smart contract.
 1341 |     | function writeStaticParams(uint256 storagePointer) {
 1342 |     |   uint256 poolId = getPoolId();
 1343 |     |   address proxy;
 1344 |     |   assembly {
 1345 |     |     // The 32-byte storage pointer is derived by hashing the following 64
 1346 |     |     // bytes:
 1347 |     |     mstore(0, poolId)
 1348 |     |     mstore(32, storagePointer)
 1349 |     |     storagePointer := keccak256(0, 64)
 1350 |     | 
 1351 |     |     // Static parameters are stored in a 'storage contract' which is deployed
 1352 |     |     // by a disposable 'proxy contract'. First the 'proxy contract' is
 1353 |     |     // deployed.
 1354 |     |     mstore(0x00, PROXY_CREATION_CODE)
 1355 |     |     proxy := create2(0, 0x10, 0x10, storagePointer)
 1356 |     |   }
 1357 |     | 
 1358 |     |   require(proxy != address(0), DeploymentFailed());
 1359 |     | 
 1360 |     |   // The total number of bytes to be written.
 1361 |     |   Index length = getKernelLength();
 1362 |     |   uint256 deploymentCreationCode;
 1363 |     |   assembly {
 1364 |     |     length := add(
 1365 |     |       sub(_endOfStaticParams_, _staticParams_), // Length of static parameters.
 1366 |     |       shl(6, sub(length, 1)) // Length of kernel.
 1367 |     |     )
 1368 |     |     // '1' is added to include the '00' padding bytes. Due the '1019' limit on
 1369 |     |     // the size of kernel, the addition is always safe.
 1370 |     |     deploymentCreationCode := or(DEPLOYMENT_CODE, shl(64, add(length, 1)))
 1371 |     |   }
 1372 |     |   setDeploymentCreationCode(deploymentCreationCode);
 1373 |     | 
 1374 |     |   // Data is written from memory to a new contract via the proxy.
 1375 |     |   bool success;
 1376 |     |   assembly {
 1377 |     |     success := call(
 1378 |     |       gas(),
 1379 |     |       proxy,
 1380 |     |       0,
 1381 |     |       _deploymentCreationCode_,
 1382 |     |       add(length, 11), // Because 'DEPLOYMENT_CODE' is 11 bytes.
 1383 |     |       0,
 1384 |     |       0
 1385 |     |     )
 1386 |     |   }
 1387 |     | 
 1388 |     |   require(success, DeploymentFailed());
 1389 |     | }
 1390 |     | 
 1391 |     | /// @notice This function calculates the address of the storage contract
 1392 |     | /// containing static parameters and kernel.
 1393 |     | ///
 1394 |     | /// @param storagePointer The pointer which is used to derive the address of
 1395 |     | /// the storage smart contract.
 1396 |     | /// @return storageAddress The address of the storage contract whose bytecode
 1397 |     | /// comprises static parameters and kernel.
 1398 |     | function getStaticParamsStorageAddress(
 1399 |     |   uint256 storagePointer
 1400 |     | ) view returns (
 1401 |     |   address storageAddress
 1402 |     | ) {
 1403 |     |   address nofeeswap;
 1404 |     |   assembly {
 1405 |     |     nofeeswap := address()
 1406 |     |   }
 1407 |     |   return getStaticParamsStorageAddress(
 1408 |     |     nofeeswap,
 1409 |     |     getPoolId(),
 1410 |     |     storagePointer
 1411 |     |   );
 1412 |     | }
 1413 |     | 
 1414 |     | /// @notice This function calculates the address of the storage contract
 1415 |     | /// containing static parameters and kernel.
 1416 |     | ///
 1417 |     | /// @param nofeeswap The protocol's address.
 1418 |     | /// @param poolId The corresponding 'poolId'.
 1419 |     | /// @param storagePointer The pointer which is used to derive the address of
 1420 |     | /// the storage smart contract.
 1421 |     | /// @return storageAddress The address of the storage contract whose bytecode
 1422 |     | /// comprises static parameters and kernel.
 1423 |     | function getStaticParamsStorageAddress(
 1424 |     |   address nofeeswap,
 1425 |     |   uint256 poolId,
 1426 |     |   uint256 storagePointer
 1427 |     | ) pure returns (
 1428 |     |   address storageAddress
 1429 |     | ) {
 1430 |     |   assembly {
 1431 |     |     // The 32-byte storage pointer is derived by hashing the following 64:
 1432 |     |     mstore(0, poolId)
 1433 |     |     mstore(32, storagePointer)
 1434 |     |     storagePointer := keccak256(0, 64)
 1435 |     | 
 1436 |     |     // Fetch free memory pointer so that we can use '0x40' as scratch space.
 1437 |     |     let freeMemoryPointer := mload(0x40)
 1438 |     | 
 1439 |     |     // Pool static parameters are stored in a 'storage contract' which is 
 1440 |     |     // deployed by a 'proxy contract'. First the 'proxy contract' address is
 1441 |     |     // derived.
 1442 |     |     // 'nofeeswap' address is written in first memory slot along with a '0xff'
 1443 |     |     // prefix. The storage pointer and 'PROXY_CREATION_HASH' are written in
 1444 |     |     // the second and third memory slots, respectively.
 1445 |     |     mstore(0x00, nofeeswap)
 1446 |     |     mstore8(0x0b, 0xff)
 1447 |     |     mstore(0x20, storagePointer)
 1448 |     |     mstore(0x40, PROXY_CREATION_HASH)
 1449 |     | 
 1450 |     |     // This 85 byte hash gives the 'proxy contract' address.
 1451 |     |     mstore(0x14, keccak256(0x0b, 0x55))
 1452 |     | 
 1453 |     |     // Restores 'freeMemoryPointer'.
 1454 |     |     mstore(0x40, freeMemoryPointer)
 1455 |     | 
 1456 |     |     // 0xd6 = 0xc0 (short RLP prefix) + 0x16 (length of 0x94 ++ proxy ++ 0x01)
 1457 |     |     // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex)
 1458 |     |     mstore(0x00, 0xd694)
 1459 |     |     mstore8(0x34, 0x01)
 1460 |     | 
 1461 |     |     // Gives the 'storage contract' address.
 1462 |     |     storageAddress := and(keccak256(0x1e, 0x17), shr(96, not(0)))
 1463 |     |   }
 1464 |     | }
 1465 |     | 
 1466 |     | /// @notice This function reads pool's static parameters from storageAddress 
 1467 |     | /// and sets them in appropriate memory locations:
 1468 |     | ///
 1469 |     | /// @param storageAddress The address of the storage contract whose bytecode
 1470 |     | /// comprises static parameters and kernel.
 1471 |     | function readStaticParams(
 1472 |     |   address storageAddress
 1473 |     | ) view {
 1474 |     |   assembly {
 1475 |     |     extcodecopy(
 1476 |     |       storageAddress,
 1477 |     |       _staticParams_,
 1478 |     |       1,
 1479 |     |       sub(_endOfStaticParams_, _staticParams_)
 1480 |     |     )
 1481 |     |   }
 1482 |     | }
 1483 |     | 
 1484 |     | /// @notice This function reads pool's static parameters and kernel, and sets
 1485 |     | /// them in appropriate memory locations.
 1486 |     | ///
 1487 |     | /// @param storageAddress The address of the storage contract whose bytecode
 1488 |     | /// comprises static parameters and kernel.
 1489 |     | function readStaticParamsAndKernel(
 1490 |     |   address storageAddress
 1491 |     | ) view {
 1492 |     |   readStaticParams(storageAddress);
 1493 |     |   Index kernelLength = readKernelLength(storageAddress);
 1494 |     |   setKernelLength(kernelLength);
 1495 |     |   readKernel(getKernel(), storageAddress, kernelLength);
 1496 |     | }
 1497 |     | 
 1498 |     | /// @notice This function reads kernel length.
 1499 |     | ///
 1500 |     | /// @param storageAddress The address of the storage contract whose bytecode
 1501 |     | /// comprises static parameters and kernel.
 1502 |     | /// @return length The number of kernel breakpoints.
 1503 |     | function readKernelLength(
 1504 |     |   address storageAddress
 1505 |     | ) view returns (
 1506 |     |   Index length
 1507 |     | ) {
 1508 |     |   assembly {
 1509 |     |     // The total number of bytes to be loaded.
 1510 |     |     // Each breakpoint of the kernel is 64 bytes. The first breakpoint is 
 1511 |     |     // omitted.
 1512 |     |     length := add(
 1513 |     |       shr(
 1514 |     |         6,
 1515 |     |         sub(
 1516 |     |           sub(extcodesize(storageAddress), 1),
 1517 |     |           sub(_endOfStaticParams_, _staticParams_)
 1518 |     |         )
 1519 |     |       ),
 1520 |     |       1
 1521 |     |     )
 1522 |     |   }
 1523 |     | }
 1524 |     | 
 1525 |     | /// @notice This function reads kernel from storageAddress and sets it in
 1526 |     | /// the appropriate memory location.
 1527 |     | ///
 1528 |     | /// @param kernel The memory pointer referring to the memory space which hosts
 1529 |     | /// the list of kernel breakpoints.
 1530 |     | /// @param storageAddress The address of the storage contract whose bytecode
 1531 |     | /// comprises static parameters and kernel.
 1532 |     | /// @param length The number of kernel breakpoints.
 1533 |     | function readKernel(
 1534 |     |   Kernel kernel,
 1535 |     |   address storageAddress,
 1536 |     |   Index length
 1537 |     | ) view {
 1538 |     |   assembly {
 1539 |     |     // Data is loaded from the 'storageAddress' to memory.
 1540 |     |     extcodecopy(
 1541 |     |       storageAddress,
 1542 |     |       kernel,
 1543 |     |       add(1, sub(_endOfStaticParams_, _staticParams_)),
 1544 |     |       shl(6, sub(length, 1))
 1545 |     |     )
 1546 |     |   }
 1547 |     | }
 1548 |     | 
 1549 |     | /// @notice Reads pool data and sets it in the appropriate memory location.
 1550 |     | function readPoolData() view {
 1551 |     |   readDynamicParams();
 1552 |     | 
 1553 |     |   // The address of the storage contract whose bytecode comprises static
 1554 |     |   // parameters and kernel.
 1555 |     |   address storageAddress = getStaticParamsStorageAddress(
 1556 |     |     getStaticParamsStoragePointerExtension()
 1557 |     |   );
 1558 |     | 
 1559 |     |   // Static paremters are read from the storage contract.
 1560 |     |   readStaticParams(storageAddress);
 1561 |     | 
 1562 |     |   // 'poolGrowthPortion' is capped by 'maxPoolGrowthPortion'.
 1563 |     |   setPoolGrowthPortion(
 1564 |     |     min(getPoolGrowthPortion(), getMaxPoolGrowthPortion())
 1565 |     |   );
 1566 |     | 
 1567 |     |   // The length of the kernel is determined.
 1568 |     |   Index length = readKernelLength(storageAddress);
 1569 |     |   setKernelLength(length);
 1570 |     | 
 1571 |     |   // Kernel breakpoints are read from the storage contract and stored in
 1572 |     |   // memory.
 1573 |     |   Kernel kernel = getKernel();
 1574 |     |   readKernel(kernel, storageAddress, length);
 1575 |     | 
 1576 |     |   // If needed, additional space is reserved in memory for the pending kernel.
 1577 |     |   length = max(length, getPendingKernelLength());
 1578 |     | 
 1579 |     |   // The memory pointer for the curve sequence is derived.
 1580 |     |   Curve curve;
 1581 |     |   assembly {
 1582 |     |     curve := add(kernel, shl(6, sub(length, 1)))
 1583 |     |   }
 1584 |     |   setCurve(curve);
 1585 |     | 
 1586 |     |   // The curve sequence is read from storage and placed in memory.
 1587 |     |   length = readCurve();
 1588 |     |   setCurveLength(length);
 1589 |     | 
 1590 |     |   // The free memory pointer is set next.
 1591 |     |   uint256 freeMemoryPointer;
 1592 |     |   assembly {
 1593 |     |     freeMemoryPointer := add(
 1594 |     |       curve,
 1595 |     |       shl(5, add(shr(2, sub(length, 1)), 2))
 1596 |     |     )
 1597 |     |   }
 1598 |     |   setFreeMemoryPointer(freeMemoryPointer);
 1599 |     | 
 1600 |     |   // The byte count for the memory snapshot given to the hook contract is
 1601 |     |   // derived next.
 1602 |     |   uint256 hookInputByteCount;
 1603 |     |   assembly {
 1604 |     |     hookInputByteCount := 
 1605 |     |       sub(sub(freeMemoryPointer, _hookInputByteCount_), 32)
 1606 |     |   }
 1607 |     |   setHookInputByteCount(hookInputByteCount);
 1608 |     | }
 1609 |     | 
 1610 |     | // Modified from Philogy 
 1611 |     | // <https://github.com/Philogy/sstore3/blob/main/src/SSTORE3_L.sol>
 1612 |     | // Modified from Solady 
 1613 |     | // <https://github.com/Vectorized/solady/blob/main/src/utils/CREATE3.sol>
 1614 |     | 
 1615 |     | // The proxy bytecode.
 1616 |     | uint256 constant PROXY_CREATION_CODE = 0x67363D3D37363D3DF03D5260086018F3;
 1617 |     | // 'keccak256(PROXY_CREATION_CODE)'.
 1618 |     | bytes32 constant PROXY_CREATION_HASH = 
 1619 |     |   0xF779EDCBDC615C777A4CB2BEE1BF733055AA41FF7247837D0CD548565F65D034;
 1620 |     | // -------------------------------------------------------------------+
 1621 |     | // Opcode      | Mnemonic         | Stack        | Memory             |
 1622 |     | // -------------------------------------------------------------------|
 1623 |     | // 36          | CALLDATASIZE     | cds          |                    |
 1624 |     | // 3d          | RETURNDATASIZE   | 0 cds        |                    |
 1625 |     | // 3d          | RETURNDATASIZE   | 0 0 cds      |                    |
 1626 |     | // 37          | CALLDATACOPY     |              | [0..cds): calldata |
 1627 |     | // 36          | CALLDATASIZE     | cds          | [0..cds): calldata |
 1628 |     | // 3d          | RETURNDATASIZE   | 0 cds        | [0..cds): calldata |
 1629 |     | // 3d          | RETURNDATASIZE   | 0 0 cds      | [0..cds): calldata |
 1630 |     | // f0          | CREATE           | newContract  | [0..cds): calldata |
 1631 |     | // -------------------------------------------------------------------|
 1632 |     | // Opcode      | Mnemonic         | Stack        | Memory             |
 1633 |     | // -------------------------------------------------------------------|
 1634 |     | // 67 bytecode | PUSH8 bytecode   | bytecode     |                    |
 1635 |     | // 3d          | RETURNDATASIZE   | 0 bytecode   |                    |
 1636 |     | // 52          | MSTORE           |              | [0..8): bytecode   |
 1637 |     | // 60 0x08     | PUSH1 0x08       | 0x08         | [0..8): bytecode   |
 1638 |     | // 60 0x18     | PUSH1 0x18       | 0x18 0x08    | [0..8): bytecode   |
 1639 |     | // f3          | RETURN           |              | [0..8): bytecode   |
 1640 |     | // -------------------------------------------------------------------+
 1641 |     | 
 1642 |     | 
 1643 |     | uint256 constant DEPLOYMENT_CODE = 0x61000080600a3d393df300;
 1644 |     | // ------------------------------------------------------------------------+
 1645 |     | //                                                                         |
 1646 |     | // STORE DEPLOY START (11 bytes)                                           |
 1647 |     | //                                                                         |
 1648 |     | // ----+------------+------------------+--------------+--------------------+
 1649 |     | // PC  | Opcode     | Mnemonic         | Stack        | Memory             |
 1650 |     | // ----+------------+------------------+--------------+--------------------+
 1651 |     | //                                                                         |
 1652 |     | // ::::::::::: Deploy code (10 bytes). ::::::::::::::::::::::::::::::::::: |
 1653 |     | // 0x0 | 61 ????    | PUSH2 length     | len          | -                  |
 1654 |     | // 0x3 | 80         | DUP1             | len len      | -                  |
 1655 |     | // 0x4 | 60 0a      | PUSH1 0x0a       | 10 len len   | -                  |
 1656 |     | // 0x6 | 3d         | RETURNDATASIZE   | 0 10 len len | [0..len): runtime  |
 1657 |     | // 0x7 | 39         | CODECOPY         | len          | [24..32): runtime  |
 1658 |     | // 0x8 | 3d         | RETURNDATASIZE   | 0 len        | [24..32): runtime  |
 1659 |     | // 0x9 | f3         | RETURN           |              | [24..32): runtime  |
 1660 |     | //                                                                         |
 1661 |     | // ::::::::::: Padding (1 byte). ::::::::::::::::::::::::::::::::::::::::: |
 1662 |     | // 0x0 | 00         | STOP             |              | [24..32): runtime  |
 1663 |     | // ----+------------+------------------+--------------+--------------------+

R:/LIAT.AI/question2-calldata/contracts/utilities/Tag.sol
   1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
   2 |     | pragma solidity ^0.8.28;
   3 |     | 
   4 |     | import {X59} from "./X59.sol";
   5 |     | 
   6 |     | // Type 'Tag' may refer to any of the followings:
   7 |     | //
   8 |     | // - Native token corresponding to 'Tag.wrap(0)'.
   9 |     | //
  10 |     | // - An ERC-20 address, i.e., 'Tag.wrap(uint256(uint160(tokenAddress)))'.
  11 |     | //
  12 |     | // - An ERC-1155 token whose value is determined by hashing token address and
  13 |     | // token ID, i.e., 
  14 |     | // 'Tag.wrap(uint256(keccak256(abi.encodePacked(tokenAddress, tokenId))))'.
  15 |     | //
  16 |     | // - An ERC-6909 token whose value is determined by hashing token address and
  17 |     | // token ID, i.e., 
  18 |     | // 'Tag.wrap(uint256(keccak256(abi.encodePacked(tokenAddress, tokenId))))'.
  19 |     | //
  20 |     | // - A nofeeswap position whose value is determined by hashing, poolId and
  21 |     | // min/max position boundaries, i.e., 
  22 |     | // 'Tag.wrap(uint256(keccak256(abi.encodePacked(
  23 |     | //    poolId,
  24 |     | //    qMin,
  25 |     | //    qMax
  26 |     | //  ))))'.
  27 |     | //
  28 |     | type Tag is uint256;
  29 |     | 
  30 |     | Tag constant native = Tag.wrap(0);
  31 |     | 
  32 |     | using {equals as ==, notEqual as !=} for Tag global;
  33 |     | using {lessThan as <, greaterThan as >} for Tag global;
  34 |     | using {
  35 |     |   lessThanOrEqualTo as <=,
  36 |     |   greaterThanOrEqualTo as >=
  37 |     | } for Tag global;
  38 |     | 
  39 |     | function equals(
  40 |     |   Tag value0,
  41 |     |   Tag value1
  42 |     | ) pure returns (
  43 |     |   bool result
  44 |     | ) {
  45 |     |   assembly {
  46 |     |     result := eq(value0, value1)
  47 |     |   }
  48 |     | }
  49 |     | 
  50 |     | function notEqual(
  51 |     |   Tag value0,
  52 |     |   Tag value1
  53 |     | ) pure returns (
  54 |     |   bool result
  55 |     | ) {
  56 |     |   return !(value0 == value1);
  57 |     | }
  58 |     | 
  59 |     | function lessThan(
  60 |     |   Tag value0,
  61 |     |   Tag value1
  62 |     | ) pure returns (
  63 |     |   bool result
  64 |     | ) {
  65 |     |   assembly {
  66 |     |     result := lt(value0, value1)
  67 |     |   }
  68 |     | }
  69 |     | 
  70 |     | function greaterThan(
  71 |     |   Tag value0,
  72 |     |   Tag value1
  73 |     | ) pure returns (
  74 |     |   bool result
  75 |     | ) {
  76 |     |   assembly {
  77 |     |     result := gt(value0, value1)
  78 |     |   }
  79 |     | }
  80 |     | 
  81 |     | function lessThanOrEqualTo(
  82 |     |   Tag value0,
  83 |     |   Tag value1
  84 |     | ) pure returns (
  85 |     |   bool result
  86 |     | ) {
  87 |     |   return !(value0 > value1);
  88 |     | }
  89 |     | 
  90 |     | function greaterThanOrEqualTo(
  91 |     |   Tag value0,
  92 |     |   Tag value1
  93 |     | ) pure returns (
  94 |     |   bool result
  95 |     | ) {
  96 |     |   return !(value0 < value1);
  97 |     | }
  98 |     | 
  99 |     | library TagLibrary {
 100 |     |   /// @notice Generates a tag given an ERC-20 address.
 101 |     |   /// @param tokenAddress The given ERC-20 address to be transformed to the
 102 |     |   /// type 'tag'.
 103 |     |   function tag(
 104 |     |     address tokenAddress
 105 |     |   ) internal pure returns (
 106 |     |     Tag tokenTag
 107 |     |   ) {
 108 |     |     assembly {
 109 |     |       tokenTag := and(tokenAddress, sub(shl(160, 1), 1))
 110 |     |     }
 111 |     |   }
 112 |     | 
 113 |     |   /// @notice Generates a tag given a multi-token address and tokenId.
 114 |     |   /// @param tokenAddress The given multi-token address to be transformed to
 115 |     |   /// the type 'tag'.
 116 |     |   /// @param tokenId The given multi-token id to be used to generate 'tag'.
 117 |     |   function tag(
 118 |     |     address tokenAddress,
 119 |     |     uint256 tokenId
 120 |     |   ) internal pure returns (
 121 |     |     Tag tokenTag
 122 |     |   ) {
 123 |     |     assembly {
 124 |     |       mstore(20, tokenAddress)
 125 |     |       mstore(0, tokenId)
 126 |     |       tokenTag := keccak256(0, 52)
 127 |     |     }
 128 |     |   }
 129 |     | 
 130 |     |   /// @notice Generates a tag given a nofeeswap liquidity position.
 131 |     |   /// @param poolId The pool identifier hosting this liquidity position.
 132 |     |   /// @param qMin Equal to '(2 ** 59) * log(pMin)' where 'pMin' is the left
 133 |     |   /// position boundary.
 134 |     |   /// @param qMax Equal to '(2 ** 59) * log(pMax)' where 'pMax' is the right
 135 |     |   /// position boundary.
 136 |     |   function tag(
 137 |     |     uint256 poolId,
 138 |     |     X59 qMin,
 139 |     |     X59 qMax
 140 |     |   ) internal pure returns (
 141 |     |     Tag positionTag
 142 |     |   ) {
 143 |     |     assembly {
 144 |     |       // Cache the free memory pointer so that the third memory slot can be
 145 |     |       // used for hashing.
 146 |     |       let freeMemoryPointer := mload(0x40)
 147 |     |       mstore(64, qMax)
 148 |     |       mstore(32, qMin)
 149 |     |       mstore(0, poolId)
 150 |     |       positionTag := keccak256(0, 96)
 151 |     |       // The 'freeMemoryPointer' is restored.
 152 |     |       mstore(0x40, freeMemoryPointer)
 153 |     |     }
 154 |     |   }
 155 |     | }

R:/LIAT.AI/question2-calldata/contracts/utilities/X111.sol
   1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
   2 |     | pragma solidity ^0.8.28;
   3 |     | 
   4 |     | import {X208} from "./X208.sol";
   5 |     | import {X216} from "./X216.sol";
   6 |     | import {FullMathLibrary} from "./FullMath.sol";
   7 |     | 
   8 |     | // Type 'X111' is dedicated to growth and liquidity values.
   9 |     | type X111 is int256;
  10 |     | 
  11 |     | using X111Library for X111 global;
  12 |     | 
  13 |     | X111 constant zeroX111 = X111.wrap(0);
  14 |     | X111 constant oneX111 = X111.wrap(1 << 111);
  15 |     | X111 constant maxGrowth = X111.wrap(1 << 127);
  16 |     | 
  17 |     | using {equals as ==, notEqual as !=} for X111 global;
  18 |     | using {lessThan as <, greaterThan as >} for X111 global;
  19 |     | using {
  20 |     |   lessThanOrEqualTo as <=,
  21 |     |   greaterThanOrEqualTo as >=
  22 |     | } for X111 global;
  23 |     | using {add as +, sub as -} for X111 global;
  24 |     | 
  25 |     | function equals(
  26 |     |   X111 value0,
  27 |     |   X111 value1
  28 |     | ) pure returns (
  29 |     |   bool result
  30 |     | ) {
  31 |     |   assembly {
  32 |     |     result := eq(value0, value1)
  33 |     |   }
  34 |     | }
  35 |     | 
  36 |     | function notEqual(
  37 |     |   X111 value0,
  38 |     |   X111 value1
  39 |     | ) pure returns (
  40 |     |   bool result
  41 |     | ) {
  42 |     |   return !(value0 == value1);
  43 |     | }
  44 |     | 
  45 |     | function lessThan(
  46 |     |   X111 value0,
  47 |     |   X111 value1
  48 |     | ) pure returns (
  49 |     |   bool result
  50 |     | ) {
  51 |     |   assembly {
  52 |     |     result := slt(value0, value1)
  53 |     |   }
  54 |     | }
  55 |     | 
  56 |     | function greaterThan(
  57 |     |   X111 value0,
  58 |     |   X111 value1
  59 |     | ) pure returns (
  60 |     |   bool result
  61 |     | ) {
  62 |     |   assembly {
  63 |     |     result := sgt(value0, value1)
  64 |     |   }
  65 |     | }
  66 |     | 
  67 |     | function lessThanOrEqualTo(
  68 |     |   X111 value0,
  69 |     |   X111 value1
  70 |     | ) pure returns (
  71 |     |   bool result
  72 |     | ) {
  73 |     |   return !(value0 > value1);
  74 |     | }
  75 |     | 
  76 |     | function greaterThanOrEqualTo(
  77 |     |   X111 value0,
  78 |     |   X111 value1
  79 |     | ) pure returns (
  80 |     |   bool result
  81 |     | ) {
  82 |     |   return !(value0 < value1);
  83 |     | }
  84 |     | 
  85 |     | // Overflow/underflow should be avoided externally.
  86 |     | function add(
  87 |     |   X111 value0,
  88 |     |   X111 value1
  89 |     | ) pure returns (
  90 |     |   X111 result
  91 |     | ) {
  92 |     |   assembly {
  93 |     |     result := add(value0, value1)
  94 |     |   }
  95 |     | }
  96 |     | 
  97 |     | // Overflow/underflow should be avoided externally.
  98 |     | function sub(
  99 |     |   X111 value0,
 100 |     |   X111 value1
 101 |     | ) pure returns (
 102 |     |   X111 result
 103 |     | ) {
 104 |     |   assembly {
 105 |     |     result := sub(value0, value1)
 106 |     |   }
 107 |     | }
 108 |     | 
 109 |     | function min(
 110 |     |   X111 value0,
 111 |     |   X111 value1
 112 |     | ) pure returns (
 113 |     |   X111 result
 114 |     | ) {
 115 |     |   return (value0 < value1) ? value0 : value1;
 116 |     | }
 117 |     | 
 118 |     | function max(
 119 |     |   X111 value0,
 120 |     |   X111 value1
 121 |     | ) pure returns (
 122 |     |   X111 result
 123 |     | ) {
 124 |     |   return (value0 < value1) ? value1 : value0;
 125 |     | }
 126 |     | 
 127 |     | library X111Library {
 128 |     |   /// @notice Calculates 'liquidity == growth * shares'.
 129 |     |   /// 'growth' should not be less than 'oneX111'.
 130 |     |   /// 'growth' should be less than or equal to '1 << 127'.
 131 |     |   /// 'shares' should be less than '1 << 127'
 132 |     |   function times(
 133 |     |     X111 growth,
 134 |     |     uint256 shares
 135 |     |   ) internal pure returns (
 136 |     |     X111 liquidity
 137 |     |   ) {
 138 |     |     assembly {
 139 |     |       // Multiplication is safe because of the input requirements.
 140 |     |       liquidity := mul(growth, shares)
 141 |     |     }
 142 |     |   }
 143 |     | 
 144 |     |   /// @notice Calculates 'liquidity == growth * shares'.
 145 |     |   /// 'growth' should not be less than 'oneX111'.
 146 |     |   /// 'growth' should be less than or equal to '1 << 127'.
 147 |     |   /// 'shares' should be greater than '- (1 << 127)'.
 148 |     |   /// 'shares' should be less than '1 << 127'.
 149 |     |   function times(
 150 |     |     X111 growth,
 151 |     |     int256 shares
 152 |     |   ) internal pure returns (
 153 |     |     X111 liquidity
 154 |     |   ) {
 155 |     |     assembly {
 156 |     |       // Multiplication is safe because of the input requirements.
 157 |     |       liquidity := mul(growth, shares)
 158 |     |     }
 159 |     |   }
 160 |     | 
 161 |     |   /// @notice Calculates
 162 |     |   /// '(value * multiplier) / ((2 ** 119) * exp(-8))'
 163 |     |   /// 'growth' should not be less than 'oneX111'.
 164 |     |   /// 'growth' should be less than or equal to '1 << 127'.
 165 |     |   /// 'multiplier' should be non-negative and less than 'oneX216'.
 166 |     |   function mulDivByExpInv8(
 167 |     |     X111 growth,
 168 |     |     X216 multiplier
 169 |     |   ) internal pure returns (
 170 |     |     X208 product
 171 |     |   ) {
 172 |     |     // Both castings are safe because
 173 |     |     // 'growth >= oneX111' and 'multiplier >= zeroX216'
 174 |     |     ( ,  , uint256 q2) = FullMathLibrary.mul768(
 175 |     |       // (2 ** 244) * exp(8)
 176 |     |       0xBA4F53EA38636F85F007042540AE8EF33225E9A7AB4F4473A86D4A8FDD1A5B82,
 177 |     |       // The shift is safe because 'oneX111 <= growth <= (1 << 127)'
 178 |     |       uint256(X111.unwrap(growth)) << 110,
 179 |     |       // The shift is safe because '0 <= multiplier <= oneX216'
 180 |     |       uint256(X216.unwrap(multiplier)) << 39
 181 |     |     );
 182 |     |     product = X208.wrap(q2);
 183 |     |   }
 184 |     | }

R:/LIAT.AI/question2-calldata/contracts/utilities/X127.sol
   1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
   2 |     | pragma solidity ^0.8.28;
   3 |     | 
   4 |     | import {X23} from "./X23.sol";
   5 |     | import {X216} from "./X216.sol";
   6 |     | import {SafeAddFailed} from "./Errors.sol";
   7 |     | import {FullMathLibrary} from "./FullMath.sol";
   8 |     | 
   9 |     | // Type 'X127' is used for 'sqrtOffset', 'sqrtInverseOffset', and token
  10 |     | // amounts.
  11 |     | type X127 is int256;
  12 |     | 
  13 |     | using X127Library for X127 global;
  14 |     | 
  15 |     | X127 constant oneX127 = X127.wrap(1 << 127);
  16 |     | X127 constant zeroX127 = X127.wrap(0);
  17 |     | X127 constant epsilonX127 = X127.wrap(1);
  18 |     | // 104 = 231 - 127 digits of non-decimal
  19 |     | X127 constant accruedMax = X127.wrap((1 << 231) - 1);
  20 |     | 
  21 |     | using {equals as ==, notEquals as !=} for X127 global;
  22 |     | using {lessThan as <, greaterThan as >} for X127 global;
  23 |     | using {
  24 |     |   lessThanOrEqualTo as <=,
  25 |     |   greaterThanOrEqualTo as >=
  26 |     | } for X127 global;
  27 |     | using {add as +, sub as -, safeAdd as &} for X127 global;
  28 |     | 
  29 |     | function equals(
  30 |     |   X127 value0,
  31 |     |   X127 value1
  32 |     | ) pure returns (
  33 |     |   bool result
  34 |     | ) {
  35 |     |   assembly {
  36 |     |     result := eq(value0, value1)
  37 |     |   }
  38 |     | }
  39 |     | 
  40 |     | function notEquals(
  41 |     |   X127 value0,
  42 |     |   X127 value1
  43 |     | ) pure returns (
  44 |     |   bool result
  45 |     | ) {
  46 |     |   return !(value0 == value1);
  47 |     | }
  48 |     | 
  49 |     | function lessThan(
  50 |     |   X127 value0,
  51 |     |   X127 value1
  52 |     | ) pure returns (
  53 |     |   bool result
  54 |     | ) {
  55 |     |   assembly {
  56 |     |     result := slt(value0, value1)
  57 |     |   }
  58 |     | }
  59 |     | 
  60 |     | function greaterThan(
  61 |     |   X127 value0,
  62 |     |   X127 value1
  63 |     | ) pure returns (
  64 |     |   bool result
  65 |     | ) {
  66 |     |   assembly {
  67 |     |     result := sgt(value0, value1)
  68 |     |   }
  69 |     | }
  70 |     | 
  71 |     | function lessThanOrEqualTo(
  72 |     |   X127 value0,
  73 |     |   X127 value1
  74 |     | ) pure returns (
  75 |     |   bool result
  76 |     | ) {
  77 |     |   return !(value0 > value1);
  78 |     | }
  79 |     | 
  80 |     | function greaterThanOrEqualTo(
  81 |     |   X127 value0,
  82 |     |   X127 value1
  83 |     | ) pure returns (
  84 |     |   bool result
  85 |     | ) {
  86 |     |   return !(value0 < value1);
  87 |     | }
  88 |     | 
  89 |     | // Overflow/underflow should be avoided externally.
  90 |     | function add(
  91 |     |   X127 value0,
  92 |     |   X127 value1
  93 |     | ) pure returns (
  94 |     |   X127 result
  95 |     | ) {
  96 |     |   assembly {
  97 |     |     result := add(value0, value1)
  98 |     |   }
  99 |     | }
 100 |     | 
 101 |     | // Overflow/underflow should be avoided externally.
 102 |     | function sub(
 103 |     |   X127 value0,
 104 |     |   X127 value1
 105 |     | ) pure returns (
 106 |     |   X127 result
 107 |     | ) {
 108 |     |   assembly {
 109 |     |     result := sub(value0, value1)
 110 |     |   }
 111 |     | }
 112 |     | 
 113 |     | // Throws in case of overflow/underflow.
 114 |     | function safeAdd(
 115 |     |   X127 value0,
 116 |     |   X127 value1
 117 |     | ) pure returns (
 118 |     |   X127 result
 119 |     | ) {
 120 |     |   // We first add the two values unsafely and then examine the result.
 121 |     |   result = value0 + value1;
 122 |     |   
 123 |     |   // The following requirement is satisfied if and only if 'result' does not
 124 |     |   // overflow or underflow. Because,
 125 |     |   // - overflow implies that both 'value0' and 'value1' are positive but
 126 |     |   // 'result' is negative which contradicts the following requirement.
 127 |     |   // - underflow implies that both 'value0' and 'value1' are negative but
 128 |     |   // 'result' is positive which contradicts the following requirement as well.
 129 |     |   // - Lastly, in case of no overflow/underflow, the following requirement is
 130 |     |   // trivial.
 131 |     |   require(
 132 |     |     (value1 >= zeroX127) == (result >= value0),
 133 |     |     SafeAddFailed(value0, value1)
 134 |     |   );
 135 |     | }
 136 |     | 
 137 |     | function min(
 138 |     |   X127 value0,
 139 |     |   X127 value1
 140 |     | ) pure returns (
 141 |     |   X127 result
 142 |     | ) {
 143 |     |   return (value0 < value1) ? value0 : value1;
 144 |     | }
 145 |     | 
 146 |     | function max(
 147 |     |   X127 value0,
 148 |     |   X127 value1
 149 |     | ) pure returns (
 150 |     |   X127 result
 151 |     | ) {
 152 |     |   return (value0 < value1) ? value1 : value0;
 153 |     | }
 154 |     | 
 155 |     | library X127Library {
 156 |     |   /// @notice Calculates 'value * multiplier / (2 ** 23)'
 157 |     |   /// 'value' should be non-negative.
 158 |     |   /// 'value * multiplier' should be less than '2 ** 256'.
 159 |     |   function times(
 160 |     |     X127 value,
 161 |     |     X23 multiplier
 162 |     |   ) internal pure returns (
 163 |     |     X127 product
 164 |     |   ) {
 165 |     |     // The multiplication is safe because of the input requirement.
 166 |     |     assembly {
 167 |     |       product := shr(23, mul(value, multiplier))
 168 |     |     }
 169 |     |   }
 170 |     | 
 171 |     |   /// @notice Calculates '(value * numerator) / denominator'
 172 |     |   /// Overflow and division by zero should be avoided externally.
 173 |     |   /// All input values should be non-negative.
 174 |     |   function mulDiv(
 175 |     |     X127 value,
 176 |     |     X216 numerator,
 177 |     |     X216 denominator
 178 |     |   ) internal pure returns (
 179 |     |     X127 result
 180 |     |   ) {
 181 |     |     result = X127.wrap(
 182 |     |       // Casting to 'int256' is safe because overflow is handled externally.
 183 |     |       int256(
 184 |     |         // The three castings are safe because of the input requirement.
 185 |     |         // The requirements of 'mulDiv' are met because overflow is handled
 186 |     |         // externally.
 187 |     |         FullMathLibrary.mulDiv(
 188 |     |           uint256(X127.unwrap(value)),
 189 |     |           uint256(X216.unwrap(numerator)),
 190 |     |           uint256(X216.unwrap(denominator))
 191 |     |         )
 192 |     |       )
 193 |     |     );
 194 |     |   }
 195 |     | 
 196 |     |   /// @notice Transforms type X127 to the integer 'value / (2 ** 127)' while
 197 |     |   /// maintaining the sign. Rounds towards negative infinity.
 198 |     |   function toInteger(
 199 |     |     X127 value
 200 |     |   ) internal pure returns (
 201 |     |     int256 result
 202 |     |   ) {
 203 |     |     assembly {
 204 |     |       result := sar(127, value)
 205 |     |     }
 206 |     |   }
 207 |     | 
 208 |     |   /// @notice Transforms type X127 to the integer 'value / (2 ** 127)' while
 209 |     |   /// maintaining the sign.
 210 |     |   /// Rounds towards positive infinity.
 211 |     |   /// 'value' should be greater than '- 2 ** 255'.
 212 |     |   function toIntegerRoundUp(
 213 |     |     X127 value
 214 |     |   ) internal pure returns (
 215 |     |     int256 result
 216 |     |   ) {
 217 |     |     // The inner subtraction is safe because 'value > - 2 ** 255'.
 218 |     |     // The outer subtraction is safe because 
 219 |     |     // '- 2 ** 128 < (0 - value) / (2 ** 127) < 2 ** 128'
 220 |     |     assembly {
 221 |     |       result := sub(0, sar(127, sub(0, value)))
 222 |     |     }
 223 |     |   }
 224 |     | }

R:/LIAT.AI/question2-calldata/contracts/utilities/X15.sol
   1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
   2 |     | pragma solidity ^0.8.28;
   3 |     | 
   4 |     | // Type 'X15' is dedicated to the vertical coordinates of the kernel
   5 |     | // breakpoints. The distribution of liquidity within every interval is governed
   6 |     | // by a piecewise linear kernel function. The kernel function is characterized
   7 |     | // by a list of breakpoints given by the pool owner. The vertical coordinate of
   8 |     | // each breakpoint is a number within the interval [0, 1] which is stored in
   9 |     | // 'X15' format, with '2 ** 15' representing 1.
  10 |     | type X15 is uint256;
  11 |     | 
  12 |     | X15 constant zeroX15 = X15.wrap(0);
  13 |     | X15 constant oneX15 = X15.wrap(1 << 15);
  14 |     | 
  15 |     | using {equals as ==, notEqual as !=} for X15 global;
  16 |     | using {lessThan as <, greaterThan as >} for X15 global;
  17 |     | using {
  18 |     |   lessThanOrEqualTo as <=,
  19 |     |   greaterThanOrEqualTo as >=
  20 |     | } for X15 global;
  21 |     | using {add as +, sub as -} for X15 global;
  22 |     | 
  23 |     | function equals(
  24 |     |   X15 value0,
  25 |     |   X15 value1
  26 |     | ) pure returns (
  27 |     |   bool result
  28 |     | ) {
  29 |     |   assembly {
  30 |     |     result := eq(value0, value1)
  31 |     |   }
  32 |     | }
  33 |     | 
  34 |     | function notEqual(
  35 |     |   X15 value0,
  36 |     |   X15 value1
  37 |     | ) pure returns (
  38 |     |   bool result
  39 |     | ) {
  40 |     |   return !(value0 == value1);
  41 |     | }
  42 |     | 
  43 |     | function lessThan(
  44 |     |   X15 value0,
  45 |     |   X15 value1
  46 |     | ) pure returns (
  47 |     |   bool result
  48 |     | ) {
  49 |     |   assembly {
  50 |     |     result := lt(value0, value1)
  51 |     |   }
  52 |     | }
  53 |     | 
  54 |     | function greaterThan(
  55 |     |   X15 value0,
  56 |     |   X15 value1
  57 |     | ) pure returns (
  58 |     |   bool result
  59 |     | ) {
  60 |     |   assembly {
  61 |     |     result := gt(value0, value1)
  62 |     |   }
  63 |     | }
  64 |     | 
  65 |     | function lessThanOrEqualTo(
  66 |     |   X15 value0,
  67 |     |   X15 value1
  68 |     | ) pure returns (
  69 |     |   bool result
  70 |     | ) {
  71 |     |   return !(value0 > value1);
  72 |     | }
  73 |     | 
  74 |     | function greaterThanOrEqualTo(
  75 |     |   X15 value0,
  76 |     |   X15 value1
  77 |     | ) pure returns (
  78 |     |   bool result
  79 |     | ) {
  80 |     |   return !(value0 < value1);
  81 |     | }
  82 |     | 
  83 |     | // Overflow should be avoided externally.
  84 |     | function add(
  85 |     |   X15 value0,
  86 |     |   X15 value1
  87 |     | ) pure returns (
  88 |     |   X15 result
  89 |     | ) {
  90 |     |   assembly {
  91 |     |     result := add(value0, value1)
  92 |     |   }
  93 |     | }
  94 |     | 
  95 |     | // Underflow should be avoided externally.
  96 |     | function sub(
  97 |     |   X15 value0,
  98 |     |   X15 value1
  99 |     | ) pure returns (
 100 |     |   X15 result
 101 |     | ) {
 102 |     |   assembly {
 103 |     |     result := sub(value0, value1)
 104 |     |   }
 105 |     | }

R:/LIAT.AI/question2-calldata/contracts/utilities/X208.sol
   1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
   2 |     | pragma solidity ^0.8.28;
   3 |     | 
   4 |     | import {X111} from "./X111.sol";
   5 |     | import {X216} from "./X216.sol";
   6 |     | import {FullMathLibrary} from "./FullMath.sol";
   7 |     | 
   8 |     | // Type 'X208' is dedicated to growth multipliers.
   9 |     | type X208 is uint256;
  10 |     | 
  11 |     | using X208Library for X208 global;
  12 |     | 
  13 |     | X208 constant zeroX208 = X208.wrap(0);
  14 |     | // (2 ** 208) * exp(+8)
  15 |     | X208 constant exp8X208 = X208.wrap(
  16 |     |   0x000000000BA4F53EA38636F85F007042540AE8EF33225E9A7AB4F4473A86D4A8
  17 |     | );
  18 |     | 
  19 |     | using {equals as ==, notEquals as !=} for X208 global;
  20 |     | using {lessThan as <, greaterThan as >} for X208 global;
  21 |     | using {
  22 |     |   lessThanOrEqualTo as <=,
  23 |     |   greaterThanOrEqualTo as >=
  24 |     | } for X208 global;
  25 |     | using {add as +, sub as -} for X208 global;
  26 |     | 
  27 |     | function equals(
  28 |     |   X208 value0,
  29 |     |   X208 value1
  30 |     | ) pure returns (
  31 |     |   bool result
  32 |     | ) {
  33 |     |   assembly {
  34 |     |     result := eq(value0, value1)
  35 |     |   }
  36 |     | }
  37 |     | 
  38 |     | function notEquals(
  39 |     |   X208 value0,
  40 |     |   X208 value1
  41 |     | ) pure returns (
  42 |     |   bool result
  43 |     | ) {
  44 |     |   return !(value0 == value1);
  45 |     | }
  46 |     | 
  47 |     | function lessThan(
  48 |     |   X208 value0,
  49 |     |   X208 value1
  50 |     | ) pure returns (
  51 |     |   bool result
  52 |     | ) {
  53 |     |   assembly {
  54 |     |     result := lt(value0, value1)
  55 |     |   }
  56 |     | }
  57 |     | 
  58 |     | function greaterThan(
  59 |     |   X208 value0,
  60 |     |   X208 value1
  61 |     | ) pure returns (
  62 |     |   bool result
  63 |     | ) {
  64 |     |   assembly {
  65 |     |     result := gt(value0, value1)
  66 |     |   }
  67 |     | }
  68 |     | 
  69 |     | function lessThanOrEqualTo(
  70 |     |   X208 value0,
  71 |     |   X208 value1
  72 |     | ) pure returns (
  73 |     |   bool result
  74 |     | ) {
  75 |     |   return !(value0 > value1);
  76 |     | }
  77 |     | 
  78 |     | function greaterThanOrEqualTo(
  79 |     |   X208 value0,
  80 |     |   X208 value1
  81 |     | ) pure returns (
  82 |     |   bool result
  83 |     | ) {
  84 |     |   return !(value0 < value1);
  85 |     | }
  86 |     | 
  87 |     | // Overflow should be avoided externally.
  88 |     | function add(
  89 |     |   X208 value0,
  90 |     |   X208 value1
  91 |     | ) pure returns (
  92 |     |   X208 result
  93 |     | ) {
  94 |     |   assembly {
  95 |     |     result := add(value0, value1)
  96 |     |   }
  97 |     | }
  98 |     | 
  99 |     | // Underflow should be avoided externally.
 100 |     | function sub(
 101 |     |   X208 value0,
 102 |     |   X208 value1
 103 |     | ) pure returns (
 104 |     |   X208 result
 105 |     | ) {
 106 |     |   assembly {
 107 |     |     result := sub(value0, value1)
 108 |     |   }
 109 |     | }
 110 |     | 
 111 |     | library X208Library {
 112 |     |   /// @notice Calculates '(value * numerator) / denominator'
 113 |     |   /// Overflow and division by zero should be avoided externally.
 114 |     |   /// 'numerator' and 'denominator' values should be non-negative.
 115 |     |   function mulDiv(
 116 |     |     X208 value,
 117 |     |     X216 numerator,
 118 |     |     X216 denominator
 119 |     |   ) internal pure returns (
 120 |     |     X208 result
 121 |     |   ) {
 122 |     |     // Both castings are safe because of the non-negative requirement on both
 123 |     |     // 'numerator' and 'denominator'.
 124 |     |     result = X208.wrap(
 125 |     |       FullMathLibrary.mulDiv(
 126 |     |         X208.unwrap(value),
 127 |     |         uint256(X216.unwrap(numerator)),
 128 |     |         uint256(X216.unwrap(denominator))
 129 |     |       )
 130 |     |     );
 131 |     |   }
 132 |     | 
 133 |     |   /// @notice Calculates
 134 |     |   /// '(value * multiplier) / ((2 ** 313) * exp(-8))'
 135 |     |   /// 'multiplier' should be non-negative.
 136 |     |   function mulDivByExpInv8(
 137 |     |     X208 value,
 138 |     |     X216 multiplier
 139 |     |   ) internal pure returns (
 140 |     |     X111 product
 141 |     |   ) {
 142 |     |     ( ,  , uint256 q2) = FullMathLibrary.mul768(
 143 |     |       // (2 ** 244) * exp(8)
 144 |     |       0xBA4F53EA38636F85F007042540AE8EF33225E9A7AB4F4473A86D4A8FDD1A5B82,
 145 |     |       X208.unwrap(value),
 146 |     |       // Casting is safe because of the non-negative requirement on
 147 |     |       // 'multiplier'.
 148 |     |       uint256(X216.unwrap(multiplier))
 149 |     |     );
 150 |     |     unchecked {
 151 |     |       // Casting is safe because 'q2 >> 45' never exceeds 'type(int256).max'.
 152 |     |       // '45 == 244 + 208 + 216 - 512 - 111'
 153 |     |       product = X111.wrap(int256(q2 >> 45));
 154 |     |     }
 155 |     |   }
 156 |     | }

R:/LIAT.AI/question2-calldata/contracts/utilities/X216.sol
   1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
   2 |     | pragma solidity ^0.8.28;
   3 |     | 
   4 |     | import {FullMathLibrary} from "./FullMath.sol";
   5 |     | 
   6 |     | // Type 'X216' is dedicated to integrals and sqrt of price values.
   7 |     | type X216 is int256;
   8 |     | 
   9 |     | using X216Library for X216 global;
  10 |     | 
  11 |     | X216 constant oneX216 = X216.wrap(1 << 216);
  12 |     | X216 constant zeroX216 = X216.wrap(0);
  13 |     | X216 constant epsilonX216 = X216.wrap(1);
  14 |     | // (2 ** 216) * exp(-8)
  15 |     | X216 constant expInverse8X216 = X216.wrap(
  16 |     |   0x00000000000015FC21041027ACBBFCD46780FEE71EAD23FBCB7F4A81E58767EF
  17 |     | );
  18 |     | 
  19 |     | using {equals as ==, notEquals as !=} for X216 global;
  20 |     | using {lessThan as <, greaterThan as >} for X216 global;
  21 |     | using {
  22 |     |   lessThanOrEqualTo as <=,
  23 |     |   greaterThanOrEqualTo as >=
  24 |     | } for X216 global;
  25 |     | using {add as +, sub as -} for X216 global;
  26 |     | using {mul as *, cheapMul as &} for X216 global;
  27 |     | using {mulDivByExpInv8 as %, mulDivByExpInv16 as ^} for X216 global;
  28 |     | 
  29 |     | function equals(
  30 |     |   X216 value0,
  31 |     |   X216 value1
  32 |     | ) pure returns (
  33 |     |   bool result
  34 |     | ) {
  35 |     |   assembly {
  36 |     |     result := eq(value0, value1)
  37 |     |   }
  38 |     | }
  39 |     | 
  40 |     | function notEquals(
  41 |     |   X216 value0,
  42 |     |   X216 value1
  43 |     | ) pure returns (
  44 |     |   bool result
  45 |     | ) {
  46 |     |   return !(value0 == value1);
  47 |     | }
  48 |     | 
  49 |     | function lessThan(
  50 |     |   X216 value0,
  51 |     |   X216 value1
  52 |     | ) pure returns (
  53 |     |   bool result
  54 |     | ) {
  55 |     |   assembly {
  56 |     |     result := slt(value0, value1)
  57 |     |   }
  58 |     | }
  59 |     | 
  60 |     | function greaterThan(
  61 |     |   X216 value0,
  62 |     |   X216 value1
  63 |     | ) pure returns (
  64 |     |   bool result
  65 |     | ) {
  66 |     |   assembly {
  67 |     |     result := sgt(value0, value1)
  68 |     |   }
  69 |     | }
  70 |     | 
  71 |     | function lessThanOrEqualTo(
  72 |     |   X216 value0,
  73 |     |   X216 value1
  74 |     | ) pure returns (
  75 |     |   bool result
  76 |     | ) {
  77 |     |   return !(value0 > value1);
  78 |     | }
  79 |     | 
  80 |     | function greaterThanOrEqualTo(
  81 |     |   X216 value0,
  82 |     |   X216 value1
  83 |     | ) pure returns (
  84 |     |   bool result
  85 |     | ) {
  86 |     |   return !(value0 < value1);
  87 |     | }
  88 |     | 
  89 |     | // Overflow/underflow should be avoided externally.
  90 |     | function add(
  91 |     |   X216 value0,
  92 |     |   X216 value1
  93 |     | ) pure returns (
  94 |     |   X216 result
  95 |     | ) {
  96 |     |   assembly {
  97 |     |     result := add(value0, value1)
  98 |     |   }
  99 |     | }
 100 |     | 
 101 |     | // Overflow/underflow should be avoided externally.
 102 |     | function sub(
 103 |     |   X216 value0,
 104 |     |   X216 value1
 105 |     | ) pure returns (
 106 |     |   X216 result
 107 |     | ) {
 108 |     |   assembly {
 109 |     |     result := sub(value0, value1)
 110 |     |   }
 111 |     | }
 112 |     | 
 113 |     | // Calculates '(value0 * value1) / (2 ** 216)'.
 114 |     | // Overflow/underflow should be avoided externally.
 115 |     | // Both values should be greater than '- 2 ** 255'.
 116 |     | function mul(
 117 |     |   X216 value0,
 118 |     |   X216 value1
 119 |     | ) pure returns (
 120 |     |   X216 result
 121 |     | ) {
 122 |     |   // Let 's := value0 * value1 - (2 ** 256 - 1) * p'
 123 |     |   // Let 'r := value0 * value1 - (2 ** 216) * q'
 124 |     |   // Then 's - r == (2 ** 216) * q' [modulo '2 ** 256 - 1']
 125 |     |   // Then 'q == (2 ** 40) * (s - r)' [modulo '2 ** 256 - 1']
 126 |     |   assembly {
 127 |     |     result := mulmod(
 128 |     |       addmod(
 129 |     |         // We account for the additional term '2 ** 256' in two's complement
 130 |     |         // representation by subtracting 'slt(value, 0)'. Because if a two's
 131 |     |         // complement representation 'value' correspond to a negative number,
 132 |     |         // we have:
 133 |     |         //
 134 |     |         // 'value - 2 ** 256 == value - 1' [modulo 2 ** 256 - 1]
 135 |     |         //
 136 |     |         // Both subtractions are safe due to the input requirement.
 137 |     |         mulmod(
 138 |     |           sub(value0, slt(value0, 0)),
 139 |     |           sub(value1, slt(value1, 0)),
 140 |     |           not(0)
 141 |     |         ), // s
 142 |     |         // Here, we do not need to account for the additional term '2 ** 256'
 143 |     |         // in two's complement representation because if a two's complement
 144 |     |         // representation 'value' is negative, we have:
 145 |     |         //
 146 |     |         // 'value - 2 ** 256 == value' [modulo 2 ** 216]
 147 |     |         //
 148 |     |         // The subtraction is safe because '2 ** 216 < 2 ** 256 - 1'.
 149 |     |         sub(not(0), mulmod(value0, value1, shl(216, 1))), // 0 - r
 150 |     |         not(0)
 151 |     |       ),
 152 |     |       shl(40, 1),
 153 |     |       not(0)
 154 |     |     )
 155 |     |   }
 156 |     | }
 157 |     | 
 158 |     | // Calculates '(value0 * value1) / (2 ** 216)'.
 159 |     | // 'value0' and 'value1' should be non-negative and less than 'oneX216'.
 160 |     | function cheapMul(
 161 |     |   X216 value0,
 162 |     |   X216 value1
 163 |     | ) pure returns (
 164 |     |   X216 result
 165 |     | ) {
 166 |     |   // Let 's := value0 * value1 - (2 ** 216 - 1) * p'
 167 |     |   // Let 'r := value0 * value1 - (2 ** 216) * q'
 168 |     |   // Then 's - r == q' [modulo '2 ** 216 - 1']
 169 |     |   // Because of the input requirements, 'q' does not exceed '2 ** 216 - 1'
 170 |     |   // which concludes that: 's - r == q'.
 171 |     |   assembly {
 172 |     |     result := addmod(
 173 |     |       mulmod(value0, value1, sub(shl(216, 1), 1)), // s
 174 |     |       // The subtraction is safe because the output of 'mulmod' does not exceed
 175 |     |       // '2 ** 216 - 1'.
 176 |     |       sub(sub(shl(216, 1), 1), mulmod(value0, value1, shl(216, 1))), // 0 - r
 177 |     |       sub(shl(216, 1), 1)
 178 |     |     )
 179 |     |   }
 180 |     | }
 181 |     | 
 182 |     | // Calculates '(value0 * value1) / ((2 ** 216) * exp(-8))'.
 183 |     | //
 184 |     | // The following approximation is used: '(2 ** 216) * exp(-8) ~= b / a' where
 185 |     | // 'a = 0xF8F6376C44' and 
 186 |     | // 'b = 0x1561650620DABB6A84B684E2A7E5A47CAA0A0905210083F0E3B551AABF84E9'
 187 |     | //
 188 |     | // Overflow should be avoided externally.
 189 |     | // Both values should be non-negative.
 190 |     | // 'value0' should be less than 'oneX216'.
 191 |     | function mulDivByExpInv8(
 192 |     |   X216 value0,
 193 |     |   X216 value1
 194 |     | ) pure returns (
 195 |     |   X216 result
 196 |     | ) {
 197 |     |   // Let 's := value0 * value1 * a - (2 ** 256) * p'
 198 |     |   // Let 'r := value0 * value1 * a - b * q'
 199 |     |   // Then 's - r == b * q' [modulo '2 ** 256']
 200 |     |   assembly {
 201 |     |     // Multiplication is safe because of the input requirement:
 202 |     |     // '0 <= value0 < oneX216'.
 203 |     |     result := mul(value0, 0xF8F6376C44)
 204 |     |     result := mul(
 205 |     |       // s - r
 206 |     |       sub(
 207 |     |         // s
 208 |     |         mul(result, value1),
 209 |     |         // r
 210 |     |         mulmod(
 211 |     |           result,
 212 |     |           value1,
 213 |     |           0x1561650620DABB6A84B684E2A7E5A47CAA0A0905210083F0E3B551AABF84E9 // b
 214 |     |         )
 215 |     |       ),
 216 |     |       // modular inverse of 'b' modulo '2 ** 256'
 217 |     |       0x28256938C4923FF15AB260970AA81F81C15E6F5EF3AF38DC210569E77DB19359
 218 |     |     )
 219 |     |   }
 220 |     | }
 221 |     | 
 222 |     | // Calculates '(value0 * value1) / ((2 ** 216) * exp(-16))'.
 223 |     | //
 224 |     | // The following approximation is used: '(2 ** 216) * exp(-16) ~= b / a' where
 225 |     | // 'a = 0x27D117D7B * 0x2EC3A856' and 
 226 |     | // 'b = 0xDBB82F7041B890FE67970A62A3568CC34DF9DCB17CC3A2A6A027850E7E3724F9'
 227 |     | //
 228 |     | // Overflow should be avoided externally.
 229 |     | // Both values should be non-negative.
 230 |     | // 'value0' and 'value1' should be less than 'oneX216'.
 231 |     | function mulDivByExpInv16(
 232 |     |   X216 value0,
 233 |     |   X216 value1
 234 |     | ) pure returns (
 235 |     |   X216 result
 236 |     | ) {
 237 |     |   // Let 's := value0 * value1 * a - (2 ** 256) * p'
 238 |     |   // Let 'r := value0 * value1 * a - b * q'
 239 |     |   // Then 's - r == b * q' [modulo '2 ** 256']
 240 |     |   assembly {
 241 |     |     // Both of the following multiplications are safe because of the input
 242 |     |     // requirements:
 243 |     |     // '0 <= value0 < oneX216'.
 244 |     |     // '0 <= value1 < oneX216'.
 245 |     |     value0 := mul(value0, 0x27D117D7B)
 246 |     |     value1 := mul(value1, 0x2EC3A856)
 247 |     |     result := mul(
 248 |     |       // s - r
 249 |     |       sub(
 250 |     |         // s
 251 |     |         mul(value0, value1),
 252 |     |         // r
 253 |     |         mulmod(
 254 |     |           value0,
 255 |     |           value1,
 256 |     |           // b
 257 |     |           0xDBB82F7041B890FE67970A62A3568CC34DF9DCB17CC3A2A6A027850E7E3724F9
 258 |     |         )
 259 |     |       ),
 260 |     |       // modular inverse of 'b' modulo '2 ** 256'
 261 |     |       0x7F6AF8233BADA11DD406B4458454ED9904D7AF796BE7AA4885B23E25B6985D49
 262 |     |     )
 263 |     |   }
 264 |     | }
 265 |     | 
 266 |     | function min(
 267 |     |   X216 value0,
 268 |     |   X216 value1
 269 |     | ) pure returns (
 270 |     |   X216 result
 271 |     | ) {
 272 |     |   return (value0 < value1) ? value0 : value1;
 273 |     | }
 274 |     | 
 275 |     | function max(
 276 |     |   X216 value0,
 277 |     |   X216 value1
 278 |     | ) pure returns (
 279 |     |   X216 result
 280 |     | ) {
 281 |     |   return (value0 < value1) ? value1 : value0;
 282 |     | }
 283 |     | 
 284 |     | /// @notice Returns the minimum of two unsigned fractions. '0 / 0' is 
 285 |     | /// interpreted as infinity. 'which == false' and 'which == true' indicate
 286 |     | /// '(numerator0, denominator0)' and '(numerator1, denominator1)',
 287 |     | /// respectively.
 288 |     | /// All four values should be non-negative.
 289 |     | /// At least one 'denominator' should be non-zero.
 290 |     | function minFractions(
 291 |     |   X216 numerator0,
 292 |     |   X216 denominator0,
 293 |     |   X216 numerator1,
 294 |     |   X216 denominator1
 295 |     | ) pure returns (
 296 |     |   X216 numerator,
 297 |     |   X216 denominator,
 298 |     |   bool which
 299 |     | ) {
 300 |     |   if (numerator0 == zeroX216) {
 301 |     |     if (denominator0 == zeroX216) {
 302 |     |       return (numerator1, denominator1, true);
 303 |     |     }
 304 |     |   }
 305 |     |   // Castings are safe because all four values are non-negative.
 306 |     |   (uint256 lsb0, uint256 msb0) = FullMathLibrary.mul512(
 307 |     |     uint256(X216.unwrap(numerator0)),
 308 |     |     uint256(X216.unwrap(denominator1))
 309 |     |   );
 310 |     |   (uint256 lsb1, uint256 msb1) = FullMathLibrary.mul512(
 311 |     |     uint256(X216.unwrap(numerator1)),
 312 |     |     uint256(X216.unwrap(denominator0))
 313 |     |   );
 314 |     |   (numerator, denominator, which) = 
 315 |     |     ((msb1 > msb0) || ((msb1 == msb0) && (lsb1 >= lsb0))) ? 
 316 |     |     (numerator0, denominator0, false) : 
 317 |     |     (numerator1, denominator1, true);
 318 |     | }
 319 |     | 
 320 |     | library X216Library {
 321 |     |   /// @notice Calculates 'value * exp(1 / (2 ** 60))'.
 322 |     |   /// Overflow should be avoided externally.
 323 |     |   /// 'value' should be non-negative.
 324 |     |   function multiplyByExpEpsilon(
 325 |     |     X216 value
 326 |     |   ) internal pure returns (
 327 |     |     X216 result
 328 |     |   ) {
 329 |     |     // Let 'a := floor((2 ** 256) * exp(-1 / (2 ** 60)))'
 330 |     |     // Let 'r := (2 ** 256) * value - a * q'
 331 |     |     // Let 'b := modularInverse(- a, 2 ** 256)'
 332 |     |     // Then 'q == b * r' [modulo '2 ** 256']
 333 |     |     assembly {
 334 |     |       result := mul(
 335 |     |         // r
 336 |     |         mulmod(
 337 |     |           value,
 338 |     |           // We are subtracting by 'a' because '2 ** 256' does not fit, which
 339 |     |           // is okay because the multiplication is done modulo 'a'.
 340 |     |           // 2 ** 256 - a
 341 |     |           0xFFFFFFFFFFFFFFF8000000000000002AAAAAAAAAAAAAAA001,
 342 |     |           // a
 343 |     |           0xFFFFFFFFFFFFFFF0000000000000007FFFFFFFFFFFFFFD555555555555555FFF
 344 |     |         ),
 345 |     |         // b
 346 |     |         0xAA3ED2381A8B1241D16168FD77EF989ED2B13BE12B716AA23F35ED0E39556001
 347 |     |       )
 348 |     |     }
 349 |     |   }
 350 |     | 
 351 |     |   /// @notice Calculates 'value / exp(1 / (2 ** 60))'.
 352 |     |   /// 'value' should be non-negative.
 353 |     |   function divideByExpEpsilon(
 354 |     |     X216 value
 355 |     |   ) internal pure returns (
 356 |     |     X216 result
 357 |     |   ) {
 358 |     |     assembly {
 359 |     |       // Let 'a := floor((2 ** 256 - 1) * exp(-1 / (2 ** 60)))'.
 360 |     |       // Let 's := value * a - q * not(0)'.
 361 |     |       // Let 'r := value * a'.
 362 |     |       // Then 's - r == - q * not(0) == q'.
 363 |     |       result := sub(
 364 |     |         // s
 365 |     |         mulmod(
 366 |     |           value,
 367 |     |           // a
 368 |     |           0xFFFFFFFFFFFFFFF0000000000000007FFFFFFFFFFFFFFD555555555555555FFE,
 369 |     |           not(0)
 370 |     |         ),
 371 |     |         // r
 372 |     |         mul(
 373 |     |           value,
 374 |     |           // a
 375 |     |           0xFFFFFFFFFFFFFFF0000000000000007FFFFFFFFFFFFFFD555555555555555FFE
 376 |     |         )
 377 |     |       )
 378 |     |     }
 379 |     |   }
 380 |     | 
 381 |     |   /// @notice Calculates '(value * numerator) / denominator'
 382 |     |   /// Overflow and division by zero should be avoided externally.
 383 |     |   /// All input values should be non-negative.
 384 |     |   function mulDiv(
 385 |     |     X216 value,
 386 |     |     X216 numerator,
 387 |     |     X216 denominator
 388 |     |   ) internal pure returns (
 389 |     |     X216 result
 390 |     |   ) {
 391 |     |     result = X216.wrap(
 392 |     |       // Casting is safe because overflow is handled externally.
 393 |     |       int256(
 394 |     |         // All three castings are safe due to the input requirements.
 395 |     |         FullMathLibrary.mulDiv(
 396 |     |           uint256(X216.unwrap(value)),
 397 |     |           uint256(X216.unwrap(numerator)),
 398 |     |           uint256(X216.unwrap(denominator))
 399 |     |         )
 400 |     |       )
 401 |     |     );
 402 |     |   }
 403 |     | 
 404 |     |   /// @notice Calculates '(value * numerator) / denominator' when 
 405 |     |   /// 'value * numerator < denominator * (denominator - 1)'.
 406 |     |   /// value should be non-negative
 407 |     |   function cheapMulDiv(
 408 |     |     X216 value,
 409 |     |     uint256 numerator,
 410 |     |     uint256 denominator
 411 |     |   ) internal pure returns (
 412 |     |     X216 result
 413 |     |   ) {
 414 |     |     result = X216.wrap(
 415 |     |       // Casting is safe because overflow is handled externally.
 416 |     |       int256(
 417 |     |         // The requirement of 'cheapMulDiv' is met because of the above input
 418 |     |         // requirement.
 419 |     |         FullMathLibrary.cheapMulDiv(
 420 |     |           // Casting is safe due to the input requirement in 'value'.
 421 |     |           uint256(X216.unwrap(value)),
 422 |     |           numerator,
 423 |     |           denominator
 424 |     |         )
 425 |     |       )
 426 |     |     );
 427 |     |   }
 428 |     | }

R:/LIAT.AI/question2-calldata/contracts/utilities/X23.sol
  1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
  2 |     | pragma solidity ^0.8.28;
  3 |     | 
  4 |     | // Type 'X23' is dedicated to pool growth ratios which determine the ratio of
  5 |     | // the accrued growth portions that belong to a pool owner. 'oneX23' represents
  6 |     | // 100%.
  7 |     | type X23 is uint256;
  8 |     | 
  9 |     | X23 constant zeroX23 = X23.wrap(0);
 10 |     | X23 constant oneX23 = X23.wrap(1 << 23);
 11 |     | 
 12 |     | using {add as +, sub as -} for X23 global;
 13 |     | 
 14 |     | // Overflow should be avoided externally.
 15 |     | function add(
 16 |     |   X23 value0,
 17 |     |   X23 value1
 18 |     | ) pure returns (
 19 |     |   X23 result
 20 |     | ) {
 21 |     |   assembly {
 22 |     |     result := add(value0, value1)
 23 |     |   }
 24 |     | }
 25 |     | 
 26 |     | // Underflow should be avoided externally.
 27 |     | function sub(
 28 |     |   X23 value0,
 29 |     |   X23 value1
 30 |     | ) pure returns (
 31 |     |   X23 result
 32 |     | ) {
 33 |     |   assembly {
 34 |     |     result := sub(value0, value1)
 35 |     |   }
 36 |     | }

R:/LIAT.AI/question2-calldata/contracts/utilities/X47.sol
   1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
   2 |     | pragma solidity ^0.8.28;
   3 |     | 
   4 |     | // Type 'X47' is dedicated to growth portions. Interval liquidity can grow as a
   5 |     | // result of a swap or a donation. A portion of this growth goes to the
   6 |     | // protocol. A portion of the remaining growth goes to the pool owner. These
   7 |     | // portions are stored as 'X47' type with 'oneX47' representing 100%.
   8 |     | type X47 is uint256;
   9 |     | 
  10 |     | X47 constant zeroX47 = X47.wrap(0);
  11 |     | // Largest valid value for growth portions:
  12 | *   | X47 constant oneX47 = X47.wrap(1 << 47);
  13 |     | // An invalid value for growth portions which is used as an indicator:
  14 |     | X47 constant maxX47 = X47.wrap(type(uint48).max);
  15 |     | 
  16 |     | using {equals as ==, notEqual as !=} for X47 global;
  17 |     | using {lessThan as <, greaterThan as >} for X47 global;
  18 |     | using {
  19 |     |   lessThanOrEqualTo as <=,
  20 |     |   greaterThanOrEqualTo as >=
  21 |     | } for X47 global;
  22 |     | 
  23 |     | function equals(
  24 |     |   X47 value0,
  25 |     |   X47 value1
  26 |     | ) pure returns (
  27 |     |   bool result
  28 |     | ) {
  29 |     |   assembly {
  30 |     |     result := eq(value0, value1)
  31 |     |   }
  32 |     | }
  33 |     | 
  34 |     | function notEqual(
  35 |     |   X47 value0,
  36 |     |   X47 value1
  37 |     | ) pure returns (
  38 |     |   bool result
  39 |     | ) {
  40 |     |   return !(value0 == value1);
  41 |     | }
  42 |     | 
  43 |     | function lessThan(
  44 |     |   X47 value0,
  45 |     |   X47 value1
  46 |     | ) pure returns (
  47 |     |   bool result
  48 |     | ) {
  49 |     |   assembly {
  50 |     |     result := lt(value0, value1)
  51 |     |   }
  52 |     | }
  53 |     | 
  54 |     | function greaterThan(
  55 |     |   X47 value0,
  56 |     |   X47 value1
  57 |     | ) pure returns (
  58 |     |   bool result
  59 |     | ) {
  60 |     |   assembly {
  61 |     |     result := gt(value0, value1)
  62 |     |   }
  63 |     | }
  64 |     | 
  65 |     | function lessThanOrEqualTo(
  66 |     |   X47 value0,
  67 |     |   X47 value1
  68 |     | ) pure returns (
  69 |     |   bool result
  70 |     | ) {
  71 |     |   return !(value0 > value1);
  72 |     | }
  73 |     | 
  74 |     | function greaterThanOrEqualTo(
  75 |     |   X47 value0,
  76 |     |   X47 value1
  77 |     | ) pure returns (
  78 |     |   bool result
  79 |     | ) {
  80 |     |   return !(value0 < value1);
  81 |     | }
  82 |     | 
  83 |     | function min(
  84 |     |   X47 value0,
  85 |     |   X47 value1
  86 |     | ) pure returns (
  87 |     |   X47 result
  88 |     | ) {
  89 |     |   return (value0 < value1) ? value0 : value1;
  90 |     | }
  91 |     | 
  92 |     | function max(
  93 |     |   X47 value0,
  94 |     |   X47 value1
  95 |     | ) pure returns (
  96 |     |   X47 result
  97 |     | ) {
  98 |     |   return (value0 < value1) ? value1 : value0;
  99 |     | }

R:/LIAT.AI/question2-calldata/contracts/utilities/X59.sol
   1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
   2 |     | pragma solidity ^0.8.28;
   3 |     | 
   4 |     | import {X15} from "./X15.sol";
   5 |     | import {X74} from "./X74.sol";
   6 |     | import {X127} from "./X127.sol";
   7 |     | import {X216} from "./X216.sol";
   8 |     | import {FullMathLibrary} from "./FullMath.sol";
   9 |     | 
  10 |     | // Type 'X59' is dedicated to the natural logarithm of price.
  11 |     | type X59 is int256;
  12 |     | 
  13 |     | using X59Library for X59 global;
  14 |     | 
  15 |     | X59 constant zeroX59 = X59.wrap(0);
  16 |     | X59 constant epsilonX59 = X59.wrap(1);
  17 |     | X59 constant oneX59 = X59.wrap(1 << 59);
  18 |     | X59 constant twoX59 = X59.wrap(2 << 59);
  19 |     | X59 constant threeX59 = X59.wrap(3 << 59);
  20 |     | X59 constant fourX59 = X59.wrap(4 << 59);
  21 | *   | X59 constant sixteenX59 = X59.wrap(16 << 59);
  22 | *   | X59 constant thirtyTwoX59 = X59.wrap(32 << 59);
  23 |     | X59 constant minLogSpacing = X59.wrap((1 << 59) >> 19);
  24 |     | X59 constant minLogStep = X59.wrap((1 << 59) >> 27);
  25 | *   | X59 constant minLogOffset = X59.wrap(0 - int256(90 << 59));
  26 |     | X59 constant maxLogOffset = X59.wrap(90 << 59);
  27 |     | X59 constant minX59 = X59.wrap(0 - type(int256).max);
  28 |     | X59 constant maxX59 = X59.wrap(type(int256).max);
  29 |     | 
  30 |     | using {equals as ==, notEqual as !=} for X59 global;
  31 |     | using {lessThan as <, greaterThan as >} for X59 global;
  32 |     | using {
  33 |     |   lessThanOrEqualTo as <=,
  34 |     |   greaterThanOrEqualTo as >=
  35 |     | } for X59 global;
  36 |     | using {add as +, sub as -} for X59 global;
  37 |     | using {mod as %} for X59 global;
  38 |     | 
  39 |     | function equals(
  40 |     |   X59 value0,
  41 |     |   X59 value1
  42 |     | ) pure returns (
  43 |     |   bool result
  44 |     | ) {
  45 |     |   assembly {
  46 |     |     result := eq(value0, value1)
  47 |     |   }
  48 |     | }
  49 |     | 
  50 |     | function notEqual(
  51 |     |   X59 value0,
  52 |     |   X59 value1
  53 |     | ) pure returns (
  54 |     |   bool result
  55 |     | ) {
  56 |     |   return !(value0 == value1);
  57 |     | }
  58 |     | 
  59 |     | function lessThan(
  60 |     |   X59 value0,
  61 |     |   X59 value1
  62 |     | ) pure returns (
  63 |     |   bool result
  64 |     | ) {
  65 | *   |   assembly {
  66 |     |     result := slt(value0, value1)
  67 |     |   }
  68 |     | }
  69 |     | 
  70 |     | function greaterThan(
  71 |     |   X59 value0,
  72 |     |   X59 value1
  73 |     | ) pure returns (
  74 |     |   bool result
  75 |     | ) {
  76 | *   |   assembly {
  77 |     |     result := sgt(value0, value1)
  78 |     |   }
  79 |     | }
  80 |     | 
  81 |     | function lessThanOrEqualTo(
  82 |     |   X59 value0,
  83 |     |   X59 value1
  84 |     | ) pure returns (
  85 |     |   bool result
  86 |     | ) {
  87 |     |   return !(value0 > value1);
  88 |     | }
  89 |     | 
  90 |     | function greaterThanOrEqualTo(
  91 |     |   X59 value0,
  92 |     |   X59 value1
  93 |     | ) pure returns (
  94 |     |   bool result
  95 |     | ) {
  96 |     |   return !(value0 < value1);
  97 |     | }
  98 |     | 
  99 |     | // Overflow/underflow should be avoided externally.
 100 |     | function add(
 101 |     |   X59 value0,
 102 |     |   X59 value1
 103 |     | ) pure returns (
 104 |     |   X59 result
 105 |     | ) {
 106 |     |   assembly {
 107 |     |     result := add(value0, value1)
 108 |     |   }
 109 |     | }
 110 |     | 
 111 |     | // Overflow/underflow should be avoided externally.
 112 |     | function sub(
 113 |     |   X59 value0,
 114 |     |   X59 value1
 115 |     | ) pure returns (
 116 |     |   X59 result
 117 |     | ) {
 118 | *   |   assembly {
 119 |     |     result := sub(value0, value1)
 120 |     |   }
 121 |     | }
 122 |     | 
 123 |     | // 'value' should be non-negative.
 124 |     | // 'modulus' should be positive.
 125 |     | function mod(
 126 |     |   X59 value,
 127 |     |   X59 modulus
 128 |     | ) pure returns (
 129 |     |   X59 result
 130 |     | ) {
 131 |     |   assembly {
 132 |     |     result := mod(value, modulus)
 133 |     |   }
 134 |     | }
 135 |     | 
 136 |     | function min(
 137 |     |   X59 value0,
 138 |     |   X59 value1
 139 |     | ) pure returns (
 140 |     |   X59 result
 141 |     | ) {
 142 |     |   return (value0 < value1) ? value0 : value1;
 143 |     | }
 144 |     | 
 145 |     | function max(
 146 |     |   X59 value0,
 147 |     |   X59 value1
 148 |     | ) pure returns (
 149 |     |   X59 result
 150 |     | ) {
 151 |     |   return (value0 < value1) ? value1 : value0;
 152 |     | }
 153 |     | 
 154 |     | library X59Library {
 155 |     |   // Overflow should be avoided externally.
 156 |     |   // 'value0' should be non-negative.
 157 |     |   function times(
 158 |     |     X59 value0,
 159 |     |     X15 value1
 160 |     |   ) internal pure returns (
 161 |     |     X74 result
 162 |     |   ) {
 163 |     |     assembly {
 164 |     |       result := mul(value0, value1)
 165 |     |     }
 166 |     |   }
 167 |     | 
 168 |     |   /// @notice Calculates '(value * numerator) / denominator' when 
 169 |     |   /// 'value * numerator < denominator * (denominator - 1)'.
 170 |     |   /// The three inputs should be non-negative.
 171 |     |   function cheapMulDiv(
 172 |     |     X59 value,
 173 |     |     X216 numerator,
 174 |     |     X216 denominator
 175 |     |   ) internal pure returns (
 176 |     |     X59 result
 177 |     |   ) {
 178 |     |     // The three castings to 'uint256' are safe because of the 'non-negative'
 179 |     |     // requirement on input values.
 180 |     |     //
 181 |     |     // The casting to 'int256' is safe because
 182 |     |     // 'value * numerator / denominator < denominator - 1 <= 2 ** 255 - 2'.
 183 |     |     //
 184 |     |     // The requirement of 'cheapMulDiv' are met because of the above input
 185 |     |     // requirement.
 186 |     |     result = X59.wrap(int256(FullMathLibrary.cheapMulDiv(
 187 |     |       uint256(X59.unwrap(value)),
 188 |     |       uint256(X216.unwrap(numerator)),
 189 |     |       uint256(X216.unwrap(denominator))
 190 |     |     )));
 191 |     |   }
 192 |     | 
 193 |     |   /// @notice Calculates
 194 |     |   /// '(value * multiplier0 * multiplier1) / ((2 ** (216 + 59)) * exp(-16))'
 195 |     |   /// Overflow should be avoided externally.
 196 |     |   /// All three inputs should be non-negative.
 197 |     |   function mulDivByExpInv16(
 198 |     |     X59 value,
 199 |     |     X216 multiplier0,
 200 |     |     X216 multiplier1
 201 |     |   ) internal pure returns (
 202 |     |     X216 product
 203 |     |   ) {
 204 |     |     assembly {
 205 |     |       // Let 'r := value * multiplier0 * multiplier1 
 206 |     |       //         - floor((2 ** 275) * exp(-16)) * q'.
 207 |     |       //
 208 |     |       // Let 's := value * multiplier0 * multiplier1 - (2 ** 256) * p'.
 209 |     |       //
 210 |     |       // Then 's - r == floor((2 ** 275) * exp(-16)) * q' [modulo '2 ** 256']
 211 |     |       product := mul(
 212 |     |         sub(
 213 |     |           // s
 214 |     |           mul(mul(value, multiplier0), multiplier1),
 215 |     |           // r
 216 |     |           mulmod(
 217 |     |             mulmod(
 218 |     |               value,
 219 |     |               multiplier0,
 220 |     |               // floor((2 ** 275) * exp(-16))
 221 |     |               0xF1AADDD7742E56D32FB9F997447D9E6314DB84884FABAB26BF059AF9BC20B61
 222 |     |             ),
 223 |     |             multiplier1,
 224 |     |             // floor((2 ** 275) * exp(-16))
 225 |     |             0xF1AADDD7742E56D32FB9F997447D9E6314DB84884FABAB26BF059AF9BC20B61
 226 |     |           )
 227 |     |         ),
 228 |     |         // modularInverse(floor((2 ** 275) * exp(-16)), 2 ** 256)
 229 |     |         0xD49C04AF80AF1EA5F98F85886B450A4B264FC14874F9F64143836145A37DD8A1
 230 |     |       )
 231 |     |     }
 232 |     |   }
 233 |     | 
 234 |     |   /// @notice Calculates '(2 ** 256) * exp(- x / (2 ** 60))'.
 235 |     |   /// "Pade Approximant" is employed for this purpose:
 236 |     |   /// 'exp(- x / (2 ** 60)) ~= ((u(x) - v(x)) / (u(x) + v(x))) ** (2 ** 14)'
 237 |     |   /// where
 238 |     |   ///                x ** 2      x ** 4       x ** 6          x ** 8
 239 |     |   /// 'u(x) = 1 + 7 --------- + --------- + ----------- + --------------'
 240 |     |   ///                15<<150     39<<300     6435<<449     2027025<<600
 241 |     |   /// and
 242 |     |   ///            x       x ** 3       x ** 5        x ** 7
 243 |     |   /// 'v(x) = ------- + --------- + ---------- + -------------'.
 244 |     |   ///          1<<75     15<<224     585<<374     225225<<523
 245 |     |   ///
 246 |     |   /// This formula can be reproduced via the following Mathematica command:
 247 |     |   /// 'PadeApproximant[Exp[- x / (2 ^ 74)], {x, 0, 8}]'.
 248 |     |   ///
 249 |     |   /// Input should be greater than '0' and less than '2 ** 64'.
 250 |     |   function expInverse(
 251 |     |     X59 value
 252 |     |   ) internal pure returns (
 253 |     |     uint256 exponentialInverse
 254 |     |   ) {
 255 |     |     unchecked {
 256 |     |       // Casting is safe because 'value' is between '0' and '2 ** 64'.
 257 |     |       uint256 x = uint256(X59.unwrap(value));
 258 |     |       
 259 |     |       // x ** 2
 260 |     |       uint256 x2 = x * x;
 261 |     |       
 262 |     |       // x ** 4
 263 |     |       uint256 x4 = x2 * x2;
 264 |     | 
 265 |     |       // (x ** 6) / (2 ** 128)
 266 |     |       uint256 x6;
 267 |     |       assembly {
 268 |     |         // Let 'r := x2 * x4 - (2 ** 128) * q'
 269 |     |         // Let 's := x2 * x4 - (2 ** 256 - 1) * p'
 270 |     |         // Then 's - r == (2 ** 128) * q' [modulo '2 ** 256 - 1']
 271 |     |         // And 'q == (2 ** 128) * (s - r)' [modulo '2 ** 256 - 1']
 272 |     |         // Calculation modulo '2 ** 256 - 1' is safe because:
 273 |     |         // '((2 ** 64 - 1) ** 6) / (2 ** 128) < 2 ** 256 - 1'
 274 |     |         x6 := mulmod(
 275 |     |           // The subtraction is safe because the remainder is greater than or
 276 |     |           // equal to the second one.
 277 |     |           sub(mulmod(x2, x4, not(0)), mulmod(x2, x4, shl(128, 1))),
 278 |     |           shl(128, 1),
 279 |     |           not(0)
 280 |     |         )
 281 |     |       }
 282 |     | 
 283 |     |       // (x ** 8) / (2 ** 256)
 284 |     |       uint256 x8;
 285 |     |       assembly {
 286 |     |         // Let 'r := x4 * x4 - (2 ** 256) * q'
 287 |     |         // Let 's := x4 * x4 - (2 ** 256 - 1) * p'
 288 |     |         // Then 's - r == q' [modulo '2 ** 256 - 1']
 289 |     |         // Calculation modulo '2 ** 256 - 1' is safe because:
 290 |     |         // '((2 ** 64 - 1) ** 8) / (2 ** 256) < 2 ** 256 - 1'
 291 |     |         x8 := sub(mulmod(x4, x4, not(0)), mul(x4, x4))
 292 |     |       }
 293 |     | 
 294 |     |       // (2 ** 254) * u(x)
 295 |     |       // The additions are safe because the first term is '1 << 254' and none
 296 |     |       // of the other terms exceed '1 << 250'.
 297 |     |       uint256 a = 
 298 |     |         ((x2 * (7 << 104)) / 15) + 
 299 |     |         (x4 / (39 << 46)) + 
 300 |     |         (x6 / (6435 << 67)) + 
 301 |     |         (x8 / (2027025 << 90)) + 
 302 |     |         (1 << 254);
 303 |     | 
 304 |     |       // (2 ** 254) * v(x)
 305 |     |       // The additions are safe because the first term is '1 << 255' and none
 306 |     |       // of the other terms exceed '1 << 250'.
 307 |     |       uint256 b = 
 308 |     |         ((x2 << 106) / 15) + 
 309 |     |         (x4 / (585 << 44)) + 
 310 |     |         (x6 / (225225 << 65)) + 
 311 |     |         (1 << 255);
 312 |     |         
 313 |     |       assembly {
 314 |     |         // Here we multiply the result by (x / (2 ** 76)).
 315 |     |         // Let 'r := x * b - (2 ** 76) * q'
 316 |     |         // Let 's := x * b - (2 ** 256 - 1) * p'
 317 |     |         // Then 's - r == (2 ** 76) * q' [modulo '2 ** 256 - 1']
 318 |     |         // And 'q == (2 ** 180) * (s - r)' [modulo '2 ** 256 - 1']
 319 |     |         // Calculation modulo '2 ** 256 - 1' is safe because:
 320 |     |         // 'b < 2 ** 256 - 1'
 321 |     |         b := mulmod(
 322 |     |           // The subtraction is safe because the remainder is greater than or
 323 |     |           // equal to the second one.
 324 |     |           sub(mulmod(x, b, not(0)), mulmod(x, b, shl(76, 1))),
 325 |     |           shl(180, 1),
 326 |     |           not(0)
 327 |     |         )
 328 |     |       }
 329 |     | 
 330 |     |       // (2 ** 256) * (u(x) - v(x)) / (u(x) + v(x))
 331 |     |       // Since '(2 ** 254) * (a - b) - (a + b) * (a + b - 1)' is a
 332 |     |       // decreasing function with respect to 'x', it suffices to verify
 333 |     |       // that '(2 ** 254) * (a - b) - (a + b) * (a + b - 1) < 0' only for
 334 |     |       // 'x == 1' which is true. Hence, the requirement of 'cheapMulDiv' is
 335 |     |       // satisfied.
 336 |     |       a = FullMathLibrary.cheapMulDiv(a - b, 1 << 254, a + b) << 2;
 337 |     | 
 338 |     |       // Next, we compute 'f(f(f(f(f(f(f(f(f(f(f(f(f(f(a))))))))))))))'
 339 |     |       // where 'f(y) = (y ** 2) / (2 ** 256 - 1) ~ (y ** 2) / (2 ** 256)'
 340 |     |       // This is because of the '2 ** 14' term which was discussed before.
 341 |     |       assembly {
 342 |     |         a := sub(
 343 |     |           mulmod(a, a, not(0)), // s := a * a - q * not(0)
 344 |     |           mul(a, a) // r := a * a
 345 |     |         ) // s - r == - q * not(0) == q
 346 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 347 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 348 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 349 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 350 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 351 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 352 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 353 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 354 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 355 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 356 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 357 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 358 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 359 |     |       }
 360 |     | 
 361 |     |       return a;
 362 |     |     }
 363 |     |   }
 364 |     | 
 365 |     |   /// @notice Transforms natural logarithm of price to square root of price.
 366 |     |   /// @param value The input whose exponential to be calculated.
 367 |     |   /// @return exponentialInverse is '(2 ** 216) * exp(- x / (2 ** 60))'
 368 |     |   /// @return exponentialOverExp16 is '(2 ** 216) * exp(- 16 + x / (2 ** 60))'
 369 |     |   /// Input should be greater than 0 and less than (2 ** 64).
 370 |     |   function exp(
 371 |     |     X59 value
 372 |     |   ) internal pure returns (
 373 |     |     X216 exponentialInverse,
 374 |     |     X216 exponentialOverExp16
 375 |     |   ) {
 376 |     |     // The requirements of 'expInverse' are the same as the requirements here.
 377 |     |     uint256 a = expInverse(value);
 378 |     | 
 379 |     |     // Since '0 < value < 2 ** 64', we have
 380 |     |     // '(2 ** 256) * exp(-16) < a < (2 ** 256)', hence
 381 |     |     // '(2 ** 472) * exp(-16) < a * (a - 1)' and the requirements of
 382 |     |     // 'cheapMulDiv' are satisfied.
 383 |     |     //
 384 |     |     // Casting to 'int256' is safe because the output of 'cheapMulDiv' is
 385 |     |     // non-negative and it is less than 'oneX216'.
 386 |     |     //
 387 |     |     // So, we can calculate '(2 ** 472) * exp(-16) / a' as follows:
 388 |     |     exponentialOverExp16 = X216.wrap(int256(FullMathLibrary.cheapMulDiv(
 389 |     |       // (2 ** 279) * exp(-16)
 390 |     |       0xF1AADDD7742E56D32FB9F997447D9E6314DB84884FABAB26BF059AF9BC20B609,
 391 |     |       1 << 193,
 392 |     |       a
 393 |     |     )));
 394 |     | 
 395 |     |     // Casting to 'int256' is safe because 'a >> 40' is non-negative and it is
 396 |     |     // less than 'oneX216'.
 397 |     |     exponentialInverse = X216.wrap(int256(a >> 40));
 398 |     |   }
 399 |     | 
 400 |     |   /// @notice Transforms natural logarithm of price to square root of price.
 401 |     |   /// "Pade Approximant" is employed for this purpose:
 402 |     |   /// 'exp(- x / (2 ** 60)) ~= ((u(x) - v(x)) / (u(x) + v(x))) ** (2 ** 48)'
 403 |     |   /// where
 404 |     |   ///              x ** 2
 405 |     |   /// 'u(x) = 1 + --------'
 406 |     |   ///              3<<218
 407 |     |   /// and
 408 |     |   ///             x
 409 |     |   /// 'v(x) = --------'.
 410 |     |   ///          1<<109
 411 |     |   ///
 412 |     |   /// This formula can be reproduced via the following Mathematica command:
 413 |     |   /// 'PadeApproximant[Exp[- x / (2 ^ 108)], {x, 0, 2}]'.
 414 |     |   ///
 415 |     |   /// @param value The input whose exponential to be calculated.
 416 |     |   /// @return exponentialInverse is '(2 ** 256) * exp(- x / (2 ** 60))'
 417 |     |   /// Input should be positive and less than '2 * maxLogOffset'.
 418 |     |   function expOffset(
 419 |     |     X59 value
 420 |     |   ) internal pure returns (
 421 |     |     uint256 exponentialInverse
 422 |     |   ) {
 423 |     |     unchecked {
 424 |     |       // Casting is safe because 'value' is between '0' and '2 ** 64'.
 425 |     |       uint256 x = uint256(X59.unwrap(value));
 426 |     | 
 427 |     |       // (2 ** 255) * u(x)
 428 |     |       // The multiplication and addition are safe because 'x < 2 ** 64'.
 429 |     |       uint256 a = (((x * x) << 37) / 3) + (1 << 255);
 430 |     | 
 431 |     |       // (2 ** 255) * v(x)
 432 |     |       // The shift is safe because 'x < 2 ** 64'.
 433 |     |       x <<= 146;
 434 |     | 
 435 |     |       // The requirements of 'cheapMulDiv' are satisfied because
 436 |     |       // (a - x) * (2 ** 254) - (a + x) (a + x - 1) is a decreasing function
 437 |     |       // with respect to 'x'. Hence, we just need to verify that it is negative
 438 |     |       // for 'x == 1' which is true.
 439 |     |       a = FullMathLibrary.cheapMulDiv(a - x, 1 << 254, a + x) << 2;
 440 |     | 
 441 |     |       // Next, we apply the function 
 442 |     |       // 'f(y) = (y ** 2) / (2 ** 256 - 1) ~ (y ** 2) / (2 ** 256)', 48 times.
 443 |     |       // This is because of the '2 ** 48' term which was discussed before.
 444 |     |       assembly {
 445 |     |         a := sub(
 446 |     |           mulmod(a, a, not(0)), // s := a * a - q * not(0)
 447 |     |           mul(a, a) // r := a * a
 448 |     |         ) // s - r == - q * not(0) == q
 449 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 450 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 451 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 452 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 453 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 454 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 455 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 456 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 457 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 458 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 459 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 460 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 461 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 462 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 463 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 464 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 465 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 466 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 467 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 468 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 469 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 470 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 471 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 472 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 473 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 474 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 475 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 476 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 477 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 478 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 479 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 480 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 481 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 482 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 483 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 484 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 485 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 486 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 487 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 488 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 489 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 490 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 491 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 492 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 493 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 494 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 495 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 496 |     |       }
 497 |     | 
 498 |     |       return a;
 499 |     |     }
 500 |     |   }
 501 |     | 
 502 |     |   /// @notice Transforms natural logarithm of price in two's complement to
 503 |     |   /// square root of price.
 504 |     |   /// Input should be between 'minLogOffset' and 'maxLogOffset'.
 505 |     |   /// @param logOffset The input whose exponential to be calculated.
 506 |     |   /// @return sqrtOffset is '(2 ** 127) * exp(logOffset / (2 ** 60))'
 507 |     |   function logToSqrtOffset(
 508 |     |     X59 logOffset
 509 |     |   ) internal pure returns (
 510 |     |     X127 sqrtOffset
 511 |     |   ) {
 512 |     |     // '(2 ** 256) * exp(- (maxLogOffset - logOffset) / (2 ** 60))'
 513 |     |     // The requirements of 'expOffset' are satisfied here because:
 514 |     |     // 'minLogOffset < logOffset < maxLogOffset'
 515 |     |     // '0 < maxLogOffset - logOffset < 
 516 |     |     //      maxLogOffset - minLogOffset == 2 * maxLogOffset'.
 517 |     |     uint256 exponential = (maxLogOffset - logOffset).expOffset();
 518 |     |     // (2 ** (256 + 191)) * exp(- (maxLogOffset - logOffset) / (2 ** 60)) / 
 519 |     |     // ((2 ** 320) * exp(-45))
 520 |     |     assembly {
 521 |     |       // Let 's := exponential * (2 ** 191) - (2 ** 256) * p'
 522 |     |       // Let 'r := exponential * (2 ** 191) - floor((2 ** 320) * exp(-45)) * q'
 523 |     |       // Then 's - r == floor((2 ** 320) * exp(-45)) * q' [modulo '2 ** 256']
 524 |     |       sqrtOffset := mul(
 525 |     |         // s - r
 526 |     |         sub(
 527 |     |           // s
 528 |     |           mul(exponential, shl(191, 1)), // Because '256 + 191 - 320 == 127'
 529 |     |           // r
 530 |     |           mulmod(
 531 |     |             exponential,
 532 |     |             shl(191, 1),
 533 |     |             // floor((2 ** 320) * exp(-45))
 534 |     |             0x872DB9E8FFA9E7D41F2AAF39897B91E4002E70FCEED391471FAD73D51503772D
 535 |     |           )
 536 |     |         ),
 537 |     |         // modularInverse(floor((2 ** 320) * exp(-45)), 2 ** 256)
 538 |     |         0xCF8E41E6C4D4AA5E9CC597C10CD32EACD30C44F750A8FFDB1A8863DD8F72F0A5
 539 |     |       )
 540 |     |     }
 541 |     |   }
 542 |     | }

R:/LIAT.AI/question2-calldata/contracts/utilities/X74.sol
  1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
  2 |     | pragma solidity ^0.8.28;
  3 |     | 
  4 |     | import {X216} from "./X216.sol";
  5 |     | 
  6 |     | // Type 'X74' is used as an intermediate type when searching for precise log
  7 |     | // price movement corresponding to the specified outgoing/incoming token 
  8 |     | // amounts.
  9 |     | type X74 is int256;
 10 |     | 
 11 |     | X74 constant zeroX74 = X74.wrap(0);
 12 |     | 
 13 |     | using {equals as ==, notEqual as !=} for X74 global;
 14 |     | using {add as +, sub as -} for X74 global;
 15 |     | 
 16 |     | using X74Library for X74 global;
 17 |     | 
 18 |     | function equals(
 19 |     |   X74 value0,
 20 |     |   X74 value1
 21 |     | ) pure returns (
 22 |     |   bool result
 23 |     | ) {
 24 |     |   assembly {
 25 |     |     result := eq(value0, value1)
 26 |     |   }
 27 |     | }
 28 |     | 
 29 |     | function notEqual(
 30 |     |   X74 value0,
 31 |     |   X74 value1
 32 |     | ) pure returns (
 33 |     |   bool result
 34 |     | ) {
 35 |     |   return !(value0 == value1);
 36 |     | }
 37 |     | 
 38 |     | // Overflow/underflow should be avoided externally.
 39 |     | function add(
 40 |     |   X74 value0,
 41 |     |   X74 value1
 42 |     | ) pure returns (
 43 |     |   X74 result
 44 |     | ) {
 45 |     |   assembly {
 46 |     |     result := add(value0, value1)
 47 |     |   }
 48 |     | }
 49 |     | 
 50 |     | // Overflow/underflow should be avoided externally.
 51 |     | function sub(
 52 |     |   X74 value0,
 53 |     |   X74 value1
 54 |     | ) pure returns (
 55 |     |   X74 result
 56 |     | ) {
 57 |     |   assembly {
 58 |     |     result := sub(value0, value1)
 59 |     |   }
 60 |     | }
 61 |     | 
 62 |     | library X74Library {
 63 |     |   // Converts type 'X74' to 'X216'.
 64 |     |   // Overflow should be avoided externally.
 65 |     |   function toX216(
 66 |     |     X74 value
 67 |     |   ) internal pure returns (
 68 |     |     X216 result
 69 |     |   ) {
 70 |     |     assembly {
 71 |     |       // Multiplication is safe because overflow is avoided externally.
 72 |     |       result := mul(shl(142, 1), value)
 73 |     |     }
 74 |     |   }
 75 |     | }

R:/LIAT.AI/question2-calldata/echidna/CalldataTestIndustryGrade.sol
   1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
   2 |     | // SPDX-License-Identifier: UNLICENSED
   3 |     | pragma solidity ^0.8.28;
   4 |     | 
   5 |     | import "contracts/helpers/CalldataWrapper.sol";
   6 |     | import {
   7 |     |     _msgSender_,
   8 |     |     _poolId_,
   9 |     |     _logPriceMin_,
  10 |     |     _logPriceMax_,
  11 |     |     _logPriceMinOffsetted_,
  12 |     |     _logPriceMaxOffsetted_,
  13 |     |     _shares_,
  14 |     |     _curve_,
  15 |     |     _hookData_,
  16 |     |     _hookDataByteCount_,
  17 |     |     _hookInputByteCount_,
  18 |     |     _freeMemoryPointer_,
  19 |     |     _endOfStaticParams_,
  20 |     |     _hookInputByteCount_ as HOOK_INPUT_BYTE_COUNT_SLOT
  21 |     | } from "contracts/utilities/Memory.sol";
  22 |     | 
  23 |     | /// @title Echidna Property-Based Test for readModifyPositionInput
  24 |     | /// @notice Comprehensive fuzzing test suite that replicates Python/Brownie tests in randomized manner
  25 |     | /// @dev Tests arbitrary non-strictly encoded input with random hookdata starting positions
  26 |     | /// @dev This addresses Question 2: Property-based testing of readModifyPositionInput with
  27 |     | ///      random hookdata offsets to test calldatacopy mechanism with non-strict ABI encoding
  28 | *r  | contract CalldataTestIndustryGrade {
  29 |     | 
  30 |     |     // ========================================================================
  31 |     |     // CONSTANTS & TYPE DEFINITIONS
  32 |     |     // ========================================================================
  33 |     | 
  34 |     |     /// @notice Maximum allowed hookData byte count (uint16.max)
  35 |     |     uint256 constant MAX_HOOK_DATA_BYTE_COUNT = 0xFFFF;
  36 |     | 
  37 |     |     /// @notice Guard patterns for memory corruption detection
  38 |     |     bytes32 constant GUARD_PATTERN_1 = 0xDEADBEEFDEADBEEFDEADBEEFDEADBEEFDEADBEEFDEADBEEFDEADBEEFDEADBEEF;
  39 |     |     bytes32 constant GUARD_PATTERN_2 = 0xBADC0FFEBADC0FFEBADC0FFEBADC0FFEBADC0FFEBADC0FFEBADC0FFEBADC0FFE;
  40 |     |     bytes32 constant GUARD_PATTERN_3 = 0xCAFEBABECAFEBABECAFEBABECAFEBABECAFEBABECAFEBABECAFEBABECAFEBABE;
  41 |     | 
  42 |     |     /// @notice Fixed-point constants for log price calculations (X59 format)
  43 | *   |     uint256 constant ONE_X59 = 1 << 59;
  44 |     |     uint256 constant SIXTEEN_X59 = 16 * ONE_X59;
  45 | *   |     uint256 constant THIRTY_TWO_X59 = 32 * ONE_X59;
  46 |     |     uint256 constant ONE_X63 = 1 << 63;
  47 |     | 
  48 |     |     /// @notice Valid ranges for shares parameter
  49 | *   |     int256 constant MAX_INT128 = type(int128).max;
  50 | *   |     int256 constant MIN_INT128 = -MAX_INT128; // Note: not type(int128).min, as per contract logic
  51 |     | 
  52 |     |     /// @notice CalldataWrapper contract instance
  53 |     |     CalldataWrapper public wrapper;
  54 |     | 
  55 |     |     /// @notice Function selector for _readModifyPositionInput()
  56 | *   |     bytes4 constant READ_MODIFY_POSITION_SELECTOR = CalldataWrapper._readModifyPositionInput.selector;
  57 |     | 
  58 |     |     // ========================================================================
  59 |     |     // STATE VARIABLES FOR TRACKING
  60 |     |     // ========================================================================
  61 |     | 
  62 | *   |     uint256 public testsExecuted;
  63 | *   |     uint256 public totalGasConsumed;
  64 | *   |     uint256 public maxGasObserved;
  65 |     | 
  66 |     |     // ========================================================================
  67 |     |     // CONSTRUCTOR
  68 |     |     // ========================================================================
  69 |     | 
  70 |     |     constructor() {
  71 | *   |         wrapper = new CalldataWrapper();
  72 |     |         testsExecuted = 0;
  73 | *   |         totalGasConsumed = 0;
  74 | *   |         maxGasObserved = 0;
  75 |     |     }
  76 |     | 
  77 |     |     // ========================================================================
  78 |     |     // HELPER FUNCTIONS
  79 |     |     // ========================================================================
  80 |     | 
  81 |     |     /// @notice Extracts qOffset (8-bit signed) from poolId at bits [180:187]
  82 |     |     /// @param poolId The pool identifier (256 bits)
  83 |     |     /// @return qOffset The extracted offset as int8 (-128 to +127)
  84 | *   |     function extractQOffset(uint256 poolId) internal pure returns (int8 qOffset) {
  85 | *   |         uint8 unsignedOffset = uint8((poolId >> 180) & 0xFF);
  86 | *   |         if (unsignedOffset >= 128) {
  87 |     |             qOffset = int8(int256(uint256(unsignedOffset)) - 256);
  88 |     |         } else {
  89 |     |             qOffset = int8(int256(uint256(unsignedOffset)));
  90 |     |         }
  91 |     |     }
  92 |     | 
  93 |     |     /// @notice Converts int256 to two's complement uint256 representation
  94 | *   |     function toTwosComplement(int256 value) internal pure returns (uint256 result) {
  95 | *   |         if (value >= 0) {
  96 |     |             result = uint256(value);
  97 |     |         } else {
  98 |     |             unchecked {
  99 |     |                 result = uint256(type(uint256).max) + uint256(value) + 1;
 100 |     |             }
 101 |     |         }
 102 |     |     }
 103 |     | 
 104 |     |     /// @notice Calculates adjusted logPrice from normalized q and poolId offset
 105 |     |     /// @dev Formula: logPrice = q + (qOffset * 2^59) - 2^63
 106 | *   |     function calculateLogPrice(uint64 q, int8 qOffset) internal pure returns (int256) {
 107 |     |         int256 shift;
 108 | *   |         if (qOffset >= 0) {
 109 | *   |             shift = int256(uint256(int256(qOffset))) * int256(ONE_X59) - int256(ONE_X63);
 110 |     |         } else {
 111 | *   |             shift = -int256(uint256(int256(-qOffset))) * int256(ONE_X59) - int256(ONE_X63);
 112 |     |         }
 113 |     |         return int256(uint256(q)) + shift;
 114 |     |     }
 115 |     | 
 116 |     |     /// @notice Constructs calldata with RANDOM hookdata offset (non-strict encoding)
 117 |     |     /// @dev This is the KEY REQUIREMENT: Testing arbitrary non-strictly encoded input
 118 |     |     ///      by starting hookdata content from a random place in calldata
 119 |     |     /// @param poolId Pool identifier
 120 |     |     /// @param logPriceMin Minimum log price (adjusted)
 121 |     |     /// @param logPriceMax Maximum log price (adjusted)
 122 |     |     /// @param shares Number of shares (int256, bounded to int128 range)
 123 |     |     /// @param hookDataContent Content pattern to fill hookData
 124 |     |     /// @param hookDataByteCount Size of hookData in bytes
 125 |     |     /// @param randomGap Random gap between static params and hookdata (0-1000 bytes)
 126 |     |     /// @param randomContentStart Random starting offset within content pattern (0-31 bytes)
 127 |     |     /// @return calldataBytes The constructed calldata with random offsets
 128 | *   |     function constructCalldata(
 129 |     |         uint256 poolId,
 130 |     |         int256 logPriceMin,
 131 |     |         int256 logPriceMax,
 132 |     |         int256 shares,
 133 |     |         uint256 hookDataContent,
 134 |     |         uint16 hookDataByteCount,
 135 |     |         uint16 randomGap,
 136 |     |         uint8 randomContentStart
 137 |     |     ) internal pure returns (bytes memory calldataBytes) {
 138 |     |         // Limit randomGap to reasonable size (0-1000 bytes) for test performance
 139 | *   |         randomGap = uint16(uint256(randomGap) % 1001);
 140 |     | 
 141 |     |         // Limit randomContentStart to 0-31 (byte offset within a 32-byte word)
 142 | *   |         randomContentStart = uint8(uint256(randomContentStart) % 32);
 143 |     | 
 144 |     |         // Calculate hookdata starting position with RANDOM offset
 145 |     |         // This tests the calldatacopy mechanism with non-standard ABI encoding
 146 | *   |         uint256 startOfHookData = 5 * 0x20 + randomGap;
 147 |     | 
 148 |     |         // Build hookDataBytes array with randomized content start
 149 | *   |         bytes memory hookDataBytes;
 150 | *   |         if (hookDataByteCount > 0) {
 151 | *   |             uint256 numSlots = (hookDataByteCount + 31) / 32;
 152 | *   |             hookDataBytes = new bytes(32 + hookDataByteCount);
 153 |     | 
 154 |     |             // Write length in first slot
 155 | *   |             assembly {
 156 |     |                 mstore(add(hookDataBytes, 32), hookDataByteCount)
 157 |     |             }
 158 |     | 
 159 |     |             // Fill content with ROTATION based on randomContentStart
 160 |     |             // This ensures we test non-strictly encoded hookdata content
 161 | *   |             for (uint256 i = 0; i < numSlots; i++) {
 162 | *   |                 uint256 offset = 64 + i * 32;
 163 | *   |                 if (offset <= hookDataBytes.length) {
 164 |     |                     // Rotate content based on random offset
 165 |     |                     uint256 rotatedContent;
 166 | *   |                     if (randomContentStart == 0) {
 167 | *   |                         rotatedContent = hookDataContent;
 168 |     |                     } else {
 169 | *   |                         uint256 leftShift = randomContentStart * 8;
 170 | *   |                         uint256 rightShift = (32 - randomContentStart) * 8;
 171 | *   |                         rotatedContent = (hookDataContent << leftShift) | (hookDataContent >> rightShift);
 172 |     |                     }
 173 | *   |                     assembly {
 174 |     |                         mstore(add(hookDataBytes, offset), rotatedContent)
 175 |     |                     }
 176 |     |                 }
 177 |     |             }
 178 |     |         } else {
 179 | *   |             hookDataBytes = new bytes(32);
 180 | *   |             assembly {
 181 |     |                 mstore(add(hookDataBytes, 32), 0)
 182 |     |             }
 183 |     |         }
 184 |     | 
 185 |     |         // Construct full calldata with RANDOM gap (non-strict encoding)
 186 | *   |         calldataBytes = abi.encodePacked(
 187 |     |             READ_MODIFY_POSITION_SELECTOR,
 188 |     |             bytes32(poolId),
 189 | *   |             bytes32(toTwosComplement(logPriceMin)),
 190 | *   |             bytes32(toTwosComplement(logPriceMax)),
 191 | *   |             bytes32(toTwosComplement(shares)),
 192 |     |             bytes32(startOfHookData),    // Pointer to hookdata (with random gap)
 193 | *   |             new bytes(randomGap),         // RANDOM GAP - key for non-strict encoding test
 194 |     |             hookDataBytes
 195 |     |         );
 196 |     |     }
 197 |     | 
 198 |     |     // ========================================================================
 199 |     |     // PROPERTY TESTS
 200 |     |     // ========================================================================
 201 |     | 
 202 |     |     /// @notice PROPERTY 1: Correctness with random hookdata offset (non-strict encoding)
 203 |     |     /// @dev Replicates test_readModifyPositionInput from Python tests but fully randomized
 204 |     |     /// @dev KEY: Tests arbitrary non-strictly encoded input by using random gaps and content starts
 205 |     |     /// @param poolId Pool identifier (256 bits, qOffset extracted from bits [180:187])
 206 |     |     /// @param qMin Normalized minimum log price (must be 0 < qMin < 2^64)
 207 |     |     /// @param qMax Normalized maximum log price (must be 0 < qMax < 2^64)
 208 |     |     /// @param shares Number of shares (bounded to ±int128.max range, != 0)
 209 |     |     /// @param hookDataContent Content pattern for filling hookData (256 bits)
 210 |     |     /// @param hookDataByteCount Size of hookData (0 to 1000 for performance)
 211 |     |     /// @param randomGap RANDOM gap size for non-strict encoding test (0-1000)
 212 |     |     /// @param randomContentStart RANDOM starting offset in hookdata content (0-31)
 213 |     |     function test_property_readModifyPositionInput_correctness(
 214 |     |         uint256 poolId,
 215 |     |         uint64 qMin,
 216 |     |         uint64 qMax,
 217 |     |         int256 shares,
 218 |     |         uint256 hookDataContent,
 219 |     |         uint16 hookDataByteCount,
 220 |     |         uint16 randomGap,
 221 |     |         uint8 randomContentStart
 222 |     |     ) public {
 223 |     |         // === INPUT NORMALIZATION ===
 224 |     |         // Limit hookDataByteCount for test performance (full range tested separately)
 225 | *   |         if (hookDataByteCount > 1000) hookDataByteCount = uint16(uint256(hookDataByteCount) % 1001);
 226 |     | 
 227 |     |         // Ensure qMin in valid range: 0 < qMin < THIRTY_TWO_X59 (32 * 2^59)
 228 | *   |         if (qMin == 0) qMin = 1;
 229 | *   |         if (qMin >= THIRTY_TWO_X59) qMin = uint64(1 + (uint256(qMin) % (THIRTY_TWO_X59 - 1)));
 230 |     | 
 231 |     |         // Ensure qMax in valid range: 0 < qMax < THIRTY_TWO_X59
 232 | *   |         if (qMax == 0) qMax = 1;
 233 | *   |         if (qMax >= THIRTY_TWO_X59) qMax = uint64(1 + (uint256(qMax) % (THIRTY_TWO_X59 - 1)));
 234 |     | 
 235 |     |         // Ensure shares in valid range: MIN_INT128 <= shares <= MAX_INT128, shares != 0
 236 | *   |         if (shares > MAX_INT128) shares = int256(1 + (uint256(shares) % uint256(MAX_INT128)));
 237 | *   |         if (shares < MIN_INT128) {
 238 |     |             unchecked {
 239 | *   |                 shares = -int256(1 + (uint256(-shares) % uint256(MAX_INT128)));
 240 |     |             }
 241 |     |         }
 242 | *   |         if (shares == 0) shares = 1;
 243 |     | 
 244 |     |         // Extract qOffset from poolId
 245 | *   |         int8 qOffset = extractQOffset(poolId);
 246 |     | 
 247 |     |         // Calculate adjusted log prices
 248 | *   |         int256 logPriceMin = calculateLogPrice(qMin, qOffset);
 249 | *   |         int256 logPriceMax = calculateLogPrice(qMax, qOffset);
 250 |     | 
 251 |     |         // === MEMORY GUARDS ===
 252 |     |         bytes32 guard1Before = GUARD_PATTERN_1;
 253 |     |         bytes32 guard2Before = GUARD_PATTERN_2;
 254 |     |         bytes32 guard3Before = GUARD_PATTERN_3;
 255 |     | 
 256 |     |         // === CONSTRUCT CALLDATA WITH RANDOM OFFSETS ===
 257 | *   |         bytes memory calldataBytes = constructCalldata(
 258 |     |             poolId,
 259 |     |             logPriceMin,
 260 |     |             logPriceMax,
 261 |     |             shares,
 262 |     |             hookDataContent,
 263 |     |             hookDataByteCount,
 264 |     |             randomGap,
 265 |     |             randomContentStart
 266 |     |         );
 267 |     | 
 268 |     |         // === EXECUTE FUNCTION ===
 269 | *   |         uint256 gasBefore = gasleft();
 270 | *   |         (bool success, ) = address(wrapper).call(calldataBytes);
 271 | *   |         uint256 gasUsed = gasBefore - gasleft();
 272 |     | 
 273 |     |         // Track metrics
 274 | *   |         totalGasConsumed += gasUsed;
 275 | *   |         if (gasUsed > maxGasObserved) maxGasObserved = gasUsed;
 276 | *   |         testsExecuted++;
 277 |     | 
 278 |     |         // === ASSERTIONS ===
 279 |     |         // Property: Valid inputs with arbitrary non-strict encoding must succeed
 280 | *   |         assert(success);
 281 |     | 
 282 |     |         // Property: Memory guards must remain intact (no corruption)
 283 |     |         assert(guard1Before == GUARD_PATTERN_1);
 284 |     |         assert(guard2Before == GUARD_PATTERN_2);
 285 |     |         assert(guard3Before == GUARD_PATTERN_3);
 286 |     |     }
 287 |     | 
 288 |     |     /// @notice PROPERTY 2: Invalid log prices must revert
 289 |     |     /// @dev Replicates test_readModifyPositionInputInvalidLogPrices
 290 |     |     /// @param poolId Pool identifier
 291 |     |     /// @param useZeroQMin If true, use qMin=0; else use qMin >= THIRTY_TWO_X59
 292 |     |     /// @param shares Number of shares
 293 |     |     /// @param hookDataByteCount Size of hookData
 294 |     |     function test_property_invalid_logprices_revert(
 295 |     |         uint256 poolId,
 296 |     |         bool useZeroQMin,
 297 |     |         int256 shares,
 298 |     |         uint16 hookDataByteCount
 299 |     |     ) public {
 300 | *   |         if (hookDataByteCount > 100) hookDataByteCount = uint16(uint256(hookDataByteCount) % 101);
 301 | *   |         if (shares > MAX_INT128) shares = int256(1 + (uint256(shares) % uint256(MAX_INT128)));
 302 | *   |         if (shares < MIN_INT128) {
 303 |     |             unchecked {
 304 |     |                 shares = -int256(1 + (uint256(-shares) % uint256(MAX_INT128)));
 305 |     |             }
 306 |     |         }
 307 | *   |         if (shares == 0) shares = 1;
 308 |     | 
 309 |     |         // Use INVALID qMin (either 0 or >= THIRTY_TWO_X59)
 310 | *   |         uint64 qMin = useZeroQMin ? 0 : uint64(THIRTY_TWO_X59);
 311 |     |         uint64 qMax = 100; // Valid value
 312 |     | 
 313 | *   |         int8 qOffset = extractQOffset(poolId);
 314 | *   |         int256 logPriceMin = calculateLogPrice(qMin, qOffset);
 315 | *   |         int256 logPriceMax = calculateLogPrice(qMax, qOffset);
 316 |     | 
 317 | *   |         bytes memory calldataBytes = constructCalldata(
 318 |     |             poolId,
 319 |     |             logPriceMin,
 320 |     |             logPriceMax,
 321 |     |             shares,
 322 |     |             0,
 323 |     |             hookDataByteCount,
 324 |     |             0,
 325 |     |             0
 326 |     |         );
 327 |     | 
 328 | *   |         (bool success, ) = address(wrapper).call(calldataBytes);
 329 |     | 
 330 |     |         // Property: Invalid log prices MUST cause revert
 331 | *   |         assert(!success);
 332 |     | 
 333 | *   |         testsExecuted++;
 334 |     |     }
 335 |     | 
 336 |     |     /// @notice PROPERTY 3: Invalid shares must revert
 337 |     |     /// @dev Replicates test_readModifyPositionInputInvalidShares
 338 |     |     /// @param poolId Pool identifier
 339 |     |     /// @param invalidCase 0=zero, 1=too large, 2=too small
 340 |     |     /// @param hookDataByteCount Size of hookData
 341 |     |     function test_property_invalid_shares_revert(
 342 |     |         uint256 poolId,
 343 |     |         uint8 invalidCase,
 344 |     |         uint16 hookDataByteCount
 345 |     |     ) public {
 346 | *   |         if (hookDataByteCount > 100) hookDataByteCount = uint16(uint256(hookDataByteCount) % 101);
 347 |     | 
 348 |     |         uint64 qMin = 100;
 349 |     |         uint64 qMax = 200;
 350 |     | 
 351 | *   |         int8 qOffset = extractQOffset(poolId);
 352 | *   |         int256 logPriceMin = calculateLogPrice(qMin, qOffset);
 353 | *   |         int256 logPriceMax = calculateLogPrice(qMax, qOffset);
 354 |     | 
 355 |     |         // Choose INVALID shares based on case
 356 | *   |         int256 shares;
 357 | *   |         uint8 caseType = invalidCase % 3;
 358 | *   |         if (caseType == 0) {
 359 | *   |             shares = 0; // Zero shares (invalid)
 360 | *   |         } else if (caseType == 1) {
 361 |     |             shares = MAX_INT128 + 1; // Too large
 362 |     |         } else {
 363 | *   |             shares = MIN_INT128 - 1; // Too small
 364 |     |         }
 365 |     | 
 366 | *   |         bytes memory calldataBytes = constructCalldata(
 367 |     |             poolId,
 368 |     |             logPriceMin,
 369 |     |             logPriceMax,
 370 |     |             shares,
 371 |     |             0,
 372 |     |             hookDataByteCount,
 373 |     |             0,
 374 |     |             0
 375 |     |         );
 376 |     | 
 377 |     |         (bool success, ) = address(wrapper).call(calldataBytes);
 378 |     | 
 379 |     |         // Property: Invalid shares MUST cause revert
 380 | *   |         assert(!success);
 381 |     | 
 382 |     |         testsExecuted++;
 383 |     |     }
 384 |     | 
 385 |     |     /// @notice PROPERTY 4: Oversized hookData must revert
 386 |     |     /// @dev Replicates test_readModifyPositionInputHookDataTooLong
 387 |     |     /// @param poolId Pool identifier
 388 |     |     /// @param shares Number of shares
 389 |     |     function test_property_hookdata_too_long_revert(
 390 |     |         uint256 poolId,
 391 |     |         int256 shares
 392 |     |     ) public {
 393 | *   |         if (shares > MAX_INT128) shares = int256(1 + (uint256(shares) % uint256(MAX_INT128)));
 394 | *   |         if (shares < MIN_INT128) {
 395 |     |             unchecked {
 396 |     |                 shares = -int256(1 + (uint256(-shares) % uint256(MAX_INT128)));
 397 |     |             }
 398 |     |         }
 399 | *   |         if (shares == 0) shares = 1;
 400 |     | 
 401 | *   |         uint64 qMin = 100;
 402 |     |         uint64 qMax = 200;
 403 |     | 
 404 | *   |         int8 qOffset = extractQOffset(poolId);
 405 | *   |         int256 logPriceMin = calculateLogPrice(qMin, qOffset);
 406 | *   |         int256 logPriceMax = calculateLogPrice(qMax, qOffset);
 407 |     | 
 408 |     |         // Use hookDataByteCount > uint16.max (MAX_HOOK_DATA_BYTE_COUNT)
 409 | *   |         uint256 invalidHookDataSize = uint256(MAX_HOOK_DATA_BYTE_COUNT) + 1;
 410 |     | 
 411 |     |         // Manually construct calldata with oversized hookdata length
 412 | *   |         bytes memory calldataBytes = abi.encodePacked(
 413 |     |             READ_MODIFY_POSITION_SELECTOR,
 414 |     |             bytes32(poolId),
 415 | *   |             bytes32(toTwosComplement(logPriceMin)),
 416 | *   |             bytes32(toTwosComplement(logPriceMax)),
 417 | *   |             bytes32(toTwosComplement(shares)),
 418 | *   |             bytes32(uint256(5 * 0x20)),           // startOfHookData
 419 |     |             bytes32(invalidHookDataSize), // INVALID size > uint16.max
 420 | *   |             new bytes(100)               // Some content
 421 |     |         );
 422 |     | 
 423 | *   |         (bool success, ) = address(wrapper).call(calldataBytes);
 424 |     | 
 425 |     |         // Property: Oversized hookData MUST cause revert
 426 | *   |         assert(!success);
 427 |     | 
 428 |     |         testsExecuted++;
 429 |     |     }
 430 |     | 
 431 |     |     /// @notice PROPERTY 5: Encoding independence (different gaps, same result)
 432 |     |     /// @dev Tests that same logical data with different random gaps produces same outcome
 433 |     |     /// @dev This is CRITICAL for non-strict encoding requirement
 434 |     |     /// @param poolId Pool identifier
 435 |     |     /// @param qMin Normalized minimum log price
 436 |     |     /// @param qMax Normalized maximum log price
 437 |     |     /// @param shares Number of shares
 438 |     |     /// @param hookDataContent Content for hookData
 439 |     |     /// @param hookDataByteCount Size of hookData
 440 |     |     /// @param randomGap1 First random gap
 441 |     |     /// @param randomGap2 Second random gap (different)
 442 |     |     function test_property_encoding_independence(
 443 |     |         uint256 poolId,
 444 |     |         uint64 qMin,
 445 |     |         uint64 qMax,
 446 |     |         int256 shares,
 447 |     |         uint256 hookDataContent,
 448 |     |         uint16 hookDataByteCount,
 449 |     |         uint16 randomGap1,
 450 |     |         uint16 randomGap2
 451 |     |     ) public {
 452 |     |         // === INPUT NORMALIZATION ===
 453 | *   |         if (hookDataByteCount > 100) hookDataByteCount = uint16(uint256(hookDataByteCount) % 101);
 454 | *   |         if (qMin == 0) qMin = 1;
 455 | *   |         if (qMax == 0) qMax = 1;
 456 | *   |         if (qMin >= THIRTY_TWO_X59) qMin = uint64(1 + (uint256(qMin) % (THIRTY_TWO_X59 - 1)));
 457 | *   |         if (qMax >= THIRTY_TWO_X59) qMax = uint64(1 + (uint256(qMax) % (THIRTY_TWO_X59 - 1)));
 458 | *   |         if (shares > MAX_INT128) shares = int256(1 + (uint256(shares) % uint256(MAX_INT128)));
 459 | *   |         if (shares < MIN_INT128) {
 460 |     |             unchecked {
 461 |     |                 shares = -int256(1 + (uint256(-shares) % uint256(MAX_INT128)));
 462 |     |             }
 463 |     |         }
 464 | *   |         if (shares == 0) shares = 1;
 465 |     | 
 466 | *   |         int8 qOffset = extractQOffset(poolId);
 467 | *   |         int256 logPriceMin = calculateLogPrice(qMin, qOffset);
 468 | *   |         int256 logPriceMax = calculateLogPrice(qMax, qOffset);
 469 |     | 
 470 |     |         // === EXECUTE WITH FIRST RANDOM ENCODING ===
 471 | *   |         bytes memory calldata1 = constructCalldata(
 472 |     |             poolId, logPriceMin, logPriceMax, shares,
 473 |     |             hookDataContent, hookDataByteCount, randomGap1, 0
 474 |     |         );
 475 | *   |         (bool success1, ) = address(wrapper).call(calldata1);
 476 |     | 
 477 |     |         // === EXECUTE WITH SECOND RANDOM ENCODING ===
 478 | *   |         bytes memory calldata2 = constructCalldata(
 479 |     |             poolId, logPriceMin, logPriceMax, shares,
 480 |     |             hookDataContent, hookDataByteCount, randomGap2, 0
 481 |     |         );
 482 | *   |         (bool success2, ) = address(wrapper).call(calldata2);
 483 |     | 
 484 |     |         // Property: Different encodings of same logical data should have same outcome
 485 | *   |         assert(success1 == success2);
 486 |     | 
 487 |     |         testsExecuted++;
 488 |     |     }
 489 |     | 
 490 |     |     /// @notice PROPERTY 6: Extreme hookdata sizes
 491 |     |     /// @dev Tests boundary conditions for hookDataByteCount
 492 |     |     /// @param poolId Pool identifier
 493 |     |     /// @param shares Number of shares
 494 |     |     /// @param extremeCase 0=size 0, 1=size 1, 2=size MAX-1, 3=size MAX
 495 |     |     /// @param randomGap Random gap for non-strict encoding
 496 |     |     function test_property_extreme_hookdata_sizes(
 497 |     |         uint256 poolId,
 498 |     |         int256 shares,
 499 |     |         uint8 extremeCase,
 500 |     |         uint16 randomGap
 501 |     |     ) public {
 502 | *   |         if (shares > MAX_INT128) shares = int256(1 + (uint256(shares) % uint256(MAX_INT128)));
 503 | *   |         if (shares < MIN_INT128) {
 504 |     |             unchecked {
 505 | *   |                 shares = -int256(1 + (uint256(-shares) % uint256(MAX_INT128)));
 506 |     |             }
 507 |     |         }
 508 | *   |         if (shares == 0) shares = 1;
 509 |     | 
 510 |     |         uint64 qMin = 100;
 511 |     |         uint64 qMax = 200;
 512 |     | 
 513 | *   |         int8 qOffset = extractQOffset(poolId);
 514 | *   |         int256 logPriceMin = calculateLogPrice(qMin, qOffset);
 515 | *   |         int256 logPriceMax = calculateLogPrice(qMax, qOffset);
 516 |     | 
 517 |     |         // Choose extreme hookDataByteCount
 518 | *   |         uint16 hookDataByteCount;
 519 | *   |         uint8 caseType = extremeCase % 4;
 520 | *   |         if (caseType == 0) {
 521 | *   |             hookDataByteCount = 0; // Minimum
 522 | *   |         } else if (caseType == 1) {
 523 | *   |             hookDataByteCount = 1; // Single byte
 524 | *   |         } else if (caseType == 2) {
 525 |     |             hookDataByteCount = uint16(MAX_HOOK_DATA_BYTE_COUNT - 1); // Near maximum
 526 |     |         } else {
 527 |     |             hookDataByteCount = uint16(MAX_HOOK_DATA_BYTE_COUNT); // Maximum
 528 |     |         }
 529 |     | 
 530 | *   |         bytes memory calldataBytes = constructCalldata(
 531 |     |             poolId,
 532 |     |             logPriceMin,
 533 |     |             logPriceMax,
 534 |     |             shares,
 535 |     |             0xF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00F,
 536 |     |             hookDataByteCount,
 537 |     |             randomGap,
 538 |     |             0
 539 |     |         );
 540 |     | 
 541 |     |         uint256 gasBefore = gasleft();
 542 |     |         (bool success, ) = address(wrapper).call(calldataBytes);
 543 |     |         uint256 gasUsed = gasBefore - gasleft();
 544 |     | 
 545 |     |         // Track metrics
 546 |     |         totalGasConsumed += gasUsed;
 547 |     |         if (gasUsed > maxGasObserved) maxGasObserved = gasUsed;
 548 |     |         testsExecuted++;
 549 |     | 
 550 |     |         // Property: All extreme sizes within valid range must succeed
 551 | *   |         assert(success);
 552 |     |     }
 553 |     | 
 554 |     |     // ========================================================================
 555 |     |     // INVARIANT CHECKS
 556 |     |     // ========================================================================
 557 |     | 
 558 |     |     /// @notice Invariant: Tests executed counter only increases
 559 |     |     function echidna_tests_executed_increases() public view returns (bool) {
 560 |     |         return true;
 561 |     |     }
 562 |     | 
 563 |     |     /// @notice Invariant: Average gas consumption is reasonable
 564 |     |     function echidna_reasonable_gas_consumption() public view returns (bool) {
 565 |     |         if (testsExecuted == 0) return true;
 566 |     |         uint256 avgGas = totalGasConsumed / testsExecuted;
 567 |     |         return avgGas < 10_000_000;
 568 |     |     }
 569 |     | 
 570 |     |     /// @notice Invariant: Maximum gas observed is within expected bounds
 571 |     |     function echidna_max_gas_reasonable() public view returns (bool) {
 572 |     |         return maxGasObserved < 50_000_000;
 573 |     |     }
 574 |     | }

