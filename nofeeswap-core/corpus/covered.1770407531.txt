R:/LIAT.AI/nofeeswap-core/contracts/utilities/Errors.sol
   1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
   2 |     | pragma solidity ^0.8.28;
   3 |     | 
   4 |     | import {Index} from "./Index.sol";
   5 |     | import {X15} from "./X15.sol";
   6 |     | import {X47} from "./X47.sol";
   7 |     | import {X59} from "./X59.sol";
   8 |     | import {X111} from "./X111.sol";
   9 |     | import {X127} from "./X127.sol";
  10 |     | import {X208} from "./X208.sol";
  11 |     | import {X216} from "./X216.sol";
  12 |     | import {Tag} from "./Tag.sol";
  13 |     | 
  14 |     | /// @notice Thrown in case of overflow when attempting to calculate
  15 |     | /// '(a * b) / denominator'.
  16 |     | error MulDivOverflow(uint256 a, uint256 b, uint256 denominator);
  17 |     | 
  18 |     | /// @notice Thrown in case of overflow or underflow when attempting to
  19 |     | /// calculate 'a + b'.
  20 |     | error SafeAddFailed(X127 a, X127 b);
  21 |     | 
  22 |     | /// @notice Thrown when balance exceeds 'type(uint128).max'.
  23 |     | error BalanceOverflow(uint256 balance);
  24 |     | 
  25 |     | /// @notice Thrown when safe cast into an int256 overflows.
  26 |     | error SafeCastOverflow(uint256 value);
  27 |     | 
  28 |     | /// @notice Thrown when the given 'qSpacing' is less than 'minLogSpacing'.
  29 |     | error LogSpacingIsTooSmall(X59 qSpacing);
  30 |     | 
  31 |     | /// @notice Thrown when attempting to initialize a curve sequence on blank
  32 |     | /// intervals.
  33 |     | error BlankIntervalsShouldBeAvoided(X59 qLower, X59 qUpper);
  34 |     | 
  35 |     | /// @notice Thrown when 'curveLength' is zero upon initialization.
  36 |     | error CurveLengthIsZero();
  37 |     | 
  38 |     | /// @notice Each member of the curve sequence should be in-between the
  39 |     | /// preceding two members. Thrown when a given initial curve sequence violates
  40 |     | /// this rule.
  41 |     | error InvalidCurveArrangement(X59 q0, X59 q1, X59 q2);
  42 |     | 
  43 |     | /// @notice Thrown when 'curveLength' is out of range.
  44 |     | error CurveIndexOutOfRange(Index length);
  45 |     | 
  46 |     | /// @notice Thrown in case of overflow when attempting to calculate 
  47 |     | ///
  48 |     | /// 'amount := ceiling(
  49 |     | ///
  50 |     | ///     shares *
  51 |     | ///
  52 |     | ///     (getZeroForOne() ? sqrtOffset : sqrtInverseOffset) * 
  53 |     | ///
  54 |     | ///      multiplier
  55 |     | ///     ------------
  56 |     | ///       2 ** 208
  57 |     | ///  )'.
  58 |     | error SafeOutOfRangeAmountOverflow(
  59 |     |   X127 sqrtOffsetOrSqrtInverseOffset,
  60 |     |   X208 growthMultiplier,
  61 |     |   int256 shares
  62 |     | );
  63 |     | 
  64 |     | /// @notice Thrown in case of overflow when attempting to calculate 
  65 |     | ///
  66 |     | /// 'amount := ceiling(
  67 |     | ///
  68 |     | ///     (zeroOrOne ? sqrtOffset : sqrtInverseOffset) * 
  69 |     | ///
  70 |     | ///      liquidity      integral
  71 |     | ///     ----------- * -------------
  72 |     | ///       2 ** 111     outgoingMax
  73 |     | ///  )'.
  74 |     | error SafeInRangeAmountOverflow(
  75 |     |   X127 sqrtOffsetOrSqrtInverseOffset,
  76 |     |   X216 integral,
  77 |     |   X111 liquidity,
  78 |     |   X216 outgoingMax,
  79 |     |   uint256 outgoingMaxModularInverse
  80 |     | );
  81 |     | 
  82 |     | /// @notice Thrown when the second horizontal coordinate of a given kernel is
  83 |     | /// '0'. In this case, we have a vertical jump at the origin which limits
  84 |     | /// liquidity growth.
  85 |     | error SecondHorizontalCoordinateIsZero();
  86 |     | 
  87 |     | /// @notice The horizontal coordinates should be monotonically non-decreasing.
  88 |     | error NonMonotonicHorizontalCoordinates(X59 q_i, X59 q_j);
  89 |     | 
  90 |     | /// @notice The vertical coordinates should be monotonically non-decreasing.
  91 |     | error NonMonotonicVerticalCoordinates(X15 c_i, X15 c_j);
  92 |     | 
  93 |     | /// @notice There should not be repetitive points.
  94 |     | error RepetitiveKernelPoints(X15 c_i, X59 q_i);
  95 |     | 
  96 |     | /// @notice Thrown when the horizontal coordinates of a non-vertical and 
  97 |     | /// non-horizontal segment are closer than '2 ** 32'.
  98 |     | error SlopeTooHigh(X59 q_i, X59 q_j);
  99 |     | 
 100 |     | /// @notice Thrown when the horizontal coordinates of a given 'kernelCompact'
 101 |     | /// exceeds 'qSpacing'.
 102 |     | error HorizontalCoordinatesMayNotExceedLogSpacing(X59 q_j, X59 qSpacing);
 103 |     | 
 104 |     | /// @notice There should not be three repetitive horizontal coordinates. A 
 105 |     | /// vertical jump (i.e., discontinuity) is permitted and can be constructed
 106 |     | /// via two repetitive horizontal coordinates. However, three repetitive
 107 |     | /// horizontal coordinates are always redundant and should be avoided.
 108 |     | error RepetitiveHorizontalCoordinates(X59 q_i);
 109 |     | 
 110 |     | /// @notice There should not be three repetitive vertical coordinates. A 
 111 |     | /// horizontal segment (i.e., constant range) is permitted and can be 
 112 |     | /// constructed via two repetitive vertical coordinates. However, three
 113 |     | /// repetitive vertical coordinates are always redundant and should be
 114 |     | /// avoided.
 115 |     | error RepetitiveVerticalCoordinates(X15 c_i);
 116 |     | 
 117 |     | /// @notice Thrown when 'kernelLength' is out of range.
 118 |     | error KernelIndexOutOfRange(Index length);
 119 |     | 
 120 |     | /// @notice The last vertical coordinate should be equal to 'oneX15'.
 121 |     | error LastVerticalCoordinateMismatch(X15 c_j);
 122 |     | 
 123 |     | /// @notice Thrown when growth exceeds maximum permitted value of 'maxGrowth'.
 124 |     | error GrowthOverflow();
 125 |     | 
 126 |     | /// @notice Thrown when accrued growth portion values exceed '2 ** 104 - 1'.
 127 |     | error AccruedGrowthPortionOverflow(X127 accruedValue);
 128 |     | 
 129 |     | /// @notice Thrown when given flags are invalid or not consistent with hook.
 130 |     | error InvalidFlags(uint256);
 131 |     | 
 132 |     | /// @notice Thrown when the numerical search for outgoing target fails which 
 133 |     | /// should never heappen.
 134 |     | error SearchingForOutgoingTargetFailed();
 135 |     | 
 136 |     | /// @notice Thrown when the numerical search for incoming target fails which
 137 |     | /// should never heappen.
 138 |     | error SearchingForIncomingTargetFailed();
 139 |     | 
 140 |     | /// @notice Thrown when the numerical search for overshoot fails which should
 141 |     | /// never heappen.
 142 |     | error SearchingForOvershootFailed();
 143 |     | 
 144 |     | /// @notice Thrown if attempting to unlock the protocol while already unlocked.
 145 |     | error AlreadyUnlocked(address currentCaller);
 146 |     | 
 147 |     | /// @notice Thrown when any of the following methods are invoked prior to the
 148 |     | /// protocol being unlocked:
 149 |     | ///
 150 |     | ///   'INofeeswap.clear'
 151 |     | ///   'INofeeswap.take'
 152 |     | ///   'INofeeswap.settle'
 153 |     | ///   'INofeeswap.transferTransientBalanceFrom'
 154 |     | ///   'INofeeswap.modifyBalance'
 155 |     | ///   'INofeeswap.swap'
 156 |     | ///   'INofeeswapDelegatee.modifyPosition'
 157 |     | ///   'INofeeswapDelegatee.donate'
 158 |     | ///
 159 |     | error ProtocolIsLocked();
 160 |     | 
 161 |     | /// @notice Thrown when attempting to perform the following operations on a 
 162 |     | /// pool which is locked:
 163 |     | ///
 164 |     | ///   'INofeeswap.swap'
 165 |     | ///   'INofeeswapDelegatee.modifyPosition'
 166 |     | ///   'INofeeswapDelegatee.donate'
 167 |     | ///   'INofeeswapDelegatee.modifyKernel'
 168 |     | ///   'INofeeswapDelegatee.modifyPoolGrowthPortion'
 169 |     | ///   'INofeeswapDelegatee.updateGrowthPortions'
 170 |     | ///   'INofeeswapDelegatee.collectPool'
 171 |     | ///   'INofeeswapDelegatee.collectProtocol'
 172 |     | ///
 173 |     | error PoolIsLocked(uint256 poolId);
 174 |     | 
 175 |     | /// @notice Thrown when the deployment of static parameters fail.
 176 |     | error DeploymentFailed();
 177 |     | 
 178 |     | /// @notice Thrown when the method 'redeployStaticParamsAndKernel' is run
 179 |     | /// externally.
 180 |     | error CannotRedeployStaticParamsAndKernelExternally();
 181 |     | 
 182 |     | /// @notice Thrown when attempting to sync protocol's reserve of native token.
 183 |     | error NativeTokenCannotBeSynced();
 184 |     | 
 185 |     | /// @notice Thrown when the spender allowance for a tag is insufficient.
 186 |     | error InsufficientPermission(address spender, Tag tag);
 187 |     | 
 188 |     | /// @notice Thrown when the total number of shares accross all liquidity
 189 |     | /// intervals exceed '2 ** 127 - 1'.
 190 |     | error SharesGrossOverflow(int256 sharesGross);
 191 |     | 
 192 |     | /// @notice Thrown when attempting to access a pool which does not exist.
 193 |     | error PoolDoesNotExist(uint256 poolId);
 194 |     | 
 195 |     | /// @notice Thrown when the owner balance for a tag is insufficient.
 196 |     | error InsufficientBalance(address owner, Tag tag);
 197 |     | 
 198 |     | /// @notice Throws when Sentinel response is invalid.
 199 |     | error InvalidSentinelResponse(bytes4 response);
 200 |     | 
 201 |     | /// @notice Thrown when the given 'zeroForOne' is not in agreement with 
 202 |     | /// 'logPriceLimitOffsetted'.
 203 |     | error InvalidDirection(X59 current, X59 limit);
 204 |     | 
 205 |     | /// @notice Thrown when attempting to initialize a pool that already exists.
 206 |     | error PoolExists(uint256 poolId);
 207 |     | 
 208 |     | /// @notice Thrown when 'log(pOffset)' is not within the range '[-89, +89]'.
 209 |     | error LogOffsetOutOfRange(X59 qOffset);
 210 |     | 
 211 |     | /// @notice Thrown when the given tags are not in the correct order, i.e.,
 212 |     | /// 'tag0 < tag1'.
 213 |     | error TagsOutOfOrder(Tag tag0, Tag tag1);
 214 |     | 
 215 |     | /// @notice Thrown when a given growth portion is greater than one.
 216 |     | error InvalidGrowthPortion(X47 poolGrowthPortion);
 217 |     | 
 218 |     | /// @notice Thrown when a given logarithmic price does not belong to the range
 219 |     | /// '[log(pOffset) - 16 + 1 / (2 ** 59), log(pOffset) + 16 - 1 / (2 ** 59)]'.
 220 |     | error LogPriceOutOfRange(X59 logPrice);
 221 |     | 
 222 |     | /// @notice Thrown when attempting to mint/burn a position with zero shares or
 223 |     | /// when the number of shares does not belong to 
 224 |     | /// '[- type(int128).max, type(int128).max]'.
 225 |     | error InvalidNumberOfShares(int256 shares);
 226 |     | 
 227 |     | /// @notice Thrown when attempting to initialize a pool with 'poolId == 0'.
 228 |     | error PoolIdCannotBeZero();
 229 |     | 
 230 |     | /// @notice Thrown when attempting to access protocol operations via an
 231 |     | /// unauthorized address.
 232 |     | error OnlyByProtocol(address attemptingAddress, address protocolAddress);
 233 |     | 
 234 |     | /// @notice Thrown when attempting to access pool operations via an
 235 |     | /// unauthorized address.
 236 |     | error OnlyByPoolOwner(address attemptingAddress, address poolOwnerAddress);
 237 |     | 
 238 |     | /// @notice Thrown when attempting to mint/burn a position with invalid
 239 |     | /// lower bound which is not equal to interval boundaries modulo 'qSpacing'.
 240 |     | error LogPriceMinIsNotSpaced(X59 logPriceMin);
 241 |     | 
 242 |     | /// @notice Thrown when attempting to mint/burn a position with invalid
 243 |     | /// upper bound which is not equal to interval boundaries modulo 'qSpacing'.
 244 |     | error LogPriceMaxIsNotSpaced(X59 logPriceMax);
 245 |     | 
 246 |     | /// @notice Thrown when attempting to mint/burn a position with invalid
 247 |     | /// lower bound which is not greater than 'qSpacing'
 248 |     | error LogPriceMinIsInBlankArea(X59 logPriceMin);
 249 |     | 
 250 |     | /// @notice Thrown when attempting to mint/burn a position with invalid
 251 |     | /// lower bound which is not less than 'thirtyTwoX59 - qSpacing'.
 252 |     | error LogPriceMaxIsInBlankArea(X59 logPriceMax);
 253 |     | 
 254 |     | /// @notice Thrown when the given logPrices for a position are not in the
 255 |     | /// correct order.
 256 |     | error LogPricesOutOfOrder(X59 logPriceMin, X59 logPriceMax);
 257 |     | 
 258 |     | /// @notice Thrown when attempting donate to a pool whose donate flag is not 
 259 |     | /// active.
 260 |     | error DonateIsNotAllowed(uint256 poolId);
 261 |     | 
 262 |     | /// @notice Thrown when attempting to perform a donate to an empty interval.
 263 |     | error CannotDonateToEmptyInterval();
 264 |     | 
 265 |     | /// @notice Thrown when attempting to change an immutable kernel.
 266 |     | error ImmutableKernel(uint256 poolId);
 267 |     | 
 268 |     | /// @notice Thrown when attempting to change an immutable poolGrowthPortion.
 269 |     | error ImmutablePoolGrowthPortion(uint256 poolId);
 270 |     | 
 271 |     | /// @notice Thrown when attempting to make a delegate call to the protocol.
 272 |     | error NoDelegateCall(address context);
 273 |     | 
 274 |     | /// @notice Thrown when transient balances are not cleared.
 275 |     | error OutstandingAmount();
 276 |     | 
 277 |     | /// @notice Thrown when attempting to transfer NofeeAssets to address 0.
 278 |     | error CannotTransferToAddressZero();
 279 |     | 
 280 |     | /// @notice Thrown when the amount to be cleared is not equal to the transient
 281 |     | /// balance of 'msg.sender'.
 282 |     | error NotEqualToTransientBalance(int256 currentBalance);
 283 |     | 
 284 |     | /// @notice Thrown when the size of 'hookData' exceeds 'type(uint16).max'.
 285 |     | error HookDataTooLong(uint256 hookDataByteCount);
 286 |     | 
 287 |     | /// @notice Thrown when attempting to transfer ownership to address 0.
 288 |     | error AdminCannotBeAddressZero();
 289 |     | 
 290 |     | /// @notice Thrown when attempting to settle a tag with nonzero 'msg.value'.
 291 |     | error MsgValueIsNonZero(uint256 msgValue);
 292 |     | 
 293 |     | /// @notice Thrown when attempting to mint a position after burning it in the
 294 |     | /// same transaction.
 295 |     | error CannotMintAfterBurning(uint256 poolId, X59 qMin, X59 qMax);

R:/LIAT.AI/nofeeswap-core/contracts/utilities/FullMath.sol
   1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
   2 |     | pragma solidity ^0.8.28;
   3 |     | 
   4 |     | import {MulDivOverflow} from "./Errors.sol";
   5 |     | 
   6 |     | /// @title Contains 512-bit multiplication and division functions
   7 |     | /// Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv
   8 |     | /// for several functions in this library.
   9 |     | library FullMathLibrary {
  10 |     |   ///                           _____   _____   _____
  11 |     |   /// @notice 512-bit addition 'r1 r0 = a1 a0 + b1 b0'.
  12 |     |   /// Overflow should be avoided externally.
  13 |     |   /// @param a0 Least significant 256 bits of the first number.
  14 |     |   /// @param a1 Most significant 256 bits of the first number.
  15 |     |   /// @param b0 Least significant 256 bits of the second number.
  16 |     |   /// @param b1 Most significant 256 bits of the second number.
  17 |     |   /// @return r0 Least significant 256 bits of the addition.
  18 |     |   /// @return r1 Most significant 256 bits of the addition.
  19 |     |   function add512(
  20 |     |     uint256 a0,
  21 |     |     uint256 a1,
  22 |     |     uint256 b0,
  23 |     |     uint256 b1
  24 |     |   ) internal pure returns (
  25 |     |     uint256 r0,
  26 |     |     uint256 r1
  27 |     |   ) {
  28 |     |     //      s0
  29 |     |     //      a1 a0
  30 |     |     // +    b1 b0
  31 |     |     // -----------
  32 |     |     //      r1 r0
  33 |     |     //
  34 |     |     // where 's0 := lt(r0, a0)'.
  35 |     |     assembly {
  36 |     |       r0 := add(a0, b0)
  37 |     |       r1 := add(
  38 |     |         add(a1, b1),
  39 |     |         // 'r0 < a0' indicates that the addition 'a0 + b0' has overflowed. In
  40 |     |         // this case '1' needs to be added to the most significant 256 bits of
  41 |     |         // the output.
  42 |     |         lt(r0, a0)
  43 |     |       )
  44 |     |     }
  45 |     |   }
  46 |     | 
  47 |     |   ///                              _____   _____   _____
  48 |     |   /// @notice 512-bit subtraction 'r1 r0 = a1 a0 - b1 b0'.
  49 |     |   /// Underflow should be avoided externally.
  50 |     |   /// @param a0 Least significant 256 bits of the minuend.
  51 |     |   /// @param a1 Most significant 256 bits of the minuend.
  52 |     |   /// @param b0 Least significant 256 bits of the subtrahend.
  53 |     |   /// @param b1 Most significant 256 bits of the subtrahend.
  54 |     |   /// @return r0 Least significant 256 bits of the subtraction.
  55 |     |   /// @return r1 Most significant 256 bits of the subtraction.
  56 |     |   function sub512(
  57 |     |     uint256 a0,
  58 |     |     uint256 a1,
  59 |     |     uint256 b0,
  60 |     |     uint256 b1
  61 |     |   ) internal pure returns (
  62 |     |     uint256 r0,
  63 |     |     uint256 r1
  64 |     |   ) {
  65 |     |     //      a1 a0
  66 |     |     // -    b1 b0
  67 |     |     // -----------
  68 |     |     //      s1 r0
  69 |     |     // -    s0
  70 |     |     // -----------
  71 |     |     //      r1 r0
  72 |     |     //
  73 |     |     // where 's0 := lt(a0, b0)' and 's1 := (a1 - b1) % (2 ** 256)'.
  74 |     |     assembly {
  75 |     |       r0 := sub(a0, b0)
  76 |     |       r1 := sub(
  77 |     |         sub(a1, b1),
  78 |     |         // 'a0 < b0' indicates that the subtraction 'a0 - b0' has underflowed.
  79 |     |         // In this case '1' needs to be subtracted from the most significant
  80 |     |         // 256 bits of the output.
  81 |     |         lt(a0, b0)
  82 |     |       )
  83 |     |     }
  84 |     |   }
  85 |     | 
  86 |     |   ///                           ___________
  87 |     |   /// @notice 512-bit multiply 'prod1 prod0 = a * b'.
  88 |     |   /// @param a The multiplicand.
  89 |     |   /// @param b The multiplier.
  90 |     |   /// @return prod0 Least significant 256 bits of the product.
  91 |     |   /// @return prod1 Most significant 256 bits of the product.
  92 |     |   function mul512(
  93 |     |     uint256 a,
  94 |     |     uint256 b
  95 |     |   ) internal pure returns (
  96 |     |     uint256 prod0, 
  97 |     |     uint256 prod1
  98 |     |   ) {
  99 |     |     assembly {
 100 |     |       // 'mm := a * b - (2 ** 256 - 1) * q'
 101 |     |       let mm := mulmod(a, b, not(0))
 102 |     | 
 103 |     |       // 'prod0 := a * b - (2 ** 256) * p'
 104 |     |       prod0 := mul(a, b)
 105 |     | 
 106 |     |       prod1 := sub(
 107 |     |         // 'mm - prod0 == q'.
 108 |     |         sub(mm, prod0),
 109 |     |         //               a * b                 a * b
 110 |     |         // p == floor(----------) <= floor(--------------) == q
 111 |     |         //             2 ** 256             2 ** 256 - 1
 112 |     |         //
 113 |     |         // On the other hand, since
 114 |     |         //
 115 |     |         //      a * b          a * b                  a * b
 116 |     |         // -------------- - ---------- == ----------------------------- < 1
 117 |     |         //  2 ** 256 - 1     2 ** 256      (2 ** 256) * (2 ** 256 - 1)
 118 |     |         //
 119 |     |         // we have 'q - p <= 1'.
 120 |     |         //
 121 |     |         // Hence, either 'p == q' or 'p == q - 1'.
 122 |     |         //
 123 |     |         // If 'p == q', then 'mm - prod0 == q >= 0'.
 124 |     |         // If 'p == q - 1', then 'prod0 - mm == (2 ** 256) - q > 0'.
 125 |     |         //
 126 |     |         // Since 'p == q' and 'p == q - 1' are mutually exclusive, we can argue
 127 |     |         // that:
 128 |     |         //
 129 |     |         // 'p == q' if and only if 'mm >= prod0'.
 130 |     |         // 'p == q - 1' if and only if 'mm < prod0'.
 131 |     |         //
 132 |     |         // Hence, in the latter case, we should subtract by '1'.
 133 |     |         lt(mm, prod0)
 134 |     |       )
 135 |     |     }
 136 |     |   }
 137 |     | 
 138 |     |   /// @notice Calculates (a * b) / denominator when 
 139 |     |   /// 'a * b < denominator * (denominator - 1)'.
 140 |     |   /// @param a The multiplicand.
 141 |     |   /// @param b The multiplier.
 142 |     |   /// @param denominator The divisor.
 143 |     |   /// @return result '(a * b) / denominator'.
 144 |     |   function cheapMulDiv(
 145 |     |     uint256 a,
 146 |     |     uint256 b,
 147 |     |     uint256 denominator
 148 |     |   ) internal pure returns (
 149 |     |     uint256 result
 150 |     |   ) {
 151 |     |     assembly {
 152 |     |       result := sub(denominator, 1)
 153 |     | 
 154 |     |       // 's := a * b - q * (denominator - 1)'
 155 |     |       // 'r := a * b - p * denominator'
 156 |     |       // 's - r == p * denominator == p' [mod (denominator - 1)]
 157 |     |       result := addmod(
 158 |     |         mulmod(a, b, result),
 159 |     |         // This subtraction is safe because 
 160 |     |         // '(a * b) % denominator <= denominator - 1'.
 161 |     |         sub(result, mulmod(a, b, denominator)),
 162 |     |         result
 163 |     |       )
 164 |     |       // Notice that 'result <= denominator - 1' and because of the input
 165 |     |       // requirement, we have 'p = (a * b) / denominator <= denominator - 1'.
 166 |     |       // Hence, 'result == s - r == p'.
 167 |     |     }
 168 |     |   }
 169 |     | 
 170 |     |   /// @notice Calculates the modular inverse of an odd number modulo '2 ** 256'
 171 |     |   /// Input should be odd.
 172 |     |   /// @param value The number whose modular inverse to be calculated.
 173 |     |   /// @return inverse A 256-bit inverse satisfying
 174 |     |   /// 'value * inverse == 1' [mod 2 ** 256].
 175 |     |   function modularInverse(
 176 |     |     uint256 value
 177 |     |   ) internal pure returns (
 178 |     |     uint256 inverse
 179 |     |   ) {
 180 |     |     unchecked {
 181 |     |       // Compute the inverse by starting with a seed that is correct for four
 182 |     |       // bits. That is, 'value * inverse = 1' [mod 2 ** 4].
 183 |     |       inverse = 3 * value ^ 2;
 184 |     |       // Now use Newton-Raphson iterations to improve the precision. Thanks to
 185 |     |       // Hensel's lifting lemma, this also works in modular arithmetic,
 186 |     |       // doubling the correct bits in each step.
 187 |     |       inverse *= 2 - value * inverse;
 188 |     |       inverse *= 2 - value * inverse;
 189 |     |       inverse *= 2 - value * inverse;
 190 |     |       inverse *= 2 - value * inverse;
 191 |     |       inverse *= 2 - value * inverse;
 192 |     |       inverse *= 2 - value * inverse;
 193 |     |     }
 194 |     |   }
 195 |     | 
 196 |     |   ///                          ________
 197 |     |   /// @notice 768-bit multiply q2 q1 q0 = a * b * c
 198 |     |   /// @param a The multiplicand.
 199 |     |   /// @param b The first multiplier.
 200 |     |   /// @param c The second multiplier.
 201 |     |   /// @return q0 Least significant 256 bits of the product.
 202 |     |   /// @return q1 Middle 256 bits of the product.
 203 |     |   /// @return q2 Most significant 256 bits of the product.
 204 |     |   function mul768(
 205 |     |     uint256 a,
 206 |     |     uint256 b,
 207 |     |     uint256 c
 208 |     |   ) internal pure returns (
 209 |     |     uint256 q0,
 210 |     |     uint256 q1,
 211 |     |     uint256 q2
 212 |     |   ) {
 213 |     |     //          a
 214 |     |     // x        b
 215 |     |     // -----------
 216 |     |     //      q1 q0
 217 |     |     // x        c
 218 |     |     // -----------
 219 |     |     //   ss 
 220 |     |     //      mm q0
 221 |     |     // + q2 q1  0
 222 |     |     // -----------
 223 |     |     //   q2 q1 q0
 224 |     |     //
 225 |     |     uint256 mm;
 226 |     |     (q0, q1) = mul512(a, b);
 227 |     |     (q1, q2) = mul512(q1, c);
 228 |     |     (q0, mm) = mul512(q0, c);
 229 |     |     assembly {
 230 |     |       q1 := add(q1, mm)
 231 |     |       // 'q1 < mm' indicates that the above addition has overflowed (i.e.,
 232 |     |       // 'ss == 1') and hence, '1' needs to be added to the most significant
 233 |     |       // 256 bits of the product.
 234 |     |       q2 := add(q2, lt(q1, mm))
 235 |     |     }
 236 |     |   }
 237 |     | 
 238 |     |   /// @notice Calculates 
 239 |     |   ///
 240 |     |   ///         a * b * c
 241 |     |   /// 'min(----------------, 2 ** 216 - 1)'
 242 |     |   ///       d * (2 ** 143)
 243 |     |   ///
 244 |     |   /// with full precision when 'a * b * c != 0'.
 245 |     |   /// @param a The multiplicand.
 246 |     |   /// @param b The first multiplier.
 247 |     |   /// @param c The second multiplier.
 248 |     |   /// @param d The denominator.
 249 |     |   /// @param roundUp Whether to round up the result.
 250 |     |   /// @return result The output value '(a * b * c) / (d * (2 ** 143))' which is
 251 |     |   /// capped by '2 ** 216 - 1'.
 252 |     |   function mulDiv(
 253 |     |     uint256 a,
 254 |     |     uint256 b,
 255 |     |     uint256 c,
 256 |     |     uint256 d,
 257 |     |     bool roundUp
 258 |     |   ) internal pure returns (
 259 |     |     uint256 result
 260 |     |   ) {
 261 |     |     unchecked {
 262 |     |       // ________
 263 |     |       // q2 q1 q0 = a * b * c
 264 |     |       (uint256 q0, uint256 q1, uint256 q2) = mul768(a, b, c);
 265 |     | 
 266 |     |       // If 'q2 >= (1 << 103)', then the output is greater than or equal to
 267 |     |       //
 268 |     |       //  (2 ** 103) * (2 ** 256) * (2 ** 256)
 269 |     |       // -------------------------------------- == 2 ** 216
 270 |     |       //        (2 ** 256) * (2 ** 143)
 271 |     |       //
 272 |     |       // In this case, '2 ** 216 - 1' should be returned.
 273 |     |       if (q2 >= (1 << 103)) return ((1 << 216) - 1);
 274 |     | 
 275 |     |       // Divide the numerator by '2 ** 143'
 276 |     |       (q2, q1) = (
 277 |     |         (q2 << 113) | (q1 >> 143),
 278 |     |         (q1 << 113) | (q0 >> 143)
 279 |     |       );
 280 |     | 
 281 |     |       // Calculating the remainder of the numerator modulo 'd'.
 282 |     |       uint256 r;
 283 |     |       assembly {
 284 |     |         r := addmod(
 285 |     |           addmod(q1, q2, d), // (q1 + q2) % d
 286 |     |           mulmod(q2, not(0), d), // (q2 * (2 ** 256 - 1)) % d
 287 |     |           d
 288 |     |         ) // (q1 + q2 * (2 ** 256)) % d
 289 |     |       }
 290 |     |       
 291 |     |       //                         _____
 292 |     |       // 'r' is subtracted from 'q2 q1'.
 293 |     |       assembly {
 294 |     |         // 'q1 < r' indicates that the subtraction 'q1 - r' underflows.
 295 |     |         // In this case '1' needs to be subtracted from q2.
 296 |     |         q2 := sub(q2, lt(q1, r))
 297 |     |         q1 := sub(q1, r)
 298 |     |       }
 299 |     | 
 300 |     |       // Determines whether to return '2 ** 216 - 1'.
 301 |     |       //                _____
 302 |     |       // Check whether 'q2 q1 >= (2 ** 256) * d'.
 303 |     |       if (q2 >= d) return ((1 << 216) - 1);
 304 |     | 
 305 |     |       // 'd' is factored into an odd part and a power of two. 
 306 |     |       // Then, the numerator is divided by the power of two.
 307 |     |       {
 308 |     |         // This is the largest power of two that 'd' is divisible by.
 309 |     |         uint256 twos = (0 - d) & d;
 310 |     |         assembly {
 311 |     |           // Dividing 'd' by 'twos'.
 312 |     |           d := div(d, twos)
 313 |     | 
 314 |     |           //           _____
 315 |     |           // Dividing 'q2 q1' by 'twos' and storing the least significant '256'
 316 |     |           // bits in 'q1'.
 317 |     |           q1 := or(
 318 |     |             div(q1, twos), // 'q1 / (2 ** k)'
 319 |     |             mul(
 320 |     |               q2,
 321 |     |               add(
 322 |     |                 div(
 323 |     |                   sub(0, twos), // '2 ** 256 - 2 ** k'
 324 |     |                   twos // '2 ** k'
 325 |     |                 ), // '2 ** (256 - k) - 1'
 326 |     |                 1
 327 |     |               ) // '(2 ** (256 - k)) % (2 ** 256)'
 328 |     |             ) // '(q2 * (2 ** (256 - k))) % (2 ** 256)'
 329 |     |           ) // '(q2 * (2 ** (256 - k)) + q1 / (2 ** k)) % (2 ** 256)'
 330 |     |         }
 331 |     |       }
 332 |     | 
 333 |     |       // The result can now be calculated precisely using modular inverse.
 334 |     |       // Let 'di := modularInverse(d)'.
 335 |     |       //
 336 |     |       //  _____
 337 |     |       // 'q2 q1 == d * result'
 338 |     |       // '(2 ** 256) * q2 + q1 == d * result'
 339 |     |       // 'di * (2 ** 256) * q2 + di * q1 == di * d * result'
 340 |     |       // 'di * (2 ** 256) * q2 + di * q1 == ((2 ** 256) * k + 1) * result'
 341 |     |       // 'di * q1 == result' [mod 2 ** 256]
 342 |     |       result = modularInverse(d) * q1;
 343 |     | 
 344 |     |       // If either of the remainders are positive, then the result should be
 345 |     |       // rounded up.
 346 |     |       if (roundUp) {
 347 |     |         if ((q0 & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) > 0 || r > 0) {
 348 |     |           ++result;
 349 |     |         }
 350 |     |       }
 351 |     | 
 352 |     |       // Determines whether to return '2 ** 216 - 1'.
 353 |     |       if (result >= (1 << 216)) return ((1 << 216) - 1);
 354 |     |     }
 355 |     |   }
 356 |     | 
 357 |     |   /// @notice Calculates
 358 |     |   ///
 359 |     |   ///      a * b * c
 360 |     |   /// '----------------'
 361 |     |   ///   d * (2 ** 111)
 362 |     |   ///
 363 |     |   /// with full precision. Overflows if the result exceeds 'type(int256).max'.
 364 |     |   /// 'e' must be the modular inverse of 'd / (2 ** k)' where 'k' is the
 365 |     |   /// largest power of two within 'd'.
 366 |     |   /// We should have 'a * b * c != 0' and 'd != 0'.
 367 |     |   /// @param a The multiplicand.
 368 |     |   /// @param b The first multiplier.
 369 |     |   /// @param c The second multiplier.
 370 |     |   /// @param d The denominator.
 371 |     |   /// @param e Modular inverse of the odd part of the denominator.
 372 |     |   /// @param roundUp Whether to round up the result.
 373 |     |   /// @return result The output value '(a * b * c) / (d * (2 ** 111))' if there
 374 |     |   /// is no overflow.
 375 |     |   /// @return overflow Whether the result overflows.
 376 |     |   function mulDiv(
 377 |     |     uint256 a,
 378 |     |     uint256 b,
 379 |     |     uint256 c,
 380 |     |     uint256 d,
 381 |     |     uint256 e,
 382 |     |     bool roundUp
 383 |     |   ) internal pure returns (
 384 |     |     uint256 result,
 385 |     |     bool overflow
 386 |     |   ) {
 387 |     |     unchecked {
 388 |     |       // ________
 389 |     |       // q2 q1 q0 = a * b * c
 390 |     |       (uint256 q0, uint256 q1, uint256 q2) = mul768(a, b, c);
 391 |     | 
 392 |     |       // If 'q2 >= (1 << 111)', then the output is greater than or equal to
 393 |     |       //
 394 |     |       //  (2 ** 111) * (2 ** 256) * (2 ** 256)
 395 |     |       // -------------------------------------- == 2 ** 256
 396 |     |       //        (2 ** 256) * (2 ** 111)
 397 |     |       //
 398 |     |       // In this case, we return overflow.
 399 |     |       if (q2 >= (1 << 111)) return (0, true);
 400 |     | 
 401 |     |       // Divide the numerator by '2 ** 111'
 402 |     |       (q2, q1) = (
 403 |     |         (q2 << 145) | (q1 >> 111),
 404 |     |         (q1 << 145) | (q0 >> 111)
 405 |     |       );
 406 |     | 
 407 |     |       // Calculating the remainder of the numerator modulo 'd'.
 408 |     |       uint256 r;
 409 |     |       assembly {
 410 |     |         r := addmod(
 411 |     |           addmod(q1, q2, d), // (q1 + q2) % d
 412 |     |           mulmod(q2, not(0), d), // (q2 * (2 ** 256 - 1)) % d
 413 |     |           d
 414 |     |         ) // (q1 + q2 * (2 ** 256)) % d
 415 |     |       }
 416 |     | 
 417 |     |       //                         _____
 418 |     |       // 'r' is subtracted from 'q2 q1'.
 419 |     |       assembly {
 420 |     |         // 'q1 < r' indicates that the subtraction 'q1 - r' underflowes.
 421 |     |         // In this case '1' needs to be subtracted from q2.
 422 |     |         q2 := sub(q2, lt(q1, r))
 423 |     |         q1 := sub(q1, r)
 424 |     |       }
 425 |     | 
 426 |     |       // Determines whether to return overflow.
 427 |     |       // The following equality is satisfied if and only if
 428 |     |       //
 429 |     |       //      a * b * c
 430 |     |       // '---------------- >= (2 ** 256)'
 431 |     |       //   d * (2 ** 111)
 432 |     |       //
 433 |     |       if (q2 >= d) return (0, true);
 434 |     | 
 435 |     |       // 'd' is factored into an odd part and a power of two and the numerator
 436 |     |       // is divided by the power of two.
 437 |     |       d = (0 - d) & d;
 438 |     |       assembly {
 439 |     |         q1 := or(
 440 |     |           div(q1, d), // q1 / (2 ** k)
 441 |     |           mul(
 442 |     |             q2,
 443 |     |             add(
 444 |     |               div(
 445 |     |                 sub(0, d), // '2 ** 256 - 2 ** k'
 446 |     |                 d // '2 ** k'
 447 |     |               ), // '2 ** (256 - k) - 1'
 448 |     |               1
 449 |     |             ) // '(2 ** (256 - k)) % (2 ** 256)'
 450 |     |           ) // '(q2 * (2 ** (256 - k))) % (2 ** 256)'
 451 |     |         ) // '(q2 * (2 ** (256 - k)) + q1 / (2 ** k)) % (2 ** 256)'
 452 |     |       }
 453 |     | 
 454 |     |       // The result can now be calculated precisely using 'e'.
 455 |     |       //  _____
 456 |     |       // 'q2 q1 == d * result'
 457 |     |       // '(2 ** 256) * q2 + q1 == d * result'
 458 |     |       // 'e * (2 ** 256) * q2 + e * q1 == e * d * result'
 459 |     |       // 'e * (2 ** 256) * q2 + e * q1 == ((2 ** 256) * k + 1) * result'
 460 |     |       // 'e * q1 == result' [mod 2 ** 256]
 461 |     |       result = e * q1;
 462 |     | 
 463 |     |       // If either of the remainders are positive, then the result should be
 464 |     |       // rounded up.
 465 |     |       if (roundUp) {
 466 |     |         if ((q0 & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFF) > 0 || r > 0) {
 467 |     |           ++result;
 468 |     |         }
 469 |     |       }
 470 |     | 
 471 |     |       // Determines whether to overflow.
 472 |     |       if (result >= (1 << 255)) return (0, true);
 473 |     |     }
 474 |     |   }
 475 |     | 
 476 |     |   /// @notice Calculates floor((a * b) / denominator) with full precision.
 477 |     |   /// Overflow should be avoided externally.
 478 |     |   /// @param a The multiplicand
 479 |     |   /// @param b The multiplier
 480 |     |   /// @param denominator The divisor
 481 |     |   /// @return result The 256-bit result
 482 |     |   function mulDiv(
 483 |     |     uint256 a,
 484 |     |     uint256 b,
 485 |     |     uint256 denominator
 486 |     |   ) internal pure returns (
 487 |     |     uint256 result
 488 |     |   ) {
 489 |     |     unchecked {
 490 |     |       //                   ___________
 491 |     |       // 512-bit multiply 'prod1 prod0 = a * b'
 492 |     |       // Compute the product mod 2**256 and mod 2 ** 256 - 1
 493 |     |       // then use the Chinese Remainder Theorem to reconstruct
 494 |     |       // the 512 bit result. The result is stored in two 256
 495 |     |       // variables such that product = prod1 * (2 ** 256) + prod0
 496 |     |       (uint256 prod0, uint256 prod1) = mul512(a, b);
 497 |     | 
 498 |     |       // Short circuit 256 by 256 division
 499 |     |       // This saves gas when a * b is small, at the cost of making the
 500 |     |       // large case a bit more expensive. Depending on your use case you
 501 |     |       // may want to remove this short circuit and always go through the
 502 |     |       // 512 bit path.
 503 |     |       if (prod1 == 0) {
 504 |     |         assembly {
 505 |     |           result := div(prod0, denominator)
 506 |     |         }
 507 |     |         return result;
 508 |     |       }
 509 |     |       
 510 |     |       ///////////////////////////////////////////////
 511 |     |       // 512 by 256 division.
 512 |     |       ///////////////////////////////////////////////
 513 |     | 
 514 |     |       //                                                        ___________
 515 |     |       // Make division exact by subtracting the remainder from 'prod1 prod0'
 516 |     |       // Compute remainder using mulmod
 517 |     |       // Note mulmod(_, _, 0) == 0
 518 |     |       uint256 remainder;
 519 |     |       assembly {
 520 |     |         remainder := mulmod(a, b, denominator)
 521 |     |       }
 522 |     | 
 523 |     |       // Subtract 256 bit number from 512 bit number
 524 |     |       assembly {
 525 |     |         prod1 := sub(prod1, gt(remainder, prod0))
 526 |     |         prod0 := sub(prod0, remainder)
 527 |     |       }
 528 |     |       
 529 |     |       // Factor powers of two out of denominator
 530 |     |       // Compute largest power of two-divisor of denominator.
 531 |     |       // Always >= 1 unless the denominator is zero, then twos is zero.
 532 |     |       uint256 twos = (0 - denominator) & denominator;
 533 |     |       // Divide denominator by power of two
 534 |     |       assembly {
 535 |     |         denominator := div(denominator, twos)
 536 |     |       }
 537 |     |       
 538 |     |       //         ___________
 539 |     |       // Divide 'prod1 prod0' by the factors of two
 540 |     |       assembly {
 541 |     |         prod0 := div(prod0, twos)
 542 |     |       }
 543 |     |       // Shift in bits from prod1 into prod0. For this we need
 544 |     |       // to flip `twos` such that it is 2**256 / twos.
 545 |     |       // If twos is zero, then it becomes one
 546 |     |       assembly {
 547 |     |         twos := add(div(sub(0, twos), twos), 1)
 548 |     |       }
 549 |     |       prod0 |= prod1 * twos;
 550 |     |       
 551 |     |       // Invert denominator mod 2**256
 552 |     |       // Now that denominator is an odd number, it has an inverse
 553 |     |       // modulo 2**256 such that denominator * inv = 1 mod 2**256.
 554 |     |       // Compute the inverse by starting with a seed that is correct
 555 |     |       // correct for four bits. That is, denominator * inv = 1 mod 2**4
 556 |     |       // If denominator is zero the inverse starts with 2
 557 |     |       // Now use Newton-Raphson iteration to improve the precision.
 558 |     |       // Thanks to Hensel's lifting lemma, this also works in modular
 559 |     |       // arithmetic, doubling the correct bits in each step.
 560 |     |       uint256 inv = modularInverse(denominator);
 561 |     |       // If denominator is zero, inv is now 128
 562 |     |       
 563 |     |       // Because the division is now exact we can divide by multiplying
 564 |     |       // with the modular inverse of the denominator. This will give us the
 565 |     |       // correct result modulo 2**256. Since the preconditions guarantee
 566 |     |       // that the outcome is less than 2**256, this is the final result.
 567 |     |       // We don't need to compute the high bits of the result and prod1
 568 |     |       // is no longer required.
 569 |     |       result = prod0 * inv;
 570 |     |       return result;
 571 |     |     }
 572 |     |   }
 573 |     | 
 574 |     |   /// @notice Calculates ceiling((a * b) / denominator) with full precision.
 575 |     |   /// Overflow should be avoided externally.
 576 |     |   /// @param a The multiplicand
 577 |     |   /// @param b The multiplier
 578 |     |   /// @param denominator The divisor
 579 |     |   /// @return result The 256-bit result
 580 |     |   function mulDivRoundUp(
 581 |     |     uint256 a,
 582 |     |     uint256 b,
 583 |     |     uint256 denominator
 584 |     |   ) internal pure returns (uint256 result) {
 585 |     |     result = mulDiv(a, b, denominator);
 586 |     |     // The result is incremented if 'a * b' is not divisible by 'denominator'.
 587 |     |     assembly {
 588 |     |       result := add(result, gt(mulmod(a, b, denominator), 0))
 589 |     |     }
 590 |     |   }
 591 |     | 
 592 |     |   /// @notice Calculates floor((a * b) / denominator) with full precision.
 593 |     |   /// Throws in case of overflow.
 594 |     |   /// @param a The multiplicand
 595 |     |   /// @param b The multiplier
 596 |     |   /// @param denominator The divisor
 597 |     |   /// @return result The 256-bit result
 598 |     |   function safeMulDiv(
 599 |     |     uint256 a,
 600 |     |     uint256 b,
 601 |     |     uint256 denominator
 602 |     |   ) internal pure returns (uint256 result) {
 603 |     |     (, uint256 prod1) = mul512(a, b);
 604 |     |     require(prod1 < denominator, MulDivOverflow(a, b, denominator));
 605 |     |     result = mulDiv(a, b, denominator);
 606 |     |   }
 607 |     | 
 608 |     |   /// @notice Calculates ceiling((a * b) / denominator) with full precision.
 609 |     |   /// Throws in case of overflow.
 610 |     |   /// @param a The multiplicand
 611 |     |   /// @param b The multiplier
 612 |     |   /// @param denominator The divisor
 613 |     |   /// @return result The 256-bit result
 614 |     |   function safeMulDivRoundUp(
 615 |     |     uint256 a,
 616 |     |     uint256 b,
 617 |     |     uint256 denominator
 618 |     |   ) internal pure returns (uint256 result) {
 619 |     |     // The result is incremented if 'a * b' is not divisible by 'denominator'.
 620 |     |     assembly {
 621 |     |       result := gt(mulmod(a, b, denominator), 0)
 622 |     |     }
 623 |     |     result += safeMulDiv(a, b, denominator);
 624 |     |   }
 625 |     | }

R:/LIAT.AI/nofeeswap-core/contracts/utilities/Index.sol
   1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
   2 |     | pragma solidity ^0.8.28;
   3 |     | 
   4 |     | // Type index is used to enumerate members of the curve and kernel.
   5 |     | type Index is uint256;
   6 |     | 
   7 |     | Index constant zeroIndex = Index.wrap(0);
   8 |     | Index constant oneIndex = Index.wrap(1);
   9 |     | Index constant twoIndex = Index.wrap(2);
  10 |     | Index constant threeIndex = Index.wrap(3);
  11 |     | Index constant maxCurveIndex = Index.wrap(type(uint16).max);
  12 |     | Index constant maxKernelIndex = Index.wrap(1020);
  13 |     | 
  14 |     | using {equals as ==, notEquals as !=} for Index global;
  15 |     | using {lessThan as <, greaterThan as >} for Index global;
  16 |     | using {lessThanOrEqualTo as <=, greaterThanOrEqualTo as >=} for Index global;
  17 |     | using {add as +, sub as -} for Index global;
  18 |     | 
  19 |     | function equals(
  20 |     |   Index value0,
  21 |     |   Index value1
  22 |     | ) pure returns (
  23 |     |   bool result
  24 |     | ) {
  25 |     |   assembly {
  26 |     |     result := eq(value0, value1)
  27 |     |   }
  28 |     | }
  29 |     | 
  30 |     | function notEquals(
  31 |     |   Index value0,
  32 |     |   Index value1
  33 |     | ) pure returns (
  34 |     |   bool result
  35 |     | ) {
  36 |     |   return !(value0 == value1);
  37 |     | }
  38 |     | 
  39 |     | function lessThan(
  40 |     |   Index value0,
  41 |     |   Index value1
  42 |     | ) pure returns (
  43 |     |   bool result
  44 |     | ) {
  45 |     |   assembly {
  46 |     |     result := lt(value0, value1)
  47 |     |   }
  48 |     | }
  49 |     | 
  50 |     | function greaterThan(
  51 |     |   Index value0,
  52 |     |   Index value1
  53 |     | ) pure returns (
  54 |     |   bool result
  55 |     | ) {
  56 |     |   assembly {
  57 |     |     result := gt(value0, value1)
  58 |     |   }
  59 |     | }
  60 |     | 
  61 |     | function lessThanOrEqualTo(
  62 |     |   Index value0,
  63 |     |   Index value1
  64 |     | ) pure returns (
  65 |     |   bool result
  66 |     | ) {
  67 |     |   return !(value0 > value1);
  68 |     | }
  69 |     | 
  70 |     | function greaterThanOrEqualTo(
  71 |     |   Index value0,
  72 |     |   Index value1
  73 |     | ) pure returns (
  74 |     |   bool result
  75 |     | ) {
  76 |     |   return !(value0 < value1);
  77 |     | }
  78 |     | 
  79 |     | // Overflow should be avoided externally.
  80 |     | function add(
  81 |     |   Index value0,
  82 |     |   Index value1
  83 |     | ) pure returns (
  84 |     |   Index result
  85 |     | ) {
  86 |     |   assembly {
  87 |     |     result := add(value0, value1)
  88 |     |   }
  89 |     | }
  90 |     | 
  91 |     | // Underflow should be avoided externally.
  92 |     | function sub(
  93 |     |   Index value0,
  94 |     |   Index value1
  95 |     | ) pure returns (
  96 |     |   Index result
  97 |     | ) {
  98 |     |   assembly {
  99 |     |     result := sub(value0, value1)
 100 |     |   }
 101 |     | }
 102 |     | 
 103 |     | function min(
 104 |     |   Index value0,
 105 |     |   Index value1
 106 |     | ) pure returns (
 107 |     |   Index result
 108 |     | ) {
 109 |     |   return (value0 < value1) ? value0 : value1;
 110 |     | }
 111 |     | 
 112 |     | function max(
 113 |     |   Index value0,
 114 |     |   Index value1
 115 |     | ) pure returns (
 116 |     |   Index result
 117 |     | ) {
 118 |     |   return (value0 < value1) ? value1 : value0;
 119 |     | }
 120 |     | 
 121 |     | library IndexLibrary {
 122 |     |   /// @notice Returns the current 16-bit index of the curve or kernel under 
 123 |     |   /// exploration given the corresponding pointer.
 124 |     |   ///
 125 |     |   /// 'pointer' should be a constant value.
 126 |     |   function getIndex(
 127 |     |     uint256 pointer
 128 |     |   ) internal pure returns (
 129 |     |     Index value
 130 |     |   ) {
 131 |     |     assembly {
 132 |     |       // First, the memory slot whose most significant 16 bits host the index
 133 |     |       // is loaded and then the least significant 240 bits are discarded.
 134 |     |       value := shr(240, mload(pointer))
 135 |     |     }
 136 |     |   }
 137 |     | 
 138 |     |   /// @notice Increases a 16-bit index stored in memory by one, given a 
 139 |     |   /// pointer. The new value for the index is then returned.
 140 |     |   /// Overflow should be avoided externally.
 141 |     |   ///
 142 |     |   /// 'pointer' should be a constant value.
 143 |     |   function incrementIndex(
 144 |     |     uint256 pointer
 145 |     |   ) internal pure returns (
 146 |     |     Index value
 147 |     |   ) {
 148 |     |     assembly {
 149 |     |       // Index is the most significant 16 bit. Hence, to increment it we need
 150 |     |       // to add the slot by '2 ** 240'.
 151 |     |       value := add(mload(pointer), shl(240, 1))
 152 |     |       mstore(pointer, value)
 153 |     | 
 154 |     |       // Then, the least significant 240 bits are discarded and the resulting
 155 |     |       // value is returned.
 156 |     |       value := shr(240, value)
 157 |     |     }
 158 |     |   }
 159 |     | 
 160 |     |   /// @notice Decreases a 16-bit index stored in memory by one, given a 
 161 |     |   /// pointer. The new value for the index is then returned.
 162 |     |   /// Underflow should be avoided externally.
 163 |     |   ///
 164 |     |   /// 'pointer' should be a constant value.
 165 |     |   function decrementIndex(
 166 |     |     uint256 pointer
 167 |     |   ) internal pure returns (
 168 |     |     Index value
 169 |     |   ) {
 170 |     |     assembly {
 171 |     |       // Index is the most significant 16 bit. Hence, to decrement it we need
 172 |     |       // to subtract the slot by '2 ** 240'.
 173 |     |       value := sub(mload(pointer), shl(240, 1))
 174 |     |       mstore(pointer, value)
 175 |     | 
 176 |     |       // Then, the least significant 240 bits are discarded and the resulting
 177 |     |       // value is returned.
 178 |     |       value := shr(240, value)
 179 |     |     }
 180 |     |   }
 181 |     | }

R:/LIAT.AI/nofeeswap-core/contracts/utilities/Price.sol
   1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
   2 |     | pragma solidity ^0.8.28;
   3 |     | 
   4 |     | import {X15} from "./X15.sol";
   5 |     | import {X59} from "./X59.sol";
   6 |     | import {X216} from "./X216.sol";
   7 |     | 
   8 |     | library PriceLibrary {
   9 |     |   using PriceLibrary for uint256;
  10 |     | 
  11 |     |   /// @notice Stores a given price in a given memory location with the 
  12 |     |   /// following layout:
  13 |     |   ///
  14 |     |   ///  pointer
  15 |     |   ///     |
  16 |     |   ///     +--------+---------------------------+---------------------------+
  17 |     |   ///     | 8 byte |          27 byte          |          27 byte          |
  18 |     |   ///     +--------+---------------------------+---------------------------+
  19 |     |   ///     |        |                           |
  20 |     |   ///     |        |                            \
  21 |     |   ///     |        |                             sqrtInversePrice
  22 |     |   ///     |         \
  23 |     |   ///     |          sqrtPrice
  24 |     |   ///      \
  25 |     |   ///       logPrice
  26 |     |   ///
  27 |     |   /// 'pointer' should not be less than '32'.
  28 |     |   /// 'logPrice' should be non-negative and less than '2 ** 64'.
  29 |     |   /// 'sqrtPrice' should be non-negative and less than 'oneX216'.
  30 |     |   /// 'sqrtInversePrice' should be non-negative and less than 'oneX216'.
  31 | *   |   function storePrice(
  32 |     |     uint256 pointer,
  33 |     |     X59 logPrice,
  34 |     |     X216 sqrtPrice,
  35 |     |     X216 sqrtInversePrice
  36 |     |   ) internal pure {
  37 | *   |     assembly {
  38 |     |       // The preceding slot is cached so that it can be restored after we place
  39 |     |       // all values in their appropriate memory locations.
  40 |     |       // The subtraction is safe because of the input requirement on 'pointer'.
  41 |     |       let precedingPointer := sub(pointer, 32)
  42 |     |       let precedingSlot := mload(precedingPointer)
  43 |     | 
  44 |     |       // We move '64 + 216 + 216' bits forward to reach the following location:
  45 |     |       //
  46 |     |       //                                                          pointer + 62
  47 |     |       //                                                                  \
  48 |     |       //                                                                   |
  49 |     |       //  +--------+---------------------------+---------------------------+
  50 |     |       //  | 8 byte |          27 byte          |          27 byte          |
  51 |     |       //  +--------+---------------------------+---------------------------+
  52 |     |       //  |        |                           |
  53 |     |       //  |        |                            \
  54 |     |       //  |        |                             sqrtInversePrice
  55 |     |       //  |         \
  56 |     |       //  |          sqrtPrice
  57 |     |       //   \
  58 |     |       //    logPrice
  59 |     |       //
  60 |     |       // Then we move '256' bits backward to point to the beginning of the slot
  61 |     |       // whose least significant '216' bits are supposed to host
  62 |     |       // 'sqrtInversePrice'.
  63 |     |       //
  64 |     |       // '64 + 216 + 216 - 256' bits == '30' bytes.
  65 |     |       mstore(add(pointer, 30), sqrtInversePrice)
  66 |     | 
  67 |     |       // We move '64 + 216' bits forward to reach the following location:
  68 |     |       //
  69 |     |       //                                  pointer + 35
  70 |     |       //                                       |
  71 |     |       //  +--------+---------------------------+---------------------------+
  72 |     |       //  | 8 byte |          27 byte          |          27 byte          |
  73 |     |       //  +--------+---------------------------+---------------------------+
  74 |     |       //  |        |                           |
  75 |     |       //  |        |                            \
  76 |     |       //  |        |                             sqrtInversePrice
  77 |     |       //  |         \
  78 |     |       //  |          sqrtPrice
  79 |     |       //   \
  80 |     |       //    logPrice
  81 |     |       //
  82 |     |       // Then we move '256' bits backward to point to the beginning of the slot
  83 |     |       // whose least significant '216' bits are supposed to host 'sqrtPrice'.
  84 |     |       //
  85 |     |       // '64 + 216 - 256' bits == '3' bytes.
  86 |     |       mstore(add(pointer, 3), sqrtPrice)
  87 |     | 
  88 |     |       // We move '64' bits forward to reach the following location:
  89 |     |       //
  90 |     |       //      pointer + 8
  91 |     |       //           |
  92 |     |       //  +--------+---------------------------+---------------------------+
  93 |     |       //  | 8 byte |          27 byte          |          27 byte          |
  94 |     |       //  +--------+---------------------------+---------------------------+
  95 |     |       //  |        |                           |
  96 |     |       //  |        |                            \
  97 |     |       //  |        |                             sqrtInversePrice
  98 |     |       //  |         \
  99 |     |       //  |          sqrtPrice
 100 |     |       //   \
 101 |     |       //    logPrice
 102 |     |       //
 103 |     |       // Then we move '256' bits backward to point to the beginning of the slot
 104 |     |       // whose least significant '64' bits are supposed to host 'logPrice'.
 105 |     |       //
 106 |     |       // '64 - 256' bits == '-24' bytes.
 107 |     |       //
 108 |     |       // The subtraction is safe because of the input requirement on 'pointer'.
 109 |     |       mstore(sub(pointer, 24), logPrice)
 110 |     | 
 111 |     |       // The preceding slot is restored.
 112 |     |       mstore(precedingPointer, precedingSlot)
 113 |     |     }
 114 |     |   }
 115 |     | 
 116 |     |   /// @notice Calculates the sqrt and sqrtInverse of a given logPrice and
 117 |     |   /// stores everything in the given memory location with the following
 118 |     |   /// layout:
 119 |     |   ///
 120 |     |   ///  pointer
 121 |     |   ///     |
 122 |     |   ///     +--------+---------------------------+---------------------------+
 123 |     |   ///     | 8 byte |          27 byte          |          27 byte          |
 124 |     |   ///     +--------+---------------------------+---------------------------+
 125 |     |   ///     |        |                           |
 126 |     |   ///     |        |                            \
 127 |     |   ///     |        |                             sqrtInversePrice
 128 |     |   ///     |         \
 129 |     |   ///     |          sqrtPrice
 130 |     |   ///      \
 131 |     |   ///       logPrice
 132 |     |   ///
 133 |     |   /// 'pointer' should not be less than '32' and 'pointer + 30' should not
 134 |     |   /// overflow.
 135 |     |   ///
 136 |     |   /// 'logPrice' should be greater than 0 and less than (2 ** 64).
 137 |     |   function storePrice(
 138 |     |     uint256 pointer,
 139 |     |     X59 logPrice
 140 |     |   ) internal pure {
 141 |     |     // The requirements of 'exp' are satisfied here because 
 142 |     |     // '0 < logPrice < 2 ** 64'.
 143 |     |     (X216 sqrtPrice, X216 sqrtInversePrice) = logPrice.exp();
 144 |     | 
 145 |     |     // The requirements of 'storePrice' are satisfied here, because of the
 146 |     |     // input requirement on 'pointer' and because both outputs of 'exp' are
 147 |     |     // less than 'oneX216':
 148 |     |     //
 149 |     |     // '0 < logPrice' -> '(2 ** 216) * exp(- logPrice / (2 ** 60)) < 2 ** 216'
 150 |     |     //
 151 |     |     // 'logPrice < 2 ** 64' -> 
 152 |     |     // '(2 ** 216) * exp(- 16 + logPrice / (2 ** 60)) < 2 ** 216'
 153 |     |     //
 154 |     |     pointer.storePrice(logPrice, sqrtPrice, sqrtInversePrice);
 155 |     |   }
 156 |     | 
 157 |     |   /// @notice Stores a given price in a given memory location with the
 158 |     |   /// following layout:
 159 |     |   ///
 160 |     |   ///   pointer
 161 |     |   ///      |
 162 |     |   ///   +--+--------+---------------------------+---------------------------+
 163 |     |   ///   |  | 8 byte |          27 byte          |          27 byte          |
 164 |     |   ///   +--+--------+---------------------------+---------------------------+
 165 |     |   ///   |  |        |                           |
 166 |     |   ///   |  |        |                            \
 167 |     |   ///   |  |        |                             sqrtInversePrice
 168 |     |   ///   |  |         \
 169 |     |   ///   |  |          sqrtPrice
 170 |     |   ///   |   \
 171 |     |   ///   |    logPrice
 172 |     |   ///    \
 173 |     |   ///     heightPrice
 174 |     |   ///
 175 |     |   /// 'pointer' should not be less than '34'.
 176 |     |   /// 'heightPrice' should be less than or equal to 'oneX15'.
 177 |     |   /// 'logPrice' should be non-negative and less than (2 ** 64).
 178 |     |   /// 'sqrtPrice' should be non-negative and less than 'oneX216'.
 179 |     |   /// 'sqrtInversePrice' should be non-negative and less than 'oneX216'.
 180 | *   |   function storePrice(
 181 |     |     uint256 pointer,
 182 |     |     X15 heightPrice,
 183 |     |     X59 logPrice,
 184 |     |     X216 sqrtPrice,
 185 |     |     X216 sqrtInversePrice
 186 |     |   ) internal pure {
 187 | *   |     assembly {
 188 |     |       // The preceding slot is cached so that it can be restored after we place
 189 |     |       // all values in their appropriate memory location.
 190 |     |       // The subtraction is safe because of the input requirement on 'pointer'.
 191 |     |       let precedingPointer := sub(pointer, 34)
 192 |     |       let precedingSlot := mload(precedingPointer)
 193 |     | 
 194 |     |       // We move '64 + 216 + 216' bits forward to reach the following location:
 195 |     |       //
 196 |     |       //                                                          pointer + 62
 197 |     |       //                                                                     \
 198 |     |       //                                                                      |
 199 |     |       //  +--+--------+---------------------------+---------------------------+
 200 |     |       //  |  | 8 byte |          27 byte          |          27 byte          |
 201 |     |       //  +--+--------+---------------------------+---------------------------+
 202 |     |       //  |  |        |                           |
 203 |     |       //  |  |        |                            \
 204 |     |       //  |  |        |                             sqrtInversePrice
 205 |     |       //  |  |         \
 206 |     |       //  |  |          sqrtPrice
 207 |     |       //  |   \
 208 |     |       //  |    logPrice
 209 |     |       //   \
 210 |     |       //    heightPrice
 211 |     |       //
 212 |     |       // Then we move '256' bits backward to point to the beginning of the slot
 213 |     |       // whose least significant '216' bits are supposed to host
 214 |     |       // 'sqrtInversePrice'.
 215 |     |       //
 216 |     |       // '64 + 216 + 216 - 256' bits == '30' bytes.
 217 |     |       mstore(add(pointer, 30), sqrtInversePrice)
 218 |     | 
 219 |     |       // We move '64 + 216' bits forward to reach the following location:
 220 |     |       //
 221 |     |       //                                  pointer + 35
 222 |     |       //                                         \
 223 |     |       //                                          |
 224 |     |       //  +--+--------+---------------------------+---------------------------+
 225 |     |       //  |  | 8 byte |          27 byte          |          27 byte          |
 226 |     |       //  +--+--------+---------------------------+---------------------------+
 227 |     |       //  |  |        |                           |
 228 |     |       //  |  |        |                            \
 229 |     |       //  |  |        |                             sqrtInversePrice
 230 |     |       //  |  |         \
 231 |     |       //  |  |          sqrtPrice
 232 |     |       //  |   \
 233 |     |       //  |    logPrice
 234 |     |       //   \
 235 |     |       //    heightPrice
 236 |     |       //
 237 |     |       // Then we move '256' bits backward to point to the beginning of the slot
 238 |     |       // whose least significant '216' bits are supposed to host 'sqrtPrice'.
 239 |     |       //
 240 |     |       // '64 + 216 - 256' bits == '3' bytes.
 241 |     |       mstore(add(pointer, 3), sqrtPrice)
 242 |     | 
 243 |     |       // We move '64' bits forward to reach the following location:
 244 |     |       //
 245 |     |       //      pointer + 8
 246 |     |       //             \
 247 |     |       //              |
 248 |     |       //  +--+--------+---------------------------+---------------------------+
 249 |     |       //  |  | 8 byte |          27 byte          |          27 byte          |
 250 |     |       //  +--+--------+---------------------------+---------------------------+
 251 |     |       //  |  |        |                           |
 252 |     |       //  |  |        |                            \
 253 |     |       //  |  |        |                             sqrtInversePrice
 254 |     |       //  |  |         \
 255 |     |       //  |  |          sqrtPrice
 256 |     |       //  |   \
 257 |     |       //  |    logPrice
 258 |     |       //   \
 259 |     |       //    heightPrice
 260 |     |       //
 261 |     |       // Then we move '256' bits backward to point to the beginning of the slot
 262 |     |       // whose least significant '64' bits are supposed to host 'logPrice'.
 263 |     |       //
 264 |     |       // '64 - 256' bits == '-24' bytes.
 265 |     |       // The subtraction is safe because of the input requirement on 'pointer'.
 266 |     |       mstore(sub(pointer, 24), logPrice)
 267 |     | 
 268 |     |       // We move '256' bits backward to point to the beginning of the slot
 269 |     |       // whose least significant '16' bits are supposed to host 'heightPrice'.
 270 |     |       //
 271 |     |       // '0 - 256' bits == '-32' bytes.
 272 |     |       // The subtraction is safe because of the input requirement on 'pointer'.
 273 |     |       mstore(sub(pointer, 32), heightPrice)
 274 |     | 
 275 |     |       // The preceding slot is restored.
 276 |     |       mstore(precedingPointer, precedingSlot)
 277 |     |     }
 278 |     |   }
 279 |     | 
 280 |     |   /// @notice Returns the height of a price given its memory pointer with the 
 281 |     |   /// following layout:
 282 |     |   ///
 283 |     |   ///       pointer
 284 |     |   ///      /
 285 |     |   ///     |
 286 |     |   ///  +--+--------+---------------------------+---------------------------+
 287 |     |   ///  |  | 8 byte |          27 byte          |          27 byte          |
 288 |     |   ///  +--+--------+---------------------------+---------------------------+
 289 |     |   ///  |  |        |                           |
 290 |     |   ///  |  |        |                            \
 291 |     |   ///  |  |        |                             sqrtInversePrice
 292 |     |   ///  |  |         \
 293 |     |   ///  |  |          sqrtPrice
 294 |     |   ///  |   \
 295 |     |   ///  |    logPrice
 296 |     |   ///   \
 297 |     |   ///    heightPrice
 298 |     |   ///
 299 | *   |   function height(
 300 |     |     uint256 pointer
 301 |     |   ) internal pure returns (
 302 | *   |     X15 value
 303 |     |   ) {
 304 | *   |     assembly {
 305 |     |       // We move '2' bytes backward to read the slot whose most significant
 306 |     |       // '16' bits host 'height'.
 307 |     |       //
 308 |     |       //    pointer - 2
 309 |     |       //   /
 310 |     |       //  |
 311 |     |       //  +--+--------+---------------------------+---------------------------+
 312 |     |       //  |  | 8 byte |          27 byte          |          27 byte          |
 313 |     |       //  +--+--------+---------------------------+---------------------------+
 314 |     |       //  |  |        |                           |
 315 |     |       //  |  |        |                            \
 316 |     |       //  |  |        |                             sqrtInversePrice
 317 |     |       //  |  |         \
 318 |     |       //  |  |          sqrtPrice
 319 |     |       //  |   \
 320 |     |       //  |    logPrice
 321 |     |       //   \
 322 |     |       //    heightPrice
 323 |     |       //
 324 |     |       // Then we shift the content by '240' bits to the right in order to get
 325 |     |       // 'height'.
 326 |     |       //
 327 |     |       // The subtraction is safe, because the pointer refer to a price with
 328 |     |       // height and therefore its value is not less than '2'.
 329 |     |       value := shr(240, mload(sub(pointer, 2)))
 330 |     |     }
 331 |     |   }
 332 |     | 
 333 |     |   /// @notice Returns the logarithm of a price given its memory pointer with
 334 |     |   /// the following layout:
 335 |     |   ///
 336 |     |   ///       pointer
 337 |     |   ///      /
 338 |     |   ///     |
 339 |     |   ///  +--+--------+---------------------------+---------------------------+
 340 |     |   ///  |  | 8 byte |          27 byte          |          27 byte          |
 341 |     |   ///  +--+--------+---------------------------+---------------------------+
 342 |     |   ///  |  |        |                           |
 343 |     |   ///  |  |        |                            \
 344 |     |   ///  |  |        |                             sqrtInversePrice
 345 |     |   ///  |  |         \
 346 |     |   ///  |  |          sqrtPrice
 347 |     |   ///  |   \
 348 |     |   ///  |    logPrice
 349 |     |   ///   \
 350 |     |   ///    heightPrice
 351 |     |   ///
 352 | *   |   function log(
 353 |     |     uint256 pointer
 354 |     |   ) internal pure returns (
 355 | *   |     X59 logPrice
 356 |     |   ) {
 357 | *   |     assembly {
 358 |     |       // The given pointer refers to the slot whose most significant '64' bits
 359 |     |       // host 'logPrice'. We read this slot and then we shift the content by
 360 |     |       // '192' bits to the right in order to get 'logPrice'.
 361 |     |       logPrice := shr(192, mload(pointer))
 362 |     |     }
 363 |     |   }
 364 |     | 
 365 |     |   /// @notice Returns the 'sqrtPrice' or 'sqrtInversePrice' given a memory 
 366 |     |   /// pointer with the following layout:
 367 |     |   ///
 368 |     |   ///       pointer
 369 |     |   ///      /
 370 |     |   ///     |
 371 |     |   ///  +--+--------+---------------------------+---------------------------+
 372 |     |   ///  |  | 8 byte |          27 byte          |          27 byte          |
 373 |     |   ///  +--+--------+---------------------------+---------------------------+
 374 |     |   ///  |  |        |                           |
 375 |     |   ///  |  |        |                            \
 376 |     |   ///  |  |        |                             sqrtInversePrice
 377 |     |   ///  |  |         \
 378 |     |   ///  |  |          sqrtPrice
 379 |     |   ///  |   \
 380 |     |   ///  |    logPrice
 381 |     |   ///   \
 382 |     |   ///    heightPrice
 383 |     |   ///
 384 | *   |   function sqrt(
 385 |     |     uint256 pointer,
 386 |     |     bool inverse
 387 |     |   ) internal pure returns (
 388 | *   |     X216 value
 389 |     |   ) {
 390 | *   |     assembly {
 391 |     |       // If 'inverse == true' then we move '35' bytes forward to read the slot
 392 |     |       // whose most significant '216' bits host 'sqrtPriceInverse'.
 393 |     |       //
 394 |     |       //                                  pointer + 35
 395 |     |       //                                         \
 396 |     |       //                                          |
 397 |     |       //  +--+--------+---------------------------+---------------------------+
 398 |     |       //  |  | 8 byte |          27 byte          |          27 byte          |
 399 |     |       //  +--+--------+---------------------------+---------------------------+
 400 |     |       //  |  |        |                           |
 401 |     |       //  |  |        |                            \
 402 |     |       //  |  |        |                             sqrtInversePrice
 403 |     |       //  |  |         \
 404 |     |       //  |  |          sqrtPrice
 405 |     |       //  |   \
 406 |     |       //  |    logPrice
 407 |     |       //   \
 408 |     |       //    heightPrice
 409 |     |       //
 410 |     |       // Then we shift the content by '40' bits to the right in order to get
 411 |     |       // 'sqrtPriceInverse'.
 412 |     |       //
 413 |     |       // If 'inverse == false' then we move '8' bytes forward to read the slot
 414 |     |       // whose most significant '216' bits host 'sqrtPrice'.
 415 |     |       //
 416 |     |       //      pointer + 8
 417 |     |       //             \
 418 |     |       //              |
 419 |     |       //  +--+--------+---------------------------+---------------------------+
 420 |     |       //  |  | 8 byte |          27 byte          |          27 byte          |
 421 |     |       //  +--+--------+---------------------------+---------------------------+
 422 |     |       //  |  |        |                           |
 423 |     |       //  |  |        |                            \
 424 |     |       //  |  |        |                             sqrtInversePrice
 425 |     |       //  |  |         \
 426 |     |       //  |  |          sqrtPrice
 427 |     |       //  |   \
 428 |     |       //  |    logPrice
 429 |     |       //   \
 430 |     |       //    heightPrice
 431 |     |       //
 432 |     |       // Then we shift the content by '40' bits to the right in order to get
 433 |     |       // 'sqrtPrice'.
 434 |     |       //
 435 |     |       // The additions and the multiplication are safe because 
 436 |     |       // 'iszero(inverse)' is a boolean.
 437 |     |       value := shr(
 438 |     |         40,
 439 |     |         mload(
 440 |     |           add(
 441 |     |             sub(35, mul(27, iszero(inverse))), // inverse ? 35 : 8
 442 |     |             pointer
 443 |     |           )
 444 |     |         )
 445 |     |       )
 446 |     |     }
 447 |     |   }
 448 |     | 
 449 |     |   /// @notice Copies a price from one memory pointer to another each with the 
 450 |     |   /// following layout:
 451 |     |   ///
 452 |     |   ///  pointer
 453 |     |   ///     |
 454 |     |   ///     +--------+---------------------------+---------------------------+
 455 |     |   ///     | 8 byte |          27 byte          |          27 byte          |
 456 |     |   ///     +--------+---------------------------+---------------------------+
 457 |     |   ///     |        |                           |
 458 |     |   ///     |        |                            \
 459 |     |   ///     |        |                             sqrtInversePrice
 460 |     |   ///     |         \
 461 |     |   ///     |          sqrtPrice
 462 |     |   ///      \
 463 |     |   ///       logPrice
 464 |     |   ///
 465 | *   |   function copyPrice(
 466 |     |     uint256 pointer0,
 467 |     |     uint256 pointer1
 468 |     |   ) internal pure {
 469 | *   |     assembly {
 470 |     |       // Each price contains '62' bytes which is copied from one place to the
 471 |     |       // next.
 472 |     |       mcopy(pointer0, pointer1, 62)
 473 |     |     }
 474 |     |   }
 475 |     | 
 476 |     |   /// @notice Copies a price with height from one memory pointer to another
 477 |     |   /// each with the following layout:
 478 |     |   ///
 479 |     |   ///       pointer
 480 |     |   ///      /
 481 |     |   ///     |
 482 |     |   ///  +--+--------+---------------------------+---------------------------+
 483 |     |   ///  |  | 8 byte |          27 byte          |          27 byte          |
 484 |     |   ///  +--+--------+---------------------------+---------------------------+
 485 |     |   ///  |  |        |                           |
 486 |     |   ///  |  |        |                            \
 487 |     |   ///  |  |        |                             sqrtInversePrice
 488 |     |   ///  |  |         \
 489 |     |   ///  |  |          sqrtPrice
 490 |     |   ///  |   \
 491 |     |   ///  |    logPrice
 492 |     |   ///   \
 493 |     |   ///    heightPrice
 494 |     |   ///
 495 |     |   function copyPriceWithHeight(
 496 |     |     uint256 pointer0,
 497 |     |     uint256 pointer1
 498 |     |   ) internal pure {
 499 |     |     assembly {
 500 |     |       // Each price contains '64' bytes which is copied from one place to the
 501 |     |       // next. We move two bytes backward to point to the beginning of 'height'
 502 |     |       // as opposed to the end of 'height':
 503 |     |       //
 504 |     |       //    pointer
 505 |     |       //   /
 506 |     |       //  |
 507 |     |       //  +--+--------+---------------------------+---------------------------+
 508 |     |       //  |  | 8 byte |          27 byte          |          27 byte          |
 509 |     |       //  +--+--------+---------------------------+---------------------------+
 510 |     |       //  |  |        |                           |
 511 |     |       //  |  |        |                            \
 512 |     |       //  |  |        |                             sqrtInversePrice
 513 |     |       //  |  |         \
 514 |     |       //  |  |          sqrtPrice
 515 |     |       //  |   \
 516 |     |       //  |    logPrice
 517 |     |       //   \
 518 |     |       //    heightPrice
 519 |     |       //
 520 |     |       // The subtractions are safe, because both pointers refer to prices with
 521 |     |       // height and therefore their values are not less than '2'.
 522 |     |       mcopy(sub(pointer0, 2), sub(pointer1, 2), 64)
 523 |     |     }
 524 |     |   }
 525 |     | 
 526 |     |   /// @notice Given the memory pointer for a pair of prices with height, this
 527 |     |   /// function reads the corresponding horizontal and vertical coordinates.
 528 |     |   /// 'pointer' refers to the first price and 'pointer + 64' refers to the
 529 |     |   /// second one.
 530 |     |   function segment(
 531 |     |     uint256 pointer
 532 |     |   ) internal pure returns (
 533 |     |     X59 b0,
 534 |     |     X59 b1,
 535 |     |     X15 c0,
 536 |     |     X15 c1
 537 |     |   ) {
 538 |     |     c0 = pointer.height();
 539 |     |     b0 = pointer.log();
 540 |     | 
 541 |     |     // We move '64' bytes forward to point to the second price.
 542 |     |     unchecked {
 543 |     |       pointer += 64;
 544 |     |     }
 545 |     | 
 546 |     |     c1 = pointer.height();
 547 |     |     b1 = pointer.log();
 548 |     |   }
 549 |     | }

R:/LIAT.AI/nofeeswap-core/contracts/utilities/Tag.sol
   1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
   2 |     | pragma solidity ^0.8.28;
   3 |     | 
   4 |     | import {X59} from "./X59.sol";
   5 |     | 
   6 |     | // Type 'Tag' may refer to any of the followings:
   7 |     | //
   8 |     | // - Native token corresponding to 'Tag.wrap(0)'.
   9 |     | //
  10 |     | // - An ERC-20 address, i.e., 'Tag.wrap(uint256(uint160(tokenAddress)))'.
  11 |     | //
  12 |     | // - An ERC-1155 token whose value is determined by hashing token address and
  13 |     | // token ID, i.e., 
  14 |     | // 'Tag.wrap(uint256(keccak256(abi.encodePacked(tokenAddress, tokenId))))'.
  15 |     | //
  16 |     | // - An ERC-6909 token whose value is determined by hashing token address and
  17 |     | // token ID, i.e., 
  18 |     | // 'Tag.wrap(uint256(keccak256(abi.encodePacked(tokenAddress, tokenId))))'.
  19 |     | //
  20 |     | // - A nofeeswap position whose value is determined by hashing, poolId and
  21 |     | // min/max position boundaries, i.e., 
  22 |     | // 'Tag.wrap(uint256(keccak256(abi.encodePacked(
  23 |     | //    poolId,
  24 |     | //    qMin,
  25 |     | //    qMax
  26 |     | //  ))))'.
  27 |     | //
  28 |     | type Tag is uint256;
  29 |     | 
  30 |     | Tag constant native = Tag.wrap(0);
  31 |     | 
  32 |     | using {equals as ==, notEqual as !=} for Tag global;
  33 |     | using {lessThan as <, greaterThan as >} for Tag global;
  34 |     | using {
  35 |     |   lessThanOrEqualTo as <=,
  36 |     |   greaterThanOrEqualTo as >=
  37 |     | } for Tag global;
  38 |     | 
  39 |     | function equals(
  40 |     |   Tag value0,
  41 |     |   Tag value1
  42 |     | ) pure returns (
  43 |     |   bool result
  44 |     | ) {
  45 |     |   assembly {
  46 |     |     result := eq(value0, value1)
  47 |     |   }
  48 |     | }
  49 |     | 
  50 |     | function notEqual(
  51 |     |   Tag value0,
  52 |     |   Tag value1
  53 |     | ) pure returns (
  54 |     |   bool result
  55 |     | ) {
  56 |     |   return !(value0 == value1);
  57 |     | }
  58 |     | 
  59 |     | function lessThan(
  60 |     |   Tag value0,
  61 |     |   Tag value1
  62 |     | ) pure returns (
  63 |     |   bool result
  64 |     | ) {
  65 |     |   assembly {
  66 |     |     result := lt(value0, value1)
  67 |     |   }
  68 |     | }
  69 |     | 
  70 |     | function greaterThan(
  71 |     |   Tag value0,
  72 |     |   Tag value1
  73 |     | ) pure returns (
  74 |     |   bool result
  75 |     | ) {
  76 |     |   assembly {
  77 |     |     result := gt(value0, value1)
  78 |     |   }
  79 |     | }
  80 |     | 
  81 |     | function lessThanOrEqualTo(
  82 |     |   Tag value0,
  83 |     |   Tag value1
  84 |     | ) pure returns (
  85 |     |   bool result
  86 |     | ) {
  87 |     |   return !(value0 > value1);
  88 |     | }
  89 |     | 
  90 |     | function greaterThanOrEqualTo(
  91 |     |   Tag value0,
  92 |     |   Tag value1
  93 |     | ) pure returns (
  94 |     |   bool result
  95 |     | ) {
  96 |     |   return !(value0 < value1);
  97 |     | }
  98 |     | 
  99 |     | library TagLibrary {
 100 |     |   /// @notice Generates a tag given an ERC-20 address.
 101 |     |   /// @param tokenAddress The given ERC-20 address to be transformed to the
 102 |     |   /// type 'tag'.
 103 |     |   function tag(
 104 |     |     address tokenAddress
 105 |     |   ) internal pure returns (
 106 |     |     Tag tokenTag
 107 |     |   ) {
 108 |     |     assembly {
 109 |     |       tokenTag := and(tokenAddress, sub(shl(160, 1), 1))
 110 |     |     }
 111 |     |   }
 112 |     | 
 113 |     |   /// @notice Generates a tag given a multi-token address and tokenId.
 114 |     |   /// @param tokenAddress The given multi-token address to be transformed to
 115 |     |   /// the type 'tag'.
 116 |     |   /// @param tokenId The given multi-token id to be used to generate 'tag'.
 117 |     |   function tag(
 118 |     |     address tokenAddress,
 119 |     |     uint256 tokenId
 120 |     |   ) internal pure returns (
 121 |     |     Tag tokenTag
 122 |     |   ) {
 123 |     |     assembly {
 124 |     |       mstore(20, tokenAddress)
 125 |     |       mstore(0, tokenId)
 126 |     |       tokenTag := keccak256(0, 52)
 127 |     |     }
 128 |     |   }
 129 |     | 
 130 |     |   /// @notice Generates a tag given a nofeeswap liquidity position.
 131 |     |   /// @param poolId The pool identifier hosting this liquidity position.
 132 |     |   /// @param qMin Equal to '(2 ** 59) * log(pMin)' where 'pMin' is the left
 133 |     |   /// position boundary.
 134 |     |   /// @param qMax Equal to '(2 ** 59) * log(pMax)' where 'pMax' is the right
 135 |     |   /// position boundary.
 136 |     |   function tag(
 137 |     |     uint256 poolId,
 138 |     |     X59 qMin,
 139 |     |     X59 qMax
 140 |     |   ) internal pure returns (
 141 |     |     Tag positionTag
 142 |     |   ) {
 143 |     |     assembly {
 144 |     |       // Cache the free memory pointer so that the third memory slot can be
 145 |     |       // used for hashing.
 146 |     |       let freeMemoryPointer := mload(0x40)
 147 |     |       mstore(64, qMax)
 148 |     |       mstore(32, qMin)
 149 |     |       mstore(0, poolId)
 150 |     |       positionTag := keccak256(0, 96)
 151 |     |       // The 'freeMemoryPointer' is restored.
 152 |     |       mstore(0x40, freeMemoryPointer)
 153 |     |     }
 154 |     |   }
 155 |     | }

R:/LIAT.AI/nofeeswap-core/contracts/utilities/X111.sol
   1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
   2 |     | pragma solidity ^0.8.28;
   3 |     | 
   4 |     | import {X208} from "./X208.sol";
   5 |     | import {X216} from "./X216.sol";
   6 |     | import {FullMathLibrary} from "./FullMath.sol";
   7 |     | 
   8 |     | // Type 'X111' is dedicated to growth and liquidity values.
   9 |     | type X111 is int256;
  10 |     | 
  11 |     | using X111Library for X111 global;
  12 |     | 
  13 |     | X111 constant zeroX111 = X111.wrap(0);
  14 |     | X111 constant oneX111 = X111.wrap(1 << 111);
  15 |     | X111 constant maxGrowth = X111.wrap(1 << 127);
  16 |     | 
  17 |     | using {equals as ==, notEqual as !=} for X111 global;
  18 |     | using {lessThan as <, greaterThan as >} for X111 global;
  19 |     | using {
  20 |     |   lessThanOrEqualTo as <=,
  21 |     |   greaterThanOrEqualTo as >=
  22 |     | } for X111 global;
  23 |     | using {add as +, sub as -} for X111 global;
  24 |     | 
  25 |     | function equals(
  26 |     |   X111 value0,
  27 |     |   X111 value1
  28 |     | ) pure returns (
  29 |     |   bool result
  30 |     | ) {
  31 |     |   assembly {
  32 |     |     result := eq(value0, value1)
  33 |     |   }
  34 |     | }
  35 |     | 
  36 |     | function notEqual(
  37 |     |   X111 value0,
  38 |     |   X111 value1
  39 |     | ) pure returns (
  40 |     |   bool result
  41 |     | ) {
  42 |     |   return !(value0 == value1);
  43 |     | }
  44 |     | 
  45 |     | function lessThan(
  46 |     |   X111 value0,
  47 |     |   X111 value1
  48 |     | ) pure returns (
  49 |     |   bool result
  50 |     | ) {
  51 |     |   assembly {
  52 |     |     result := slt(value0, value1)
  53 |     |   }
  54 |     | }
  55 |     | 
  56 |     | function greaterThan(
  57 |     |   X111 value0,
  58 |     |   X111 value1
  59 |     | ) pure returns (
  60 |     |   bool result
  61 |     | ) {
  62 |     |   assembly {
  63 |     |     result := sgt(value0, value1)
  64 |     |   }
  65 |     | }
  66 |     | 
  67 |     | function lessThanOrEqualTo(
  68 |     |   X111 value0,
  69 |     |   X111 value1
  70 |     | ) pure returns (
  71 |     |   bool result
  72 |     | ) {
  73 |     |   return !(value0 > value1);
  74 |     | }
  75 |     | 
  76 |     | function greaterThanOrEqualTo(
  77 |     |   X111 value0,
  78 |     |   X111 value1
  79 |     | ) pure returns (
  80 |     |   bool result
  81 |     | ) {
  82 |     |   return !(value0 < value1);
  83 |     | }
  84 |     | 
  85 |     | // Overflow/underflow should be avoided externally.
  86 |     | function add(
  87 |     |   X111 value0,
  88 |     |   X111 value1
  89 |     | ) pure returns (
  90 |     |   X111 result
  91 |     | ) {
  92 |     |   assembly {
  93 |     |     result := add(value0, value1)
  94 |     |   }
  95 |     | }
  96 |     | 
  97 |     | // Overflow/underflow should be avoided externally.
  98 |     | function sub(
  99 |     |   X111 value0,
 100 |     |   X111 value1
 101 |     | ) pure returns (
 102 |     |   X111 result
 103 |     | ) {
 104 |     |   assembly {
 105 |     |     result := sub(value0, value1)
 106 |     |   }
 107 |     | }
 108 |     | 
 109 |     | function min(
 110 |     |   X111 value0,
 111 |     |   X111 value1
 112 |     | ) pure returns (
 113 |     |   X111 result
 114 |     | ) {
 115 |     |   return (value0 < value1) ? value0 : value1;
 116 |     | }
 117 |     | 
 118 |     | function max(
 119 |     |   X111 value0,
 120 |     |   X111 value1
 121 |     | ) pure returns (
 122 |     |   X111 result
 123 |     | ) {
 124 |     |   return (value0 < value1) ? value1 : value0;
 125 |     | }
 126 |     | 
 127 |     | library X111Library {
 128 |     |   /// @notice Calculates 'liquidity == growth * shares'.
 129 |     |   /// 'growth' should not be less than 'oneX111'.
 130 |     |   /// 'growth' should be less than or equal to '1 << 127'.
 131 |     |   /// 'shares' should be less than '1 << 127'
 132 |     |   function times(
 133 |     |     X111 growth,
 134 |     |     uint256 shares
 135 |     |   ) internal pure returns (
 136 |     |     X111 liquidity
 137 |     |   ) {
 138 |     |     assembly {
 139 |     |       // Multiplication is safe because of the input requirements.
 140 |     |       liquidity := mul(growth, shares)
 141 |     |     }
 142 |     |   }
 143 |     | 
 144 |     |   /// @notice Calculates 'liquidity == growth * shares'.
 145 |     |   /// 'growth' should not be less than 'oneX111'.
 146 |     |   /// 'growth' should be less than or equal to '1 << 127'.
 147 |     |   /// 'shares' should be greater than '- (1 << 127)'.
 148 |     |   /// 'shares' should be less than '1 << 127'.
 149 |     |   function times(
 150 |     |     X111 growth,
 151 |     |     int256 shares
 152 |     |   ) internal pure returns (
 153 |     |     X111 liquidity
 154 |     |   ) {
 155 |     |     assembly {
 156 |     |       // Multiplication is safe because of the input requirements.
 157 |     |       liquidity := mul(growth, shares)
 158 |     |     }
 159 |     |   }
 160 |     | 
 161 |     |   /// @notice Calculates
 162 |     |   /// '(value * multiplier) / ((2 ** 119) * exp(-8))'
 163 |     |   /// 'growth' should not be less than 'oneX111'.
 164 |     |   /// 'growth' should be less than or equal to '1 << 127'.
 165 |     |   /// 'multiplier' should be non-negative and less than 'oneX216'.
 166 |     |   function mulDivByExpInv8(
 167 |     |     X111 growth,
 168 |     |     X216 multiplier
 169 |     |   ) internal pure returns (
 170 |     |     X208 product
 171 |     |   ) {
 172 |     |     // Both castings are safe because
 173 |     |     // 'growth >= oneX111' and 'multiplier >= zeroX216'
 174 |     |     ( ,  , uint256 q2) = FullMathLibrary.mul768(
 175 |     |       // (2 ** 244) * exp(8)
 176 |     |       0xBA4F53EA38636F85F007042540AE8EF33225E9A7AB4F4473A86D4A8FDD1A5B82,
 177 |     |       // The shift is safe because 'oneX111 <= growth <= (1 << 127)'
 178 |     |       uint256(X111.unwrap(growth)) << 110,
 179 |     |       // The shift is safe because '0 <= multiplier <= oneX216'
 180 |     |       uint256(X216.unwrap(multiplier)) << 39
 181 |     |     );
 182 |     |     product = X208.wrap(q2);
 183 |     |   }
 184 |     | }

R:/LIAT.AI/nofeeswap-core/contracts/utilities/X127.sol
   1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
   2 |     | pragma solidity ^0.8.28;
   3 |     | 
   4 |     | import {X23} from "./X23.sol";
   5 |     | import {X216} from "./X216.sol";
   6 |     | import {SafeAddFailed} from "./Errors.sol";
   7 |     | import {FullMathLibrary} from "./FullMath.sol";
   8 |     | 
   9 |     | // Type 'X127' is used for 'sqrtOffset', 'sqrtInverseOffset', and token
  10 |     | // amounts.
  11 |     | type X127 is int256;
  12 |     | 
  13 |     | using X127Library for X127 global;
  14 |     | 
  15 |     | X127 constant oneX127 = X127.wrap(1 << 127);
  16 |     | X127 constant zeroX127 = X127.wrap(0);
  17 |     | X127 constant epsilonX127 = X127.wrap(1);
  18 |     | // 104 = 231 - 127 digits of non-decimal
  19 |     | X127 constant accruedMax = X127.wrap((1 << 231) - 1);
  20 |     | 
  21 |     | using {equals as ==, notEquals as !=} for X127 global;
  22 |     | using {lessThan as <, greaterThan as >} for X127 global;
  23 |     | using {
  24 |     |   lessThanOrEqualTo as <=,
  25 |     |   greaterThanOrEqualTo as >=
  26 |     | } for X127 global;
  27 |     | using {add as +, sub as -, safeAdd as &} for X127 global;
  28 |     | 
  29 |     | function equals(
  30 |     |   X127 value0,
  31 |     |   X127 value1
  32 |     | ) pure returns (
  33 |     |   bool result
  34 |     | ) {
  35 |     |   assembly {
  36 |     |     result := eq(value0, value1)
  37 |     |   }
  38 |     | }
  39 |     | 
  40 |     | function notEquals(
  41 |     |   X127 value0,
  42 |     |   X127 value1
  43 |     | ) pure returns (
  44 |     |   bool result
  45 |     | ) {
  46 |     |   return !(value0 == value1);
  47 |     | }
  48 |     | 
  49 |     | function lessThan(
  50 |     |   X127 value0,
  51 |     |   X127 value1
  52 |     | ) pure returns (
  53 |     |   bool result
  54 |     | ) {
  55 |     |   assembly {
  56 |     |     result := slt(value0, value1)
  57 |     |   }
  58 |     | }
  59 |     | 
  60 |     | function greaterThan(
  61 |     |   X127 value0,
  62 |     |   X127 value1
  63 |     | ) pure returns (
  64 |     |   bool result
  65 |     | ) {
  66 |     |   assembly {
  67 |     |     result := sgt(value0, value1)
  68 |     |   }
  69 |     | }
  70 |     | 
  71 |     | function lessThanOrEqualTo(
  72 |     |   X127 value0,
  73 |     |   X127 value1
  74 |     | ) pure returns (
  75 |     |   bool result
  76 |     | ) {
  77 |     |   return !(value0 > value1);
  78 |     | }
  79 |     | 
  80 |     | function greaterThanOrEqualTo(
  81 |     |   X127 value0,
  82 |     |   X127 value1
  83 |     | ) pure returns (
  84 |     |   bool result
  85 |     | ) {
  86 |     |   return !(value0 < value1);
  87 |     | }
  88 |     | 
  89 |     | // Overflow/underflow should be avoided externally.
  90 |     | function add(
  91 |     |   X127 value0,
  92 |     |   X127 value1
  93 |     | ) pure returns (
  94 |     |   X127 result
  95 |     | ) {
  96 |     |   assembly {
  97 |     |     result := add(value0, value1)
  98 |     |   }
  99 |     | }
 100 |     | 
 101 |     | // Overflow/underflow should be avoided externally.
 102 |     | function sub(
 103 |     |   X127 value0,
 104 |     |   X127 value1
 105 |     | ) pure returns (
 106 |     |   X127 result
 107 |     | ) {
 108 |     |   assembly {
 109 |     |     result := sub(value0, value1)
 110 |     |   }
 111 |     | }
 112 |     | 
 113 |     | // Throws in case of overflow/underflow.
 114 |     | function safeAdd(
 115 |     |   X127 value0,
 116 |     |   X127 value1
 117 |     | ) pure returns (
 118 |     |   X127 result
 119 |     | ) {
 120 |     |   // We first add the two values unsafely and then examine the result.
 121 |     |   result = value0 + value1;
 122 |     |   
 123 |     |   // The following requirement is satisfied if and only if 'result' does not
 124 |     |   // overflow or underflow. Because,
 125 |     |   // - overflow implies that both 'value0' and 'value1' are positive but
 126 |     |   // 'result' is negative which contradicts the following requirement.
 127 |     |   // - underflow implies that both 'value0' and 'value1' are negative but
 128 |     |   // 'result' is positive which contradicts the following requirement as well.
 129 |     |   // - Lastly, in case of no overflow/underflow, the following requirement is
 130 |     |   // trivial.
 131 |     |   require(
 132 |     |     (value1 >= zeroX127) == (result >= value0),
 133 |     |     SafeAddFailed(value0, value1)
 134 |     |   );
 135 |     | }
 136 |     | 
 137 |     | function min(
 138 |     |   X127 value0,
 139 |     |   X127 value1
 140 |     | ) pure returns (
 141 |     |   X127 result
 142 |     | ) {
 143 |     |   return (value0 < value1) ? value0 : value1;
 144 |     | }
 145 |     | 
 146 |     | function max(
 147 |     |   X127 value0,
 148 |     |   X127 value1
 149 |     | ) pure returns (
 150 |     |   X127 result
 151 |     | ) {
 152 |     |   return (value0 < value1) ? value1 : value0;
 153 |     | }
 154 |     | 
 155 |     | library X127Library {
 156 |     |   /// @notice Calculates 'value * multiplier / (2 ** 23)'
 157 |     |   /// 'value' should be non-negative.
 158 |     |   /// 'value * multiplier' should be less than '2 ** 256'.
 159 |     |   function times(
 160 |     |     X127 value,
 161 |     |     X23 multiplier
 162 |     |   ) internal pure returns (
 163 |     |     X127 product
 164 |     |   ) {
 165 |     |     // The multiplication is safe because of the input requirement.
 166 |     |     assembly {
 167 |     |       product := shr(23, mul(value, multiplier))
 168 |     |     }
 169 |     |   }
 170 |     | 
 171 |     |   /// @notice Calculates '(value * numerator) / denominator'
 172 |     |   /// Overflow and division by zero should be avoided externally.
 173 |     |   /// All input values should be non-negative.
 174 |     |   function mulDiv(
 175 |     |     X127 value,
 176 |     |     X216 numerator,
 177 |     |     X216 denominator
 178 |     |   ) internal pure returns (
 179 |     |     X127 result
 180 |     |   ) {
 181 |     |     result = X127.wrap(
 182 |     |       // Casting to 'int256' is safe because overflow is handled externally.
 183 |     |       int256(
 184 |     |         // The three castings are safe because of the input requirement.
 185 |     |         // The requirements of 'mulDiv' are met because overflow is handled
 186 |     |         // externally.
 187 |     |         FullMathLibrary.mulDiv(
 188 |     |           uint256(X127.unwrap(value)),
 189 |     |           uint256(X216.unwrap(numerator)),
 190 |     |           uint256(X216.unwrap(denominator))
 191 |     |         )
 192 |     |       )
 193 |     |     );
 194 |     |   }
 195 |     | 
 196 |     |   /// @notice Transforms type X127 to the integer 'value / (2 ** 127)' while
 197 |     |   /// maintaining the sign. Rounds towards negative infinity.
 198 |     |   function toInteger(
 199 |     |     X127 value
 200 |     |   ) internal pure returns (
 201 |     |     int256 result
 202 |     |   ) {
 203 |     |     assembly {
 204 |     |       result := sar(127, value)
 205 |     |     }
 206 |     |   }
 207 |     | 
 208 |     |   /// @notice Transforms type X127 to the integer 'value / (2 ** 127)' while
 209 |     |   /// maintaining the sign.
 210 |     |   /// Rounds towards positive infinity.
 211 |     |   /// 'value' should be greater than '- 2 ** 255'.
 212 |     |   function toIntegerRoundUp(
 213 |     |     X127 value
 214 |     |   ) internal pure returns (
 215 |     |     int256 result
 216 |     |   ) {
 217 |     |     // The inner subtraction is safe because 'value > - 2 ** 255'.
 218 |     |     // The outer subtraction is safe because 
 219 |     |     // '- 2 ** 128 < (0 - value) / (2 ** 127) < 2 ** 128'
 220 |     |     assembly {
 221 |     |       result := sub(0, sar(127, sub(0, value)))
 222 |     |     }
 223 |     |   }
 224 |     | }

R:/LIAT.AI/nofeeswap-core/contracts/utilities/X15.sol
   1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
   2 |     | pragma solidity ^0.8.28;
   3 |     | 
   4 |     | // Type 'X15' is dedicated to the vertical coordinates of the kernel
   5 |     | // breakpoints. The distribution of liquidity within every interval is governed
   6 |     | // by a piecewise linear kernel function. The kernel function is characterized
   7 |     | // by a list of breakpoints given by the pool owner. The vertical coordinate of
   8 |     | // each breakpoint is a number within the interval [0, 1] which is stored in
   9 |     | // 'X15' format, with '2 ** 15' representing 1.
  10 |     | type X15 is uint256;
  11 |     | 
  12 |     | X15 constant zeroX15 = X15.wrap(0);
  13 |     | X15 constant oneX15 = X15.wrap(1 << 15);
  14 |     | 
  15 |     | using {equals as ==, notEqual as !=} for X15 global;
  16 |     | using {lessThan as <, greaterThan as >} for X15 global;
  17 |     | using {
  18 |     |   lessThanOrEqualTo as <=,
  19 |     |   greaterThanOrEqualTo as >=
  20 |     | } for X15 global;
  21 |     | using {add as +, sub as -} for X15 global;
  22 |     | 
  23 |     | function equals(
  24 |     |   X15 value0,
  25 |     |   X15 value1
  26 |     | ) pure returns (
  27 |     |   bool result
  28 |     | ) {
  29 |     |   assembly {
  30 |     |     result := eq(value0, value1)
  31 |     |   }
  32 |     | }
  33 |     | 
  34 |     | function notEqual(
  35 |     |   X15 value0,
  36 |     |   X15 value1
  37 |     | ) pure returns (
  38 |     |   bool result
  39 |     | ) {
  40 |     |   return !(value0 == value1);
  41 |     | }
  42 |     | 
  43 |     | function lessThan(
  44 |     |   X15 value0,
  45 |     |   X15 value1
  46 |     | ) pure returns (
  47 |     |   bool result
  48 |     | ) {
  49 |     |   assembly {
  50 |     |     result := lt(value0, value1)
  51 |     |   }
  52 |     | }
  53 |     | 
  54 |     | function greaterThan(
  55 |     |   X15 value0,
  56 |     |   X15 value1
  57 |     | ) pure returns (
  58 |     |   bool result
  59 |     | ) {
  60 |     |   assembly {
  61 |     |     result := gt(value0, value1)
  62 |     |   }
  63 |     | }
  64 |     | 
  65 |     | function lessThanOrEqualTo(
  66 |     |   X15 value0,
  67 |     |   X15 value1
  68 |     | ) pure returns (
  69 |     |   bool result
  70 |     | ) {
  71 |     |   return !(value0 > value1);
  72 |     | }
  73 |     | 
  74 |     | function greaterThanOrEqualTo(
  75 |     |   X15 value0,
  76 |     |   X15 value1
  77 |     | ) pure returns (
  78 |     |   bool result
  79 |     | ) {
  80 |     |   return !(value0 < value1);
  81 |     | }
  82 |     | 
  83 |     | // Overflow should be avoided externally.
  84 |     | function add(
  85 |     |   X15 value0,
  86 |     |   X15 value1
  87 |     | ) pure returns (
  88 |     |   X15 result
  89 |     | ) {
  90 |     |   assembly {
  91 |     |     result := add(value0, value1)
  92 |     |   }
  93 |     | }
  94 |     | 
  95 |     | // Underflow should be avoided externally.
  96 |     | function sub(
  97 |     |   X15 value0,
  98 |     |   X15 value1
  99 |     | ) pure returns (
 100 |     |   X15 result
 101 |     | ) {
 102 |     |   assembly {
 103 |     |     result := sub(value0, value1)
 104 |     |   }
 105 |     | }

R:/LIAT.AI/nofeeswap-core/contracts/utilities/X208.sol
   1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
   2 |     | pragma solidity ^0.8.28;
   3 |     | 
   4 |     | import {X111} from "./X111.sol";
   5 |     | import {X216} from "./X216.sol";
   6 |     | import {FullMathLibrary} from "./FullMath.sol";
   7 |     | 
   8 |     | // Type 'X208' is dedicated to growth multipliers.
   9 |     | type X208 is uint256;
  10 |     | 
  11 |     | using X208Library for X208 global;
  12 |     | 
  13 |     | X208 constant zeroX208 = X208.wrap(0);
  14 |     | // (2 ** 208) * exp(+8)
  15 |     | X208 constant exp8X208 = X208.wrap(
  16 |     |   0x000000000BA4F53EA38636F85F007042540AE8EF33225E9A7AB4F4473A86D4A8
  17 |     | );
  18 |     | 
  19 |     | using {equals as ==, notEquals as !=} for X208 global;
  20 |     | using {lessThan as <, greaterThan as >} for X208 global;
  21 |     | using {
  22 |     |   lessThanOrEqualTo as <=,
  23 |     |   greaterThanOrEqualTo as >=
  24 |     | } for X208 global;
  25 |     | using {add as +, sub as -} for X208 global;
  26 |     | 
  27 |     | function equals(
  28 |     |   X208 value0,
  29 |     |   X208 value1
  30 |     | ) pure returns (
  31 |     |   bool result
  32 |     | ) {
  33 |     |   assembly {
  34 |     |     result := eq(value0, value1)
  35 |     |   }
  36 |     | }
  37 |     | 
  38 |     | function notEquals(
  39 |     |   X208 value0,
  40 |     |   X208 value1
  41 |     | ) pure returns (
  42 |     |   bool result
  43 |     | ) {
  44 |     |   return !(value0 == value1);
  45 |     | }
  46 |     | 
  47 |     | function lessThan(
  48 |     |   X208 value0,
  49 |     |   X208 value1
  50 |     | ) pure returns (
  51 |     |   bool result
  52 |     | ) {
  53 |     |   assembly {
  54 |     |     result := lt(value0, value1)
  55 |     |   }
  56 |     | }
  57 |     | 
  58 |     | function greaterThan(
  59 |     |   X208 value0,
  60 |     |   X208 value1
  61 |     | ) pure returns (
  62 |     |   bool result
  63 |     | ) {
  64 |     |   assembly {
  65 |     |     result := gt(value0, value1)
  66 |     |   }
  67 |     | }
  68 |     | 
  69 |     | function lessThanOrEqualTo(
  70 |     |   X208 value0,
  71 |     |   X208 value1
  72 |     | ) pure returns (
  73 |     |   bool result
  74 |     | ) {
  75 |     |   return !(value0 > value1);
  76 |     | }
  77 |     | 
  78 |     | function greaterThanOrEqualTo(
  79 |     |   X208 value0,
  80 |     |   X208 value1
  81 |     | ) pure returns (
  82 |     |   bool result
  83 |     | ) {
  84 |     |   return !(value0 < value1);
  85 |     | }
  86 |     | 
  87 |     | // Overflow should be avoided externally.
  88 |     | function add(
  89 |     |   X208 value0,
  90 |     |   X208 value1
  91 |     | ) pure returns (
  92 |     |   X208 result
  93 |     | ) {
  94 |     |   assembly {
  95 |     |     result := add(value0, value1)
  96 |     |   }
  97 |     | }
  98 |     | 
  99 |     | // Underflow should be avoided externally.
 100 |     | function sub(
 101 |     |   X208 value0,
 102 |     |   X208 value1
 103 |     | ) pure returns (
 104 |     |   X208 result
 105 |     | ) {
 106 |     |   assembly {
 107 |     |     result := sub(value0, value1)
 108 |     |   }
 109 |     | }
 110 |     | 
 111 |     | library X208Library {
 112 |     |   /// @notice Calculates '(value * numerator) / denominator'
 113 |     |   /// Overflow and division by zero should be avoided externally.
 114 |     |   /// 'numerator' and 'denominator' values should be non-negative.
 115 |     |   function mulDiv(
 116 |     |     X208 value,
 117 |     |     X216 numerator,
 118 |     |     X216 denominator
 119 |     |   ) internal pure returns (
 120 |     |     X208 result
 121 |     |   ) {
 122 |     |     // Both castings are safe because of the non-negative requirement on both
 123 |     |     // 'numerator' and 'denominator'.
 124 |     |     result = X208.wrap(
 125 |     |       FullMathLibrary.mulDiv(
 126 |     |         X208.unwrap(value),
 127 |     |         uint256(X216.unwrap(numerator)),
 128 |     |         uint256(X216.unwrap(denominator))
 129 |     |       )
 130 |     |     );
 131 |     |   }
 132 |     | 
 133 |     |   /// @notice Calculates
 134 |     |   /// '(value * multiplier) / ((2 ** 313) * exp(-8))'
 135 |     |   /// 'multiplier' should be non-negative.
 136 |     |   function mulDivByExpInv8(
 137 |     |     X208 value,
 138 |     |     X216 multiplier
 139 |     |   ) internal pure returns (
 140 |     |     X111 product
 141 |     |   ) {
 142 |     |     ( ,  , uint256 q2) = FullMathLibrary.mul768(
 143 |     |       // (2 ** 244) * exp(8)
 144 |     |       0xBA4F53EA38636F85F007042540AE8EF33225E9A7AB4F4473A86D4A8FDD1A5B82,
 145 |     |       X208.unwrap(value),
 146 |     |       // Casting is safe because of the non-negative requirement on
 147 |     |       // 'multiplier'.
 148 |     |       uint256(X216.unwrap(multiplier))
 149 |     |     );
 150 |     |     unchecked {
 151 |     |       // Casting is safe because 'q2 >> 45' never exceeds 'type(int256).max'.
 152 |     |       // '45 == 244 + 208 + 216 - 512 - 111'
 153 |     |       product = X111.wrap(int256(q2 >> 45));
 154 |     |     }
 155 |     |   }
 156 |     | }

R:/LIAT.AI/nofeeswap-core/contracts/utilities/X216.sol
   1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
   2 |     | pragma solidity ^0.8.28;
   3 |     | 
   4 |     | import {FullMathLibrary} from "./FullMath.sol";
   5 |     | 
   6 |     | // Type 'X216' is dedicated to integrals and sqrt of price values.
   7 |     | type X216 is int256;
   8 |     | 
   9 |     | using X216Library for X216 global;
  10 |     | 
  11 |     | X216 constant oneX216 = X216.wrap(1 << 216);
  12 |     | X216 constant zeroX216 = X216.wrap(0);
  13 |     | X216 constant epsilonX216 = X216.wrap(1);
  14 |     | // (2 ** 216) * exp(-8)
  15 |     | X216 constant expInverse8X216 = X216.wrap(
  16 |     |   0x00000000000015FC21041027ACBBFCD46780FEE71EAD23FBCB7F4A81E58767EF
  17 |     | );
  18 |     | 
  19 |     | using {equals as ==, notEquals as !=} for X216 global;
  20 |     | using {lessThan as <, greaterThan as >} for X216 global;
  21 |     | using {
  22 |     |   lessThanOrEqualTo as <=,
  23 |     |   greaterThanOrEqualTo as >=
  24 |     | } for X216 global;
  25 |     | using {add as +, sub as -} for X216 global;
  26 |     | using {mul as *, cheapMul as &} for X216 global;
  27 |     | using {mulDivByExpInv8 as %, mulDivByExpInv16 as ^} for X216 global;
  28 |     | 
  29 |     | function equals(
  30 |     |   X216 value0,
  31 |     |   X216 value1
  32 |     | ) pure returns (
  33 |     |   bool result
  34 |     | ) {
  35 |     |   assembly {
  36 |     |     result := eq(value0, value1)
  37 |     |   }
  38 |     | }
  39 |     | 
  40 |     | function notEquals(
  41 |     |   X216 value0,
  42 |     |   X216 value1
  43 |     | ) pure returns (
  44 |     |   bool result
  45 |     | ) {
  46 |     |   return !(value0 == value1);
  47 |     | }
  48 |     | 
  49 |     | function lessThan(
  50 |     |   X216 value0,
  51 |     |   X216 value1
  52 |     | ) pure returns (
  53 |     |   bool result
  54 |     | ) {
  55 |     |   assembly {
  56 |     |     result := slt(value0, value1)
  57 |     |   }
  58 |     | }
  59 |     | 
  60 |     | function greaterThan(
  61 |     |   X216 value0,
  62 |     |   X216 value1
  63 |     | ) pure returns (
  64 |     |   bool result
  65 |     | ) {
  66 |     |   assembly {
  67 |     |     result := sgt(value0, value1)
  68 |     |   }
  69 |     | }
  70 |     | 
  71 |     | function lessThanOrEqualTo(
  72 |     |   X216 value0,
  73 |     |   X216 value1
  74 |     | ) pure returns (
  75 |     |   bool result
  76 |     | ) {
  77 |     |   return !(value0 > value1);
  78 |     | }
  79 |     | 
  80 |     | function greaterThanOrEqualTo(
  81 |     |   X216 value0,
  82 |     |   X216 value1
  83 |     | ) pure returns (
  84 |     |   bool result
  85 |     | ) {
  86 |     |   return !(value0 < value1);
  87 |     | }
  88 |     | 
  89 |     | // Overflow/underflow should be avoided externally.
  90 |     | function add(
  91 |     |   X216 value0,
  92 |     |   X216 value1
  93 |     | ) pure returns (
  94 |     |   X216 result
  95 |     | ) {
  96 |     |   assembly {
  97 |     |     result := add(value0, value1)
  98 |     |   }
  99 |     | }
 100 |     | 
 101 |     | // Overflow/underflow should be avoided externally.
 102 |     | function sub(
 103 |     |   X216 value0,
 104 |     |   X216 value1
 105 |     | ) pure returns (
 106 |     |   X216 result
 107 |     | ) {
 108 |     |   assembly {
 109 |     |     result := sub(value0, value1)
 110 |     |   }
 111 |     | }
 112 |     | 
 113 |     | // Calculates '(value0 * value1) / (2 ** 216)'.
 114 |     | // Overflow/underflow should be avoided externally.
 115 |     | // Both values should be greater than '- 2 ** 255'.
 116 |     | function mul(
 117 |     |   X216 value0,
 118 |     |   X216 value1
 119 |     | ) pure returns (
 120 |     |   X216 result
 121 |     | ) {
 122 |     |   // Let 's := value0 * value1 - (2 ** 256 - 1) * p'
 123 |     |   // Let 'r := value0 * value1 - (2 ** 216) * q'
 124 |     |   // Then 's - r == (2 ** 216) * q' [modulo '2 ** 256 - 1']
 125 |     |   // Then 'q == (2 ** 40) * (s - r)' [modulo '2 ** 256 - 1']
 126 |     |   assembly {
 127 |     |     result := mulmod(
 128 |     |       addmod(
 129 |     |         // We account for the additional term '2 ** 256' in two's complement
 130 |     |         // representation by subtracting 'slt(value, 0)'. Because if a two's
 131 |     |         // complement representation 'value' correspond to a negative number,
 132 |     |         // we have:
 133 |     |         //
 134 |     |         // 'value - 2 ** 256 == value - 1' [modulo 2 ** 256 - 1]
 135 |     |         //
 136 |     |         // Both subtractions are safe due to the input requirement.
 137 |     |         mulmod(
 138 |     |           sub(value0, slt(value0, 0)),
 139 |     |           sub(value1, slt(value1, 0)),
 140 |     |           not(0)
 141 |     |         ), // s
 142 |     |         // Here, we do not need to account for the additional term '2 ** 256'
 143 |     |         // in two's complement representation because if a two's complement
 144 |     |         // representation 'value' is negative, we have:
 145 |     |         //
 146 |     |         // 'value - 2 ** 256 == value' [modulo 2 ** 216]
 147 |     |         //
 148 |     |         // The subtraction is safe because '2 ** 216 < 2 ** 256 - 1'.
 149 |     |         sub(not(0), mulmod(value0, value1, shl(216, 1))), // 0 - r
 150 |     |         not(0)
 151 |     |       ),
 152 |     |       shl(40, 1),
 153 |     |       not(0)
 154 |     |     )
 155 |     |   }
 156 |     | }
 157 |     | 
 158 |     | // Calculates '(value0 * value1) / (2 ** 216)'.
 159 |     | // 'value0' and 'value1' should be non-negative and less than 'oneX216'.
 160 |     | function cheapMul(
 161 |     |   X216 value0,
 162 |     |   X216 value1
 163 |     | ) pure returns (
 164 |     |   X216 result
 165 |     | ) {
 166 |     |   // Let 's := value0 * value1 - (2 ** 216 - 1) * p'
 167 |     |   // Let 'r := value0 * value1 - (2 ** 216) * q'
 168 |     |   // Then 's - r == q' [modulo '2 ** 216 - 1']
 169 |     |   // Because of the input requirements, 'q' does not exceed '2 ** 216 - 1'
 170 |     |   // which concludes that: 's - r == q'.
 171 |     |   assembly {
 172 |     |     result := addmod(
 173 |     |       mulmod(value0, value1, sub(shl(216, 1), 1)), // s
 174 |     |       // The subtraction is safe because the output of 'mulmod' does not exceed
 175 |     |       // '2 ** 216 - 1'.
 176 |     |       sub(sub(shl(216, 1), 1), mulmod(value0, value1, shl(216, 1))), // 0 - r
 177 |     |       sub(shl(216, 1), 1)
 178 |     |     )
 179 |     |   }
 180 |     | }
 181 |     | 
 182 |     | // Calculates '(value0 * value1) / ((2 ** 216) * exp(-8))'.
 183 |     | //
 184 |     | // The following approximation is used: '(2 ** 216) * exp(-8) ~= b / a' where
 185 |     | // 'a = 0xF8F6376C44' and 
 186 |     | // 'b = 0x1561650620DABB6A84B684E2A7E5A47CAA0A0905210083F0E3B551AABF84E9'
 187 |     | //
 188 |     | // Overflow should be avoided externally.
 189 |     | // Both values should be non-negative.
 190 |     | // 'value0' should be less than 'oneX216'.
 191 |     | function mulDivByExpInv8(
 192 |     |   X216 value0,
 193 |     |   X216 value1
 194 |     | ) pure returns (
 195 |     |   X216 result
 196 |     | ) {
 197 |     |   // Let 's := value0 * value1 * a - (2 ** 256) * p'
 198 |     |   // Let 'r := value0 * value1 * a - b * q'
 199 |     |   // Then 's - r == b * q' [modulo '2 ** 256']
 200 |     |   assembly {
 201 |     |     // Multiplication is safe because of the input requirement:
 202 |     |     // '0 <= value0 < oneX216'.
 203 |     |     result := mul(value0, 0xF8F6376C44)
 204 |     |     result := mul(
 205 |     |       // s - r
 206 |     |       sub(
 207 |     |         // s
 208 |     |         mul(result, value1),
 209 |     |         // r
 210 |     |         mulmod(
 211 |     |           result,
 212 |     |           value1,
 213 |     |           0x1561650620DABB6A84B684E2A7E5A47CAA0A0905210083F0E3B551AABF84E9 // b
 214 |     |         )
 215 |     |       ),
 216 |     |       // modular inverse of 'b' modulo '2 ** 256'
 217 |     |       0x28256938C4923FF15AB260970AA81F81C15E6F5EF3AF38DC210569E77DB19359
 218 |     |     )
 219 |     |   }
 220 |     | }
 221 |     | 
 222 |     | // Calculates '(value0 * value1) / ((2 ** 216) * exp(-16))'.
 223 |     | //
 224 |     | // The following approximation is used: '(2 ** 216) * exp(-16) ~= b / a' where
 225 |     | // 'a = 0x27D117D7B * 0x2EC3A856' and 
 226 |     | // 'b = 0xDBB82F7041B890FE67970A62A3568CC34DF9DCB17CC3A2A6A027850E7E3724F9'
 227 |     | //
 228 |     | // Overflow should be avoided externally.
 229 |     | // Both values should be non-negative.
 230 |     | // 'value0' and 'value1' should be less than 'oneX216'.
 231 |     | function mulDivByExpInv16(
 232 |     |   X216 value0,
 233 |     |   X216 value1
 234 |     | ) pure returns (
 235 |     |   X216 result
 236 |     | ) {
 237 |     |   // Let 's := value0 * value1 * a - (2 ** 256) * p'
 238 |     |   // Let 'r := value0 * value1 * a - b * q'
 239 |     |   // Then 's - r == b * q' [modulo '2 ** 256']
 240 |     |   assembly {
 241 |     |     // Both of the following multiplications are safe because of the input
 242 |     |     // requirements:
 243 |     |     // '0 <= value0 < oneX216'.
 244 |     |     // '0 <= value1 < oneX216'.
 245 |     |     value0 := mul(value0, 0x27D117D7B)
 246 |     |     value1 := mul(value1, 0x2EC3A856)
 247 |     |     result := mul(
 248 |     |       // s - r
 249 |     |       sub(
 250 |     |         // s
 251 |     |         mul(value0, value1),
 252 |     |         // r
 253 |     |         mulmod(
 254 |     |           value0,
 255 |     |           value1,
 256 |     |           // b
 257 |     |           0xDBB82F7041B890FE67970A62A3568CC34DF9DCB17CC3A2A6A027850E7E3724F9
 258 |     |         )
 259 |     |       ),
 260 |     |       // modular inverse of 'b' modulo '2 ** 256'
 261 |     |       0x7F6AF8233BADA11DD406B4458454ED9904D7AF796BE7AA4885B23E25B6985D49
 262 |     |     )
 263 |     |   }
 264 |     | }
 265 |     | 
 266 |     | function min(
 267 |     |   X216 value0,
 268 |     |   X216 value1
 269 |     | ) pure returns (
 270 |     |   X216 result
 271 |     | ) {
 272 |     |   return (value0 < value1) ? value0 : value1;
 273 |     | }
 274 |     | 
 275 |     | function max(
 276 |     |   X216 value0,
 277 |     |   X216 value1
 278 |     | ) pure returns (
 279 |     |   X216 result
 280 |     | ) {
 281 |     |   return (value0 < value1) ? value1 : value0;
 282 |     | }
 283 |     | 
 284 |     | /// @notice Returns the minimum of two unsigned fractions. '0 / 0' is 
 285 |     | /// interpreted as infinity. 'which == false' and 'which == true' indicate
 286 |     | /// '(numerator0, denominator0)' and '(numerator1, denominator1)',
 287 |     | /// respectively.
 288 |     | /// All four values should be non-negative.
 289 |     | /// At least one 'denominator' should be non-zero.
 290 |     | function minFractions(
 291 |     |   X216 numerator0,
 292 |     |   X216 denominator0,
 293 |     |   X216 numerator1,
 294 |     |   X216 denominator1
 295 |     | ) pure returns (
 296 |     |   X216 numerator,
 297 |     |   X216 denominator,
 298 |     |   bool which
 299 |     | ) {
 300 |     |   if (numerator0 == zeroX216) {
 301 |     |     if (denominator0 == zeroX216) {
 302 |     |       return (numerator1, denominator1, true);
 303 |     |     }
 304 |     |   }
 305 |     |   // Castings are safe because all four values are non-negative.
 306 |     |   (uint256 lsb0, uint256 msb0) = FullMathLibrary.mul512(
 307 |     |     uint256(X216.unwrap(numerator0)),
 308 |     |     uint256(X216.unwrap(denominator1))
 309 |     |   );
 310 |     |   (uint256 lsb1, uint256 msb1) = FullMathLibrary.mul512(
 311 |     |     uint256(X216.unwrap(numerator1)),
 312 |     |     uint256(X216.unwrap(denominator0))
 313 |     |   );
 314 |     |   (numerator, denominator, which) = 
 315 |     |     ((msb1 > msb0) || ((msb1 == msb0) && (lsb1 >= lsb0))) ? 
 316 |     |     (numerator0, denominator0, false) : 
 317 |     |     (numerator1, denominator1, true);
 318 |     | }
 319 |     | 
 320 |     | library X216Library {
 321 |     |   /// @notice Calculates 'value * exp(1 / (2 ** 60))'.
 322 |     |   /// Overflow should be avoided externally.
 323 |     |   /// 'value' should be non-negative.
 324 |     |   function multiplyByExpEpsilon(
 325 |     |     X216 value
 326 |     |   ) internal pure returns (
 327 |     |     X216 result
 328 |     |   ) {
 329 |     |     // Let 'a := floor((2 ** 256) * exp(-1 / (2 ** 60)))'
 330 |     |     // Let 'r := (2 ** 256) * value - a * q'
 331 |     |     // Let 'b := modularInverse(- a, 2 ** 256)'
 332 |     |     // Then 'q == b * r' [modulo '2 ** 256']
 333 |     |     assembly {
 334 |     |       result := mul(
 335 |     |         // r
 336 |     |         mulmod(
 337 |     |           value,
 338 |     |           // We are subtracting by 'a' because '2 ** 256' does not fit, which
 339 |     |           // is okay because the multiplication is done modulo 'a'.
 340 |     |           // 2 ** 256 - a
 341 |     |           0xFFFFFFFFFFFFFFF8000000000000002AAAAAAAAAAAAAAA001,
 342 |     |           // a
 343 |     |           0xFFFFFFFFFFFFFFF0000000000000007FFFFFFFFFFFFFFD555555555555555FFF
 344 |     |         ),
 345 |     |         // b
 346 |     |         0xAA3ED2381A8B1241D16168FD77EF989ED2B13BE12B716AA23F35ED0E39556001
 347 |     |       )
 348 |     |     }
 349 |     |   }
 350 |     | 
 351 |     |   /// @notice Calculates 'value / exp(1 / (2 ** 60))'.
 352 |     |   /// 'value' should be non-negative.
 353 |     |   function divideByExpEpsilon(
 354 |     |     X216 value
 355 |     |   ) internal pure returns (
 356 |     |     X216 result
 357 |     |   ) {
 358 |     |     assembly {
 359 |     |       // Let 'a := floor((2 ** 256 - 1) * exp(-1 / (2 ** 60)))'.
 360 |     |       // Let 's := value * a - q * not(0)'.
 361 |     |       // Let 'r := value * a'.
 362 |     |       // Then 's - r == - q * not(0) == q'.
 363 |     |       result := sub(
 364 |     |         // s
 365 |     |         mulmod(
 366 |     |           value,
 367 |     |           // a
 368 |     |           0xFFFFFFFFFFFFFFF0000000000000007FFFFFFFFFFFFFFD555555555555555FFE,
 369 |     |           not(0)
 370 |     |         ),
 371 |     |         // r
 372 |     |         mul(
 373 |     |           value,
 374 |     |           // a
 375 |     |           0xFFFFFFFFFFFFFFF0000000000000007FFFFFFFFFFFFFFD555555555555555FFE
 376 |     |         )
 377 |     |       )
 378 |     |     }
 379 |     |   }
 380 |     | 
 381 |     |   /// @notice Calculates '(value * numerator) / denominator'
 382 |     |   /// Overflow and division by zero should be avoided externally.
 383 |     |   /// All input values should be non-negative.
 384 |     |   function mulDiv(
 385 |     |     X216 value,
 386 |     |     X216 numerator,
 387 |     |     X216 denominator
 388 |     |   ) internal pure returns (
 389 |     |     X216 result
 390 |     |   ) {
 391 |     |     result = X216.wrap(
 392 |     |       // Casting is safe because overflow is handled externally.
 393 |     |       int256(
 394 |     |         // All three castings are safe due to the input requirements.
 395 |     |         FullMathLibrary.mulDiv(
 396 |     |           uint256(X216.unwrap(value)),
 397 |     |           uint256(X216.unwrap(numerator)),
 398 |     |           uint256(X216.unwrap(denominator))
 399 |     |         )
 400 |     |       )
 401 |     |     );
 402 |     |   }
 403 |     | 
 404 |     |   /// @notice Calculates '(value * numerator) / denominator' when 
 405 |     |   /// 'value * numerator < denominator * (denominator - 1)'.
 406 |     |   /// value should be non-negative
 407 |     |   function cheapMulDiv(
 408 |     |     X216 value,
 409 |     |     uint256 numerator,
 410 |     |     uint256 denominator
 411 |     |   ) internal pure returns (
 412 |     |     X216 result
 413 |     |   ) {
 414 |     |     result = X216.wrap(
 415 |     |       // Casting is safe because overflow is handled externally.
 416 |     |       int256(
 417 |     |         // The requirement of 'cheapMulDiv' is met because of the above input
 418 |     |         // requirement.
 419 |     |         FullMathLibrary.cheapMulDiv(
 420 |     |           // Casting is safe due to the input requirement in 'value'.
 421 |     |           uint256(X216.unwrap(value)),
 422 |     |           numerator,
 423 |     |           denominator
 424 |     |         )
 425 |     |       )
 426 |     |     );
 427 |     |   }
 428 |     | }

R:/LIAT.AI/nofeeswap-core/contracts/utilities/X23.sol
  1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
  2 |     | pragma solidity ^0.8.28;
  3 |     | 
  4 |     | // Type 'X23' is dedicated to pool growth ratios which determine the ratio of
  5 |     | // the accrued growth portions that belong to a pool owner. 'oneX23' represents
  6 |     | // 100%.
  7 |     | type X23 is uint256;
  8 |     | 
  9 |     | X23 constant zeroX23 = X23.wrap(0);
 10 |     | X23 constant oneX23 = X23.wrap(1 << 23);
 11 |     | 
 12 |     | using {add as +, sub as -} for X23 global;
 13 |     | 
 14 |     | // Overflow should be avoided externally.
 15 |     | function add(
 16 |     |   X23 value0,
 17 |     |   X23 value1
 18 |     | ) pure returns (
 19 |     |   X23 result
 20 |     | ) {
 21 |     |   assembly {
 22 |     |     result := add(value0, value1)
 23 |     |   }
 24 |     | }
 25 |     | 
 26 |     | // Underflow should be avoided externally.
 27 |     | function sub(
 28 |     |   X23 value0,
 29 |     |   X23 value1
 30 |     | ) pure returns (
 31 |     |   X23 result
 32 |     | ) {
 33 |     |   assembly {
 34 |     |     result := sub(value0, value1)
 35 |     |   }
 36 |     | }

R:/LIAT.AI/nofeeswap-core/contracts/utilities/X47.sol
   1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
   2 |     | pragma solidity ^0.8.28;
   3 |     | 
   4 |     | // Type 'X47' is dedicated to growth portions. Interval liquidity can grow as a
   5 |     | // result of a swap or a donation. A portion of this growth goes to the
   6 |     | // protocol. A portion of the remaining growth goes to the pool owner. These
   7 |     | // portions are stored as 'X47' type with 'oneX47' representing 100%.
   8 |     | type X47 is uint256;
   9 |     | 
  10 |     | X47 constant zeroX47 = X47.wrap(0);
  11 |     | // Largest valid value for growth portions:
  12 |     | X47 constant oneX47 = X47.wrap(1 << 47);
  13 |     | // An invalid value for growth portions which is used as an indicator:
  14 |     | X47 constant maxX47 = X47.wrap(type(uint48).max);
  15 |     | 
  16 |     | using {equals as ==, notEqual as !=} for X47 global;
  17 |     | using {lessThan as <, greaterThan as >} for X47 global;
  18 |     | using {
  19 |     |   lessThanOrEqualTo as <=,
  20 |     |   greaterThanOrEqualTo as >=
  21 |     | } for X47 global;
  22 |     | 
  23 |     | function equals(
  24 |     |   X47 value0,
  25 |     |   X47 value1
  26 |     | ) pure returns (
  27 |     |   bool result
  28 |     | ) {
  29 |     |   assembly {
  30 |     |     result := eq(value0, value1)
  31 |     |   }
  32 |     | }
  33 |     | 
  34 |     | function notEqual(
  35 |     |   X47 value0,
  36 |     |   X47 value1
  37 |     | ) pure returns (
  38 |     |   bool result
  39 |     | ) {
  40 |     |   return !(value0 == value1);
  41 |     | }
  42 |     | 
  43 |     | function lessThan(
  44 |     |   X47 value0,
  45 |     |   X47 value1
  46 |     | ) pure returns (
  47 |     |   bool result
  48 |     | ) {
  49 |     |   assembly {
  50 |     |     result := lt(value0, value1)
  51 |     |   }
  52 |     | }
  53 |     | 
  54 |     | function greaterThan(
  55 |     |   X47 value0,
  56 |     |   X47 value1
  57 |     | ) pure returns (
  58 |     |   bool result
  59 |     | ) {
  60 |     |   assembly {
  61 |     |     result := gt(value0, value1)
  62 |     |   }
  63 |     | }
  64 |     | 
  65 |     | function lessThanOrEqualTo(
  66 |     |   X47 value0,
  67 |     |   X47 value1
  68 |     | ) pure returns (
  69 |     |   bool result
  70 |     | ) {
  71 |     |   return !(value0 > value1);
  72 |     | }
  73 |     | 
  74 |     | function greaterThanOrEqualTo(
  75 |     |   X47 value0,
  76 |     |   X47 value1
  77 |     | ) pure returns (
  78 |     |   bool result
  79 |     | ) {
  80 |     |   return !(value0 < value1);
  81 |     | }
  82 |     | 
  83 |     | function min(
  84 |     |   X47 value0,
  85 |     |   X47 value1
  86 |     | ) pure returns (
  87 |     |   X47 result
  88 |     | ) {
  89 |     |   return (value0 < value1) ? value0 : value1;
  90 |     | }
  91 |     | 
  92 |     | function max(
  93 |     |   X47 value0,
  94 |     |   X47 value1
  95 |     | ) pure returns (
  96 |     |   X47 result
  97 |     | ) {
  98 |     |   return (value0 < value1) ? value1 : value0;
  99 |     | }

R:/LIAT.AI/nofeeswap-core/contracts/utilities/X59.sol
   1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
   2 |     | pragma solidity ^0.8.28;
   3 |     | 
   4 |     | import {X15} from "./X15.sol";
   5 |     | import {X74} from "./X74.sol";
   6 |     | import {X127} from "./X127.sol";
   7 |     | import {X216} from "./X216.sol";
   8 |     | import {FullMathLibrary} from "./FullMath.sol";
   9 |     | 
  10 |     | // Type 'X59' is dedicated to the natural logarithm of price.
  11 |     | type X59 is int256;
  12 |     | 
  13 |     | using X59Library for X59 global;
  14 |     | 
  15 |     | X59 constant zeroX59 = X59.wrap(0);
  16 |     | X59 constant epsilonX59 = X59.wrap(1);
  17 |     | X59 constant oneX59 = X59.wrap(1 << 59);
  18 |     | X59 constant twoX59 = X59.wrap(2 << 59);
  19 |     | X59 constant threeX59 = X59.wrap(3 << 59);
  20 |     | X59 constant fourX59 = X59.wrap(4 << 59);
  21 |     | X59 constant sixteenX59 = X59.wrap(16 << 59);
  22 |     | X59 constant thirtyTwoX59 = X59.wrap(32 << 59);
  23 |     | X59 constant minLogSpacing = X59.wrap((1 << 59) >> 19);
  24 |     | X59 constant minLogStep = X59.wrap((1 << 59) >> 27);
  25 |     | X59 constant minLogOffset = X59.wrap(0 - int256(90 << 59));
  26 |     | X59 constant maxLogOffset = X59.wrap(90 << 59);
  27 |     | X59 constant minX59 = X59.wrap(0 - type(int256).max);
  28 |     | X59 constant maxX59 = X59.wrap(type(int256).max);
  29 |     | 
  30 |     | using {equals as ==, notEqual as !=} for X59 global;
  31 |     | using {lessThan as <, greaterThan as >} for X59 global;
  32 |     | using {
  33 |     |   lessThanOrEqualTo as <=,
  34 |     |   greaterThanOrEqualTo as >=
  35 |     | } for X59 global;
  36 |     | using {add as +, sub as -} for X59 global;
  37 |     | using {mod as %} for X59 global;
  38 |     | 
  39 |     | function equals(
  40 |     |   X59 value0,
  41 |     |   X59 value1
  42 |     | ) pure returns (
  43 |     |   bool result
  44 |     | ) {
  45 |     |   assembly {
  46 |     |     result := eq(value0, value1)
  47 |     |   }
  48 |     | }
  49 |     | 
  50 |     | function notEqual(
  51 |     |   X59 value0,
  52 |     |   X59 value1
  53 |     | ) pure returns (
  54 |     |   bool result
  55 |     | ) {
  56 |     |   return !(value0 == value1);
  57 |     | }
  58 |     | 
  59 |     | function lessThan(
  60 |     |   X59 value0,
  61 |     |   X59 value1
  62 |     | ) pure returns (
  63 |     |   bool result
  64 |     | ) {
  65 |     |   assembly {
  66 |     |     result := slt(value0, value1)
  67 |     |   }
  68 |     | }
  69 |     | 
  70 |     | function greaterThan(
  71 |     |   X59 value0,
  72 |     |   X59 value1
  73 |     | ) pure returns (
  74 |     |   bool result
  75 |     | ) {
  76 |     |   assembly {
  77 |     |     result := sgt(value0, value1)
  78 |     |   }
  79 |     | }
  80 |     | 
  81 |     | function lessThanOrEqualTo(
  82 |     |   X59 value0,
  83 |     |   X59 value1
  84 |     | ) pure returns (
  85 |     |   bool result
  86 |     | ) {
  87 |     |   return !(value0 > value1);
  88 |     | }
  89 |     | 
  90 |     | function greaterThanOrEqualTo(
  91 |     |   X59 value0,
  92 |     |   X59 value1
  93 |     | ) pure returns (
  94 |     |   bool result
  95 |     | ) {
  96 |     |   return !(value0 < value1);
  97 |     | }
  98 |     | 
  99 |     | // Overflow/underflow should be avoided externally.
 100 |     | function add(
 101 |     |   X59 value0,
 102 |     |   X59 value1
 103 |     | ) pure returns (
 104 |     |   X59 result
 105 |     | ) {
 106 |     |   assembly {
 107 |     |     result := add(value0, value1)
 108 |     |   }
 109 |     | }
 110 |     | 
 111 |     | // Overflow/underflow should be avoided externally.
 112 |     | function sub(
 113 |     |   X59 value0,
 114 |     |   X59 value1
 115 |     | ) pure returns (
 116 |     |   X59 result
 117 |     | ) {
 118 |     |   assembly {
 119 |     |     result := sub(value0, value1)
 120 |     |   }
 121 |     | }
 122 |     | 
 123 |     | // 'value' should be non-negative.
 124 |     | // 'modulus' should be positive.
 125 |     | function mod(
 126 |     |   X59 value,
 127 |     |   X59 modulus
 128 |     | ) pure returns (
 129 |     |   X59 result
 130 |     | ) {
 131 |     |   assembly {
 132 |     |     result := mod(value, modulus)
 133 |     |   }
 134 |     | }
 135 |     | 
 136 |     | function min(
 137 |     |   X59 value0,
 138 |     |   X59 value1
 139 |     | ) pure returns (
 140 |     |   X59 result
 141 |     | ) {
 142 |     |   return (value0 < value1) ? value0 : value1;
 143 |     | }
 144 |     | 
 145 |     | function max(
 146 |     |   X59 value0,
 147 |     |   X59 value1
 148 |     | ) pure returns (
 149 |     |   X59 result
 150 |     | ) {
 151 |     |   return (value0 < value1) ? value1 : value0;
 152 |     | }
 153 |     | 
 154 |     | library X59Library {
 155 |     |   // Overflow should be avoided externally.
 156 |     |   // 'value0' should be non-negative.
 157 |     |   function times(
 158 |     |     X59 value0,
 159 |     |     X15 value1
 160 |     |   ) internal pure returns (
 161 |     |     X74 result
 162 |     |   ) {
 163 |     |     assembly {
 164 |     |       result := mul(value0, value1)
 165 |     |     }
 166 |     |   }
 167 |     | 
 168 |     |   /// @notice Calculates '(value * numerator) / denominator' when 
 169 |     |   /// 'value * numerator < denominator * (denominator - 1)'.
 170 |     |   /// The three inputs should be non-negative.
 171 |     |   function cheapMulDiv(
 172 |     |     X59 value,
 173 |     |     X216 numerator,
 174 |     |     X216 denominator
 175 |     |   ) internal pure returns (
 176 |     |     X59 result
 177 |     |   ) {
 178 |     |     // The three castings to 'uint256' are safe because of the 'non-negative'
 179 |     |     // requirement on input values.
 180 |     |     //
 181 |     |     // The casting to 'int256' is safe because
 182 |     |     // 'value * numerator / denominator < denominator - 1 <= 2 ** 255 - 2'.
 183 |     |     //
 184 |     |     // The requirement of 'cheapMulDiv' are met because of the above input
 185 |     |     // requirement.
 186 |     |     result = X59.wrap(int256(FullMathLibrary.cheapMulDiv(
 187 |     |       uint256(X59.unwrap(value)),
 188 |     |       uint256(X216.unwrap(numerator)),
 189 |     |       uint256(X216.unwrap(denominator))
 190 |     |     )));
 191 |     |   }
 192 |     | 
 193 |     |   /// @notice Calculates
 194 |     |   /// '(value * multiplier0 * multiplier1) / ((2 ** (216 + 59)) * exp(-16))'
 195 |     |   /// Overflow should be avoided externally.
 196 |     |   /// All three inputs should be non-negative.
 197 |     |   function mulDivByExpInv16(
 198 |     |     X59 value,
 199 |     |     X216 multiplier0,
 200 |     |     X216 multiplier1
 201 |     |   ) internal pure returns (
 202 |     |     X216 product
 203 |     |   ) {
 204 |     |     assembly {
 205 |     |       // Let 'r := value * multiplier0 * multiplier1 
 206 |     |       //         - floor((2 ** 275) * exp(-16)) * q'.
 207 |     |       //
 208 |     |       // Let 's := value * multiplier0 * multiplier1 - (2 ** 256) * p'.
 209 |     |       //
 210 |     |       // Then 's - r == floor((2 ** 275) * exp(-16)) * q' [modulo '2 ** 256']
 211 |     |       product := mul(
 212 |     |         sub(
 213 |     |           // s
 214 |     |           mul(mul(value, multiplier0), multiplier1),
 215 |     |           // r
 216 |     |           mulmod(
 217 |     |             mulmod(
 218 |     |               value,
 219 |     |               multiplier0,
 220 |     |               // floor((2 ** 275) * exp(-16))
 221 |     |               0xF1AADDD7742E56D32FB9F997447D9E6314DB84884FABAB26BF059AF9BC20B61
 222 |     |             ),
 223 |     |             multiplier1,
 224 |     |             // floor((2 ** 275) * exp(-16))
 225 |     |             0xF1AADDD7742E56D32FB9F997447D9E6314DB84884FABAB26BF059AF9BC20B61
 226 |     |           )
 227 |     |         ),
 228 |     |         // modularInverse(floor((2 ** 275) * exp(-16)), 2 ** 256)
 229 |     |         0xD49C04AF80AF1EA5F98F85886B450A4B264FC14874F9F64143836145A37DD8A1
 230 |     |       )
 231 |     |     }
 232 |     |   }
 233 |     | 
 234 |     |   /// @notice Calculates '(2 ** 256) * exp(- x / (2 ** 60))'.
 235 |     |   /// "Pade Approximant" is employed for this purpose:
 236 |     |   /// 'exp(- x / (2 ** 60)) ~= ((u(x) - v(x)) / (u(x) + v(x))) ** (2 ** 14)'
 237 |     |   /// where
 238 |     |   ///                x ** 2      x ** 4       x ** 6          x ** 8
 239 |     |   /// 'u(x) = 1 + 7 --------- + --------- + ----------- + --------------'
 240 |     |   ///                15<<150     39<<300     6435<<449     2027025<<600
 241 |     |   /// and
 242 |     |   ///            x       x ** 3       x ** 5        x ** 7
 243 |     |   /// 'v(x) = ------- + --------- + ---------- + -------------'.
 244 |     |   ///          1<<75     15<<224     585<<374     225225<<523
 245 |     |   ///
 246 |     |   /// This formula can be reproduced via the following Mathematica command:
 247 |     |   /// 'PadeApproximant[Exp[- x / (2 ^ 74)], {x, 0, 8}]'.
 248 |     |   ///
 249 |     |   /// Input should be greater than '0' and less than '2 ** 64'.
 250 |     |   function expInverse(
 251 |     |     X59 value
 252 |     |   ) internal pure returns (
 253 |     |     uint256 exponentialInverse
 254 |     |   ) {
 255 |     |     unchecked {
 256 |     |       // Casting is safe because 'value' is between '0' and '2 ** 64'.
 257 |     |       uint256 x = uint256(X59.unwrap(value));
 258 |     |       
 259 |     |       // x ** 2
 260 |     |       uint256 x2 = x * x;
 261 |     |       
 262 |     |       // x ** 4
 263 |     |       uint256 x4 = x2 * x2;
 264 |     | 
 265 |     |       // (x ** 6) / (2 ** 128)
 266 |     |       uint256 x6;
 267 |     |       assembly {
 268 |     |         // Let 'r := x2 * x4 - (2 ** 128) * q'
 269 |     |         // Let 's := x2 * x4 - (2 ** 256 - 1) * p'
 270 |     |         // Then 's - r == (2 ** 128) * q' [modulo '2 ** 256 - 1']
 271 |     |         // And 'q == (2 ** 128) * (s - r)' [modulo '2 ** 256 - 1']
 272 |     |         // Calculation modulo '2 ** 256 - 1' is safe because:
 273 |     |         // '((2 ** 64 - 1) ** 6) / (2 ** 128) < 2 ** 256 - 1'
 274 |     |         x6 := mulmod(
 275 |     |           // The subtraction is safe because the remainder is greater than or
 276 |     |           // equal to the second one.
 277 |     |           sub(mulmod(x2, x4, not(0)), mulmod(x2, x4, shl(128, 1))),
 278 |     |           shl(128, 1),
 279 |     |           not(0)
 280 |     |         )
 281 |     |       }
 282 |     | 
 283 |     |       // (x ** 8) / (2 ** 256)
 284 |     |       uint256 x8;
 285 |     |       assembly {
 286 |     |         // Let 'r := x4 * x4 - (2 ** 256) * q'
 287 |     |         // Let 's := x4 * x4 - (2 ** 256 - 1) * p'
 288 |     |         // Then 's - r == q' [modulo '2 ** 256 - 1']
 289 |     |         // Calculation modulo '2 ** 256 - 1' is safe because:
 290 |     |         // '((2 ** 64 - 1) ** 8) / (2 ** 256) < 2 ** 256 - 1'
 291 |     |         x8 := sub(mulmod(x4, x4, not(0)), mul(x4, x4))
 292 |     |       }
 293 |     | 
 294 |     |       // (2 ** 254) * u(x)
 295 |     |       // The additions are safe because the first term is '1 << 254' and none
 296 |     |       // of the other terms exceed '1 << 250'.
 297 |     |       uint256 a = 
 298 |     |         ((x2 * (7 << 104)) / 15) + 
 299 |     |         (x4 / (39 << 46)) + 
 300 |     |         (x6 / (6435 << 67)) + 
 301 |     |         (x8 / (2027025 << 90)) + 
 302 |     |         (1 << 254);
 303 |     | 
 304 |     |       // (2 ** 254) * v(x)
 305 |     |       // The additions are safe because the first term is '1 << 255' and none
 306 |     |       // of the other terms exceed '1 << 250'.
 307 |     |       uint256 b = 
 308 |     |         ((x2 << 106) / 15) + 
 309 |     |         (x4 / (585 << 44)) + 
 310 |     |         (x6 / (225225 << 65)) + 
 311 |     |         (1 << 255);
 312 |     |         
 313 |     |       assembly {
 314 |     |         // Here we multiply the result by (x / (2 ** 76)).
 315 |     |         // Let 'r := x * b - (2 ** 76) * q'
 316 |     |         // Let 's := x * b - (2 ** 256 - 1) * p'
 317 |     |         // Then 's - r == (2 ** 76) * q' [modulo '2 ** 256 - 1']
 318 |     |         // And 'q == (2 ** 180) * (s - r)' [modulo '2 ** 256 - 1']
 319 |     |         // Calculation modulo '2 ** 256 - 1' is safe because:
 320 |     |         // 'b < 2 ** 256 - 1'
 321 |     |         b := mulmod(
 322 |     |           // The subtraction is safe because the remainder is greater than or
 323 |     |           // equal to the second one.
 324 |     |           sub(mulmod(x, b, not(0)), mulmod(x, b, shl(76, 1))),
 325 |     |           shl(180, 1),
 326 |     |           not(0)
 327 |     |         )
 328 |     |       }
 329 |     | 
 330 |     |       // (2 ** 256) * (u(x) - v(x)) / (u(x) + v(x))
 331 |     |       // Since '(2 ** 254) * (a - b) - (a + b) * (a + b - 1)' is a
 332 |     |       // decreasing function with respect to 'x', it suffices to verify
 333 |     |       // that '(2 ** 254) * (a - b) - (a + b) * (a + b - 1) < 0' only for
 334 |     |       // 'x == 1' which is true. Hence, the requirement of 'cheapMulDiv' is
 335 |     |       // satisfied.
 336 |     |       a = FullMathLibrary.cheapMulDiv(a - b, 1 << 254, a + b) << 2;
 337 |     | 
 338 |     |       // Next, we compute 'f(f(f(f(f(f(f(f(f(f(f(f(f(f(a))))))))))))))'
 339 |     |       // where 'f(y) = (y ** 2) / (2 ** 256 - 1) ~ (y ** 2) / (2 ** 256)'
 340 |     |       // This is because of the '2 ** 14' term which was discussed before.
 341 |     |       assembly {
 342 |     |         a := sub(
 343 |     |           mulmod(a, a, not(0)), // s := a * a - q * not(0)
 344 |     |           mul(a, a) // r := a * a
 345 |     |         ) // s - r == - q * not(0) == q
 346 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 347 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 348 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 349 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 350 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 351 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 352 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 353 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 354 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 355 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 356 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 357 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 358 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 359 |     |       }
 360 |     | 
 361 |     |       return a;
 362 |     |     }
 363 |     |   }
 364 |     | 
 365 |     |   /// @notice Transforms natural logarithm of price to square root of price.
 366 |     |   /// @param value The input whose exponential to be calculated.
 367 |     |   /// @return exponentialInverse is '(2 ** 216) * exp(- x / (2 ** 60))'
 368 |     |   /// @return exponentialOverExp16 is '(2 ** 216) * exp(- 16 + x / (2 ** 60))'
 369 |     |   /// Input should be greater than 0 and less than (2 ** 64).
 370 |     |   function exp(
 371 |     |     X59 value
 372 |     |   ) internal pure returns (
 373 |     |     X216 exponentialInverse,
 374 |     |     X216 exponentialOverExp16
 375 |     |   ) {
 376 |     |     // The requirements of 'expInverse' are the same as the requirements here.
 377 |     |     uint256 a = expInverse(value);
 378 |     | 
 379 |     |     // Since '0 < value < 2 ** 64', we have
 380 |     |     // '(2 ** 256) * exp(-16) < a < (2 ** 256)', hence
 381 |     |     // '(2 ** 472) * exp(-16) < a * (a - 1)' and the requirements of
 382 |     |     // 'cheapMulDiv' are satisfied.
 383 |     |     //
 384 |     |     // Casting to 'int256' is safe because the output of 'cheapMulDiv' is
 385 |     |     // non-negative and it is less than 'oneX216'.
 386 |     |     //
 387 |     |     // So, we can calculate '(2 ** 472) * exp(-16) / a' as follows:
 388 |     |     exponentialOverExp16 = X216.wrap(int256(FullMathLibrary.cheapMulDiv(
 389 |     |       // (2 ** 279) * exp(-16)
 390 |     |       0xF1AADDD7742E56D32FB9F997447D9E6314DB84884FABAB26BF059AF9BC20B609,
 391 |     |       1 << 193,
 392 |     |       a
 393 |     |     )));
 394 |     | 
 395 |     |     // Casting to 'int256' is safe because 'a >> 40' is non-negative and it is
 396 |     |     // less than 'oneX216'.
 397 |     |     exponentialInverse = X216.wrap(int256(a >> 40));
 398 |     |   }
 399 |     | 
 400 |     |   /// @notice Transforms natural logarithm of price to square root of price.
 401 |     |   /// "Pade Approximant" is employed for this purpose:
 402 |     |   /// 'exp(- x / (2 ** 60)) ~= ((u(x) - v(x)) / (u(x) + v(x))) ** (2 ** 48)'
 403 |     |   /// where
 404 |     |   ///              x ** 2
 405 |     |   /// 'u(x) = 1 + --------'
 406 |     |   ///              3<<218
 407 |     |   /// and
 408 |     |   ///             x
 409 |     |   /// 'v(x) = --------'.
 410 |     |   ///          1<<109
 411 |     |   ///
 412 |     |   /// This formula can be reproduced via the following Mathematica command:
 413 |     |   /// 'PadeApproximant[Exp[- x / (2 ^ 108)], {x, 0, 2}]'.
 414 |     |   ///
 415 |     |   /// @param value The input whose exponential to be calculated.
 416 |     |   /// @return exponentialInverse is '(2 ** 256) * exp(- x / (2 ** 60))'
 417 |     |   /// Input should be positive and less than '2 * maxLogOffset'.
 418 |     |   function expOffset(
 419 |     |     X59 value
 420 |     |   ) internal pure returns (
 421 |     |     uint256 exponentialInverse
 422 |     |   ) {
 423 |     |     unchecked {
 424 |     |       // Casting is safe because 'value' is between '0' and '2 ** 64'.
 425 |     |       uint256 x = uint256(X59.unwrap(value));
 426 |     | 
 427 |     |       // (2 ** 255) * u(x)
 428 |     |       // The multiplication and addition are safe because 'x < 2 ** 64'.
 429 |     |       uint256 a = (((x * x) << 37) / 3) + (1 << 255);
 430 |     | 
 431 |     |       // (2 ** 255) * v(x)
 432 |     |       // The shift is safe because 'x < 2 ** 64'.
 433 |     |       x <<= 146;
 434 |     | 
 435 |     |       // The requirements of 'cheapMulDiv' are satisfied because
 436 |     |       // (a - x) * (2 ** 254) - (a + x) (a + x - 1) is a decreasing function
 437 |     |       // with respect to 'x'. Hence, we just need to verify that it is negative
 438 |     |       // for 'x == 1' which is true.
 439 |     |       a = FullMathLibrary.cheapMulDiv(a - x, 1 << 254, a + x) << 2;
 440 |     | 
 441 |     |       // Next, we apply the function 
 442 |     |       // 'f(y) = (y ** 2) / (2 ** 256 - 1) ~ (y ** 2) / (2 ** 256)', 48 times.
 443 |     |       // This is because of the '2 ** 48' term which was discussed before.
 444 |     |       assembly {
 445 |     |         a := sub(
 446 |     |           mulmod(a, a, not(0)), // s := a * a - q * not(0)
 447 |     |           mul(a, a) // r := a * a
 448 |     |         ) // s - r == - q * not(0) == q
 449 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 450 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 451 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 452 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 453 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 454 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 455 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 456 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 457 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 458 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 459 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 460 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 461 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 462 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 463 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 464 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 465 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 466 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 467 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 468 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 469 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 470 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 471 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 472 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 473 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 474 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 475 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 476 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 477 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 478 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 479 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 480 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 481 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 482 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 483 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 484 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 485 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 486 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 487 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 488 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 489 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 490 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 491 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 492 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 493 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 494 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 495 |     |         a := sub(mulmod(a, a, not(0)), mul(a, a))
 496 |     |       }
 497 |     | 
 498 |     |       return a;
 499 |     |     }
 500 |     |   }
 501 |     | 
 502 |     |   /// @notice Transforms natural logarithm of price in two's complement to
 503 |     |   /// square root of price.
 504 |     |   /// Input should be between 'minLogOffset' and 'maxLogOffset'.
 505 |     |   /// @param logOffset The input whose exponential to be calculated.
 506 |     |   /// @return sqrtOffset is '(2 ** 127) * exp(logOffset / (2 ** 60))'
 507 |     |   function logToSqrtOffset(
 508 |     |     X59 logOffset
 509 |     |   ) internal pure returns (
 510 |     |     X127 sqrtOffset
 511 |     |   ) {
 512 |     |     // '(2 ** 256) * exp(- (maxLogOffset - logOffset) / (2 ** 60))'
 513 |     |     // The requirements of 'expOffset' are satisfied here because:
 514 |     |     // 'minLogOffset < logOffset < maxLogOffset'
 515 |     |     // '0 < maxLogOffset - logOffset < 
 516 |     |     //      maxLogOffset - minLogOffset == 2 * maxLogOffset'.
 517 |     |     uint256 exponential = (maxLogOffset - logOffset).expOffset();
 518 |     |     // (2 ** (256 + 191)) * exp(- (maxLogOffset - logOffset) / (2 ** 60)) / 
 519 |     |     // ((2 ** 320) * exp(-45))
 520 |     |     assembly {
 521 |     |       // Let 's := exponential * (2 ** 191) - (2 ** 256) * p'
 522 |     |       // Let 'r := exponential * (2 ** 191) - floor((2 ** 320) * exp(-45)) * q'
 523 |     |       // Then 's - r == floor((2 ** 320) * exp(-45)) * q' [modulo '2 ** 256']
 524 |     |       sqrtOffset := mul(
 525 |     |         // s - r
 526 |     |         sub(
 527 |     |           // s
 528 |     |           mul(exponential, shl(191, 1)), // Because '256 + 191 - 320 == 127'
 529 |     |           // r
 530 |     |           mulmod(
 531 |     |             exponential,
 532 |     |             shl(191, 1),
 533 |     |             // floor((2 ** 320) * exp(-45))
 534 |     |             0x872DB9E8FFA9E7D41F2AAF39897B91E4002E70FCEED391471FAD73D51503772D
 535 |     |           )
 536 |     |         ),
 537 |     |         // modularInverse(floor((2 ** 320) * exp(-45)), 2 ** 256)
 538 |     |         0xCF8E41E6C4D4AA5E9CC597C10CD32EACD30C44F750A8FFDB1A8863DD8F72F0A5
 539 |     |       )
 540 |     |     }
 541 |     |   }
 542 |     | }

R:/LIAT.AI/nofeeswap-core/contracts/utilities/X74.sol
  1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
  2 |     | pragma solidity ^0.8.28;
  3 |     | 
  4 |     | import {X216} from "./X216.sol";
  5 |     | 
  6 |     | // Type 'X74' is used as an intermediate type when searching for precise log
  7 |     | // price movement corresponding to the specified outgoing/incoming token 
  8 |     | // amounts.
  9 |     | type X74 is int256;
 10 |     | 
 11 |     | X74 constant zeroX74 = X74.wrap(0);
 12 |     | 
 13 |     | using {equals as ==, notEqual as !=} for X74 global;
 14 |     | using {add as +, sub as -} for X74 global;
 15 |     | 
 16 |     | using X74Library for X74 global;
 17 |     | 
 18 |     | function equals(
 19 |     |   X74 value0,
 20 |     |   X74 value1
 21 |     | ) pure returns (
 22 |     |   bool result
 23 |     | ) {
 24 |     |   assembly {
 25 |     |     result := eq(value0, value1)
 26 |     |   }
 27 |     | }
 28 |     | 
 29 |     | function notEqual(
 30 |     |   X74 value0,
 31 |     |   X74 value1
 32 |     | ) pure returns (
 33 |     |   bool result
 34 |     | ) {
 35 |     |   return !(value0 == value1);
 36 |     | }
 37 |     | 
 38 |     | // Overflow/underflow should be avoided externally.
 39 |     | function add(
 40 |     |   X74 value0,
 41 |     |   X74 value1
 42 |     | ) pure returns (
 43 |     |   X74 result
 44 |     | ) {
 45 |     |   assembly {
 46 |     |     result := add(value0, value1)
 47 |     |   }
 48 |     | }
 49 |     | 
 50 |     | // Overflow/underflow should be avoided externally.
 51 |     | function sub(
 52 |     |   X74 value0,
 53 |     |   X74 value1
 54 |     | ) pure returns (
 55 |     |   X74 result
 56 |     | ) {
 57 |     |   assembly {
 58 |     |     result := sub(value0, value1)
 59 |     |   }
 60 |     | }
 61 |     | 
 62 |     | library X74Library {
 63 |     |   // Converts type 'X74' to 'X216'.
 64 |     |   // Overflow should be avoided externally.
 65 |     |   function toX216(
 66 |     |     X74 value
 67 |     |   ) internal pure returns (
 68 |     |     X216 result
 69 |     |   ) {
 70 |     |     assembly {
 71 |     |       // Multiplication is safe because overflow is avoided externally.
 72 |     |       result := mul(shl(142, 1), value)
 73 |     |     }
 74 |     |   }
 75 |     | }

R:/LIAT.AI/nofeeswap-core/echidna/PriceTestSimple.sol
   1 |     | // Copyright 2025, NoFeeSwap LLC - All rights reserved.
   2 |     | // SPDX-License-Identifier: UNLICENSED
   3 |     | pragma solidity ^0.8.28;
   4 |     | 
   5 |     | import "../contracts/utilities/Price.sol";
   6 |     | import "../contracts/utilities/X15.sol";
   7 |     | import "../contracts/utilities/X59.sol";
   8 |     | import "../contracts/utilities/X216.sol";
   9 |     | 
  10 |     | /// @title Simple Echidna test for Price.sol (Property mode)
  11 |     | /// @notice This tests the storePrice function with randomized inputs
  12 |     | /// @dev Uses property mode for fuzzing
  13 | *r  | contract PriceTestSimple {
  14 |     |     using PriceLibrary for uint256;
  15 |     | 
  16 |     |     // Test counter
  17 | *   |     uint256 public testCount;
  18 |     | 
  19 |     |     /// @notice Test storePrice function - Echidna will call this with random inputs
  20 |     |     /// @param logPriceRaw Random log price value
  21 |     |     /// @param sqrtPriceRaw Random sqrt price value
  22 |     |     /// @param sqrtInversePriceRaw Random sqrt inverse price value
  23 | *   |     function test_storePrice_basic(
  24 |     |         int256 logPriceRaw,
  25 |     |         int256 sqrtPriceRaw,
  26 |     |         int256 sqrtInversePriceRaw
  27 |     |     ) public {
  28 | *   |         testCount++;
  29 |     | 
  30 |     |         // Constrain to valid ranges
  31 | *   |         if (logPriceRaw <= 0) logPriceRaw = 1;
  32 | *   |         if (logPriceRaw >= 2**64) logPriceRaw = logPriceRaw % (2**64);
  33 | *   |         if (sqrtPriceRaw < 0) sqrtPriceRaw = -sqrtPriceRaw;
  34 | *   |         if (sqrtInversePriceRaw < 0) sqrtInversePriceRaw = -sqrtInversePriceRaw;
  35 |     | 
  36 | *   |         X59 logPrice = X59.wrap(logPriceRaw);
  37 | *   |         X216 sqrtPrice = X216.wrap(sqrtPriceRaw);
  38 | *   |         X216 sqrtInversePrice = X216.wrap(sqrtInversePriceRaw);
  39 |     | 
  40 |     |         // Setup memory
  41 | *   |         uint256 pricePointer;
  42 | *   |         assembly {
  43 |     |             pricePointer := add(mload(0x40), 64)
  44 |     |             mstore(0x40, add(pricePointer, 128))
  45 |     |         }
  46 |     | 
  47 |     |         // Store the price
  48 | *   |         pricePointer.storePrice(logPrice, sqrtPrice, sqrtInversePrice);
  49 |     | 
  50 |     |         // Read back
  51 | *   |         X59 logResult = pricePointer.log();
  52 | *   |         X216 sqrtResult = pricePointer.sqrt(false);
  53 | *   |         X216 sqrtInverseResult = pricePointer.sqrt(true);
  54 |     | 
  55 |     |         // Assert values match (this is the property we're testing)
  56 | *   |         assert(X59.unwrap(logResult) == X59.unwrap(logPrice));
  57 | *   |         assert(X216.unwrap(sqrtResult) == X216.unwrap(sqrtPrice));
  58 | *   |         assert(X216.unwrap(sqrtInverseResult) == X216.unwrap(sqrtInversePrice));
  59 |     |     }
  60 |     | 
  61 |     |     /// @notice Test with height parameter
  62 | *   |     function test_storePrice_with_height(
  63 |     |         int256 heightPriceRaw,
  64 |     |         int256 logPriceRaw,
  65 |     |         int256 sqrtPriceRaw,
  66 |     |         int256 sqrtInversePriceRaw
  67 |     |     ) public {
  68 | *   |         testCount++;
  69 |     | 
  70 |     |         // Constrain inputs
  71 | *   |         if (heightPriceRaw < 0) heightPriceRaw = -heightPriceRaw;
  72 | *   |         if (heightPriceRaw >= 2**16) heightPriceRaw = heightPriceRaw % (2**16);
  73 | *   |         if (logPriceRaw <= 0) logPriceRaw = 1;
  74 | *   |         if (logPriceRaw >= 2**64) logPriceRaw = logPriceRaw % (2**64);
  75 | *   |         if (sqrtPriceRaw < 0) sqrtPriceRaw = -sqrtPriceRaw;
  76 | *   |         if (sqrtInversePriceRaw < 0) sqrtInversePriceRaw = -sqrtInversePriceRaw;
  77 |     | 
  78 | *   |         X15 heightPrice = X15.wrap(uint16(uint256(heightPriceRaw)));
  79 | *   |         X59 logPrice = X59.wrap(logPriceRaw);
  80 | *   |         X216 sqrtPrice = X216.wrap(sqrtPriceRaw);
  81 | *   |         X216 sqrtInversePrice = X216.wrap(sqrtInversePriceRaw);
  82 |     | 
  83 | *   |         uint256 pricePointer;
  84 | *   |         assembly {
  85 |     |             pricePointer := add(mload(0x40), 66)
  86 |     |             mstore(0x40, add(pricePointer, 128))
  87 |     |         }
  88 |     | 
  89 | *   |         pricePointer.storePrice(heightPrice, logPrice, sqrtPrice, sqrtInversePrice);
  90 |     | 
  91 | *   |         X15 heightResult = pricePointer.height();
  92 | *   |         X59 logResult = pricePointer.log();
  93 | *   |         X216 sqrtResult = pricePointer.sqrt(false);
  94 | *   |         X216 sqrtInverseResult = pricePointer.sqrt(true);
  95 |     | 
  96 | *   |         assert(X15.unwrap(heightResult) == X15.unwrap(heightPrice));
  97 | *   |         assert(X59.unwrap(logResult) == X59.unwrap(logPrice));
  98 | *   |         assert(X216.unwrap(sqrtResult) == X216.unwrap(sqrtPrice));
  99 | *   |         assert(X216.unwrap(sqrtInverseResult) == X216.unwrap(sqrtInversePrice));
 100 |     |     }
 101 |     | 
 102 |     |     /// @notice Test copyPrice function
 103 | *   |     function test_copyPrice(
 104 |     |         int256 logPriceRaw,
 105 |     |         int256 sqrtPriceRaw,
 106 |     |         int256 sqrtInversePriceRaw
 107 |     |     ) public {
 108 | *   |         testCount++;
 109 |     | 
 110 | *   |         if (logPriceRaw <= 0) logPriceRaw = 1;
 111 | *   |         if (logPriceRaw >= 2**64) logPriceRaw = logPriceRaw % (2**64);
 112 | *   |         if (sqrtPriceRaw < 0) sqrtPriceRaw = -sqrtPriceRaw;
 113 | *   |         if (sqrtInversePriceRaw < 0) sqrtInversePriceRaw = -sqrtInversePriceRaw;
 114 |     | 
 115 | *   |         X59 logPrice = X59.wrap(logPriceRaw);
 116 | *   |         X216 sqrtPrice = X216.wrap(sqrtPriceRaw);
 117 | *   |         X216 sqrtInversePrice = X216.wrap(sqrtInversePriceRaw);
 118 |     | 
 119 | *   |         uint256 pricePointer0;
 120 | *   |         uint256 pricePointer1;
 121 |     | 
 122 | *   |         assembly {
 123 |     |             let freePtr := mload(0x40)
 124 |     |             pricePointer0 := add(freePtr, 64)
 125 |     |             pricePointer1 := add(freePtr, 128)
 126 |     |             mstore(0x40, add(freePtr, 256))
 127 |     |         }
 128 |     | 
 129 | *   |         pricePointer1.storePrice(logPrice, sqrtPrice, sqrtInversePrice);
 130 | *   |         pricePointer0.copyPrice(pricePointer1);
 131 |     | 
 132 | *   |         X59 logResult = pricePointer0.log();
 133 | *   |         X216 sqrtResult = pricePointer0.sqrt(false);
 134 | *   |         X216 sqrtInverseResult = pricePointer0.sqrt(true);
 135 |     | 
 136 | *   |         assert(X59.unwrap(logResult) == X59.unwrap(logPrice));
 137 | *   |         assert(X216.unwrap(sqrtResult) == X216.unwrap(sqrtPrice));
 138 | *   |         assert(X216.unwrap(sqrtInverseResult) == X216.unwrap(sqrtInversePrice));
 139 |     |     }
 140 |     | 
 141 |     |     /// @notice Memory corruption test - random pointer location
 142 | *   |     function test_storePrice_memory_safety(
 143 |     |         uint256 pointerOffset,
 144 |     |         int256 logPriceRaw,
 145 |     |         int256 sqrtPriceRaw,
 146 |     |         int256 sqrtInversePriceRaw
 147 |     |     ) public {
 148 | *   |         testCount++;
 149 |     | 
 150 | *   |         if (logPriceRaw <= 0) logPriceRaw = 1;
 151 | *   |         if (logPriceRaw >= 2**64) logPriceRaw = logPriceRaw % (2**64);
 152 | *   |         if (sqrtPriceRaw < 0) sqrtPriceRaw = -sqrtPriceRaw;
 153 | *   |         if (sqrtInversePriceRaw < 0) sqrtInversePriceRaw = -sqrtInversePriceRaw;
 154 |     | 
 155 |     |         // Random pointer offset (32 to 512 bytes)
 156 | *   |         pointerOffset = 32 + (pointerOffset % 480);
 157 |     | 
 158 | *   |         X59 logPrice = X59.wrap(logPriceRaw);
 159 | *   |         X216 sqrtPrice = X216.wrap(sqrtPriceRaw);
 160 | *   |         X216 sqrtInversePrice = X216.wrap(sqrtInversePriceRaw);
 161 |     | 
 162 | *   |         uint256 pricePointer;
 163 | *   |         bytes32 guardBefore;
 164 | *   |         bytes32 guardAfter;
 165 |     | 
 166 | *   |         assembly {
 167 |     |             let freePtr := mload(0x40)
 168 |     | 
 169 |     |             // Place guard before
 170 |     |             mstore(freePtr, 0xDEADBEEFDEADBEEFDEADBEEFDEADBEEFDEADBEEFDEADBEEFDEADBEEFDEADBEEF)
 171 |     |             guardBefore := mload(freePtr)
 172 |     | 
 173 |     |             pricePointer := add(freePtr, pointerOffset)
 174 |     | 
 175 |     |             // Place guard after
 176 |     |             mstore(add(pricePointer, 62), 0xBADC0FFEEBADC0FFEEBADC0FFEEBADC0FFEEBADC0FFEEBADC0FFEEBADC0FFEEE)
 177 |     |             guardAfter := mload(add(pricePointer, 62))
 178 |     | 
 179 |     |             mstore(0x40, add(pricePointer, 256))
 180 |     |         }
 181 |     | 
 182 |     |         // Store price
 183 | *   |         pricePointer.storePrice(logPrice, sqrtPrice, sqrtInversePrice);
 184 |     | 
 185 |     |         // Verify values
 186 | *   |         X59 logResult = pricePointer.log();
 187 | *   |         X216 sqrtResult = pricePointer.sqrt(false);
 188 | *   |         X216 sqrtInverseResult = pricePointer.sqrt(true);
 189 |     | 
 190 | *   |         assert(X59.unwrap(logResult) == X59.unwrap(logPrice));
 191 | *   |         assert(X216.unwrap(sqrtResult) == X216.unwrap(sqrtPrice));
 192 | *   |         assert(X216.unwrap(sqrtInverseResult) == X216.unwrap(sqrtInversePrice));
 193 |     | 
 194 |     |         // Check memory guards weren't corrupted
 195 | *   |         bytes32 checkBefore;
 196 | *   |         bytes32 checkAfter;
 197 | *   |         assembly {
 198 |     |             checkBefore := mload(sub(pricePointer, pointerOffset))
 199 |     |             checkAfter := mload(add(pricePointer, 62))
 200 |     |         }
 201 |     | 
 202 | *   |         assert(guardBefore == checkBefore); // Memory before should be intact
 203 | *   |         assert(guardAfter == checkAfter);   // Memory after should be intact
 204 |     |     }
 205 |     | }

